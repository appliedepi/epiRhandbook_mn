---
knit: "bookdown::render_book"
title: "Тархвар судлаачийн R гарын авлага"  
description: "Тархвар судлаачийн R гарын авлага нь тархвар судлал, нийгмийн эрүүл мэндэд зориулсан R-ын лавлагаа сурах бичиг юм."
author: "гарын авлагын баг"
date: "`r Sys.Date()`"
#url: 'https://github.com/appliedepi/epiRhandbook_mn'
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
# output: bookdown::gitbook:
#      config:
#           sharing:
#                twitter: yes
#                facebook: yes
#                whatsapp: yes
#                github: yes
documentclass: book
---





#  {-}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Epi R Handbook banner beige 1500x500.png"))
# library(knitr)
# opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<meta name="description" content="Тархвар судлаачийн R гарын авлага нь тархвар судлал, нийгмийн эрүүл мэндэд зориулсан R-ын лавлагаа сурах бичиг юм.">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!-- <span style="color: red;">**THIS IS A DRAFT.  REVIEWERS GIVE FEEDBACK AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**.</span> -->

<!-- <span style="color: darkgreen;">**DO YOU LIKE THIS HANDBOOK? SHOULD SOMETHING BE CHANGED? PLEASE TELL US!**</span> -->

<!-- <form target="_blank" action="https://forms.gle/A5SnRVws7tPD15Js9"> -->
<!--     <input type="submit" value="FEEDBACK" /> -->
<!-- </form> -->

<!-- ======================================================= -->
<!-- ## An R reference manual for applied epidemiology and public health {.unnumbered} -->


<!-- <span style="color: brown;">**The Epi R Handbook is an R reference manual for applied epidemiology and public health.**</span> -->

<!-- ## About this handbook   -->

## R-ыг тархвар судлал, нийгмийн эрүүл мэндэд ашиглах нь {-}  

**Энэхүү ном дараах зорилтуудтай:**  

* Эпи R кодын түргэн лавлагаа хэлбэрээр туслах  
* Нийтлэг тархвар судлалын асуудлуудыг шийдвэрлэхэд чиглэсэн даалгавар-төвт жишээнүүдээр хангах  
* R луу шилжиж буй тархвар судлаачдад туслах  
* Интернет холболт муутай орчинд **офлайн хувилбар**[Download handbook and data] ашиглан хандах боломжтой**  


<!-- * Use practical epi examples - cleaning case linelists, making transmission chains and epidemic curves, automated reports and dashboards, modeling incidence and making projections, demographic pyramids and rate standardization, record matching, outbreak detection, survey analysis, survival analysis, GIS basics, contact tracing, phylogenetic trees...   -->



<!-- **How is this different than other R books?**   -->

<!-- * It is community-driven - *written for epidemiologists by epidemiologists* in their spare time and leveraging experience in local, national, academic, and emergency settings   -->

<!-- Dual-column created based on the rmarkdown cookbook here: https://bookdown.org/yihui/rmarkdown-cookbook/multi-column.html -->



<br>


:::: {style="display: flex;"}

::: {}
```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "epiRhandbook_HexSticker_500x500.png"))
```
:::


::: {.col data-latex="{0.05\textwidth}"}
\ 
<!-- an empty Div (with a white space), serving as
a column separator -->
:::

::: {}
<span style="color: black;">**Тархвар судлаачид тархвар судлаачиддаа зориулж бичив**</span>

Бид дэлхийн өнцөг булан бүрд буй тархвар судлаачид бөгөөд энэ номыг өөрсдийн мэргэжил нэгтнүүддээ санал болгохын тулд чөлөөт цагаараа бичлээ. Та бүгдийн санал хүсэлт, урмын үгийг хүлээн авахад таатай байна:  

* Маягт **[санал хүсэлтийн маягт](https://forms.gle/A5SnRVws7tPD15Js9)**  
* Имэйл **epiRhandbook@gmail.com** эсвэл жиргээ **[\@epiRhandbook](https://twitter.com/epirhandbook)**  
* Манай **[Github repository](https://github.com/epirhandbook/Epi_R_handbook)** руу асуудлаа (Issues) оруулах  

:::

::::




<!-- ======================================================= -->
## Энэхүү гарын авлагыг хэрхэн ашиглах вэ {-} 

* Номын гарчгуудын агуулгыг харах, эсвэл хайлтыг ашиглана уу
* Кодыг хуулахын тулд "хуулах" товчийг дарна уу  
* [Жишээний датаг][Гарын авлага болон дата татаж авах] ашиглан дагаж хийж болно   
* Дэлгэрэнгүй материалыг хуудас бүрийн "Нэмэлт материал" хэсгээс үзнэ үү  

**Офлайн хувилбар**  

[Гарын авлага болон дата татаж авах] хуудаснаас зааврыг харна уу.  



<!-- ======================================================= -->
## Талархал {-}  

Энэхүү гарын авлагыг дэлхий даяарх эпидемиологичид өөрсдийн орон нутаг, муж, үндэсний эрүүл мэндийн байгууллагууд, Дэлхийн эрүүл мэндийн байгууллага (ДЭМБ), Médecins Sans Frontières / Хил хязгааргүй эмч нар (MSF), эмнэлэг, их сургуулиуд зэрэгт ажиллаж буй туршлагаас үндэслэн хамтын ажиллагааны үр дүнд бүтээсэн болно.

Энэхүү гарын авлага нь ямар нэгэн байгууллагын гаргаж буй бүтээл **биш** юм. Хэдийгээр бид номны агуулга үнэн зөв байхыг хичээсэн ч энэхүү номонд багтсан агуулгад баталгаа өгөхгүй.  


### Оролцогчид {-}  

**Ерөнхий редактор:** [Neale Batra](https://www.linkedin.com/in/neale-batra/) 

**Төслийн үндсэн баг:** [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Amrish Baidjoe](https://twitter.com/Ammer_B), Pat Keating, [Henry Laurenson-Schafer](https://github.com/henryls1), [Finlay Campbell](https://github.com/finlaycampbell)  

**Зохиогчид**: [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Paula Blomquist](https://www.linkedin.com/in/paula-bianca-blomquist-53188186/), [Finlay Campbell](https://github.com/finlaycampbell), [Henry Laurenson-Schafer](https://github.com/henryls1), [Isaac Florence](www.Twitter.com/isaacatflorence), [Natalie Fischer](https://www.linkedin.com/in/nataliefischer211/), [Aminata Ndiaye](https://twitter.com/aminata_fadl), [Liza Coyer]( https://www.linkedin.com/in/liza-coyer-86022040/), [Jonathan Polonsky](https://twitter.com/jonny_polonsky), [Yurie Izawa](https://ch.linkedin.com/in/yurie-izawa-a1590319), [Chris Bailey](https://twitter.com/cbailey_58?lang=en), [Daniel Molling](https://www.linkedin.com/in/daniel-molling-4005716a/), [Isha Berry](https://twitter.com/ishaberry2), [Emma Buajitti](https://twitter.com/buajitti), [Mathilde Mousset](https://mathildemousset.wordpress.com/research/), [Sara Hollis](https://www.linkedin.com/in/saramhollis/), Wen Lin  

**Хянагчид**: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, [Berhe Etsay](https://www.linkedin.com/in/berhe-etsay-5752b1154/), John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, [Flavio Finger](ffinger.github.io), Tim Taylor, [Jae Hyoung Tim Lee](https://www.linkedin.com/in/jaehyoungtlee/), [Brianna Bradley](https://www.linkedin.com/in/brianna-bradley-bb8658155), [Wayne Enanoria](https://www.linkedin.com/in/wenanoria), Manual Albela Miranda, [Molly Mantus](https://www.linkedin.com/in/molly-mantus-174550150/), Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga  

**Зураг/дүрслэлүүд**: Calder Fong  


<!-- **Editor-in-Chief:** Neale Batra  -->

<!-- **Project core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell   -->

<!-- **Authors**: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, [Isaac Florence](www.Twitter.com/isaacatflorence), Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin   -->

<!-- **Reviewers**: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Wayne Enanoria, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Manual Albela Miranda, Molly Mantus, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga   -->


### Санхүүжилт, дэмжлэг {-}  

Гарын авлагад дэлхийн талбарын эпидемиологийн сургалтын хөтөлбөрүүдийн (FETPs) сүлжээ болох [TEPHINET](https://www.tephinet.org/)-ээс COVID-19 яаралтай хариу арга хэмжээний чадавхийг бэхжүүлэх буцалтгүй тусламжаар санхүүжилт авсан.  

Захиргааны дэмжлэгийг EPIET төгсөгчдийн сүлжээ ([EAN] (https://epietalumni.net/)) үзүүлсэн бөгөөд нэн ялангуяа Annika Wendland-д талархал илэрхийлж байна. EPIET бол Европын интервенц эпидемиологийн сургалтын хөтөлбөр юм.  

Энэхүү гарын авлагыг боловсруулахад дэмжлэг үзүүлсэн Хил Хязгааргүй Эмч нар (MSF) байгууллагын Амстердамын үйл ажиллагааны төвд (OCA) тусгайлан талархал илэрхийлж байна.  


*Энэхүү бүтээлийг Олон улсын эрүүл мэндийн ажлын хэсгийн хөтөлбөр болох TEPHINET-ээр дамжуулан Өвчний хяналт, урьдчилан сэргийлэлтийн төвүүдээс (CDC) NU2GGH001873 дугаартай Хамтран ажиллах гэрээний дагуу санхүүжүүлсэн. Бүтээлийн агуулгыг зөвхөн зохиогчид хариуцах бөгөөд агуулга нь Өвчний хяналт, урьдчилан сэргийлэлтийн төвүүд, Эрүүл мэнд, хүн амын яам, Олон улсын эрүүл мэндийн ажлын хэсэг, Inc. эсвэл TEPHINET-ийн албан ёсны үзэл бодлыг илэрхийлэхгүй болно.*



### Сэдэл {-}  

Гарын авлагын агуулгыг хөгжүүлэх мэдлэгээр хангасан олон тооны хичээл, виньетүүдийг тус тусын хуудсанд оруулсан болно.  

Ерөнхийдөө дараахь эх сурвалжууд энэхүү гарын авлагад нөлөө үзүүлсэн:  
["R4Epis" төсөл](https://r4epis.netlify.app/) (MSF, RECON хоёрын хамтын ажиллагаа)  
[R Эпидемикийн Консорциум (RECON)](https://www.repidemicsconsortium.org/)  
[R-ыг Дата шинжлэх ухаанд ном (R4DS)](https://r4ds.had.co.nz/)  
[bookdown: Ном, мэргэжлийн баримт бичгүүдийг R Markdown ашиглан зохиох нь](https://bookdown.org/yihui/bookdown/)  
[Netlify](https://www.netlify.com) энэхүү вэб хуудсыг байршуулдаг    


<!-- ### Image credits {-}   -->

<!-- Images in logo from US CDC Public Health Image Library) include [2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623), [Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186), and [Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838).   -->


## Ашиглалтын нөхцөл ба Лиценз {-}  

### Лиценз {.unnumbered} 

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.


Академик курсууд, эпидемиологийн сургалтын хөтөлбөрүүд энэхүү гарын авлагыг ашиглан суралцагчиддаа хичээл заах нээллттэй. Хэрэв танд энэхүү номыг ашиглах зорилтын тань талаар асуулт байвал **epirhandbook@gmail.com** имэйлээр илгээнэ үү.  


### Ишлэл {.unnumbered}

Batra, Neale, et al. The Epidemiologist R Handbook. 2021. <a rel="license" href="https://zenodo.org/badge/231610102.svg"><img alt="DOI" style="border-width:0" src="https://zenodo.org/badge/231610102.svg" /></a><br />

### Хувь нэмрээ оруулах {.unnumbered}  

Хэрэв та номын агуулгад хувь нэмрээ оруулахыг хүсч байвал Github-ын Issues хэсгээр эсвэл имэйлээр бидэнтэй холбоо бариарай. Бид номын шинэчлэлийн хуваарийг боловсруулан, хэрхэн хувь нэмрээ оруулах зааврыг бэлдэж байна.  

EpiRhandbook төсөл нь [Contributor-ын ёс зүйн дүрэмтэй](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html) болохыг анхаарна уу. Энэхүү төсөлд хувь нэмэр оруулснаар та үүний нөхцлийг дагаж мөрдөхийг зөвшөөрч байна.


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:index.Rmd-->

# (PART) Preview pages {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_preview.Rmd-->

# Редакцийн болон техникийн тэмдэглэл

Энэ хуудсанд энэхүү гарын авлагыг бүтээх явцад бидний барьсан философийн арга барил, хэв маяг, редакцийн тодорхой шийдвэрүүдийг тайлбарласан болно.

## Арга барил, загвар

Энэхүү номын уншигчдын хүрээ маш өргөн байх боломжтой. R-ийг анхлан сурч буй хүмүүс хэрэглэх нь гарцаагүй бөгөөд мөн туршлагатай R хэрэглэгчид ч шилдэг туршлага, зөвлөгөөг хайн унших болно. Тиймээс энэхүү ном ойлгомжтой бөгөөд товч тодорхой байх ёстой. Тийм болохоор бид R анхлан сурж буй хүн кодыг ашиглаж, тухайн код юу хийж буйг ойлгох хэмжээний *дөнгөж хангалттай* бичгэн тайлбар хийхийг зорьсон.

Өөр хэдэн зүйл:

-   Энэ бол харьцангуй богино жишээтэй кодын лавлагаа ном юм - R эсвэл өгөгдлийн шинжлэх ухааны талаарх гүнзгий сурах бичиг *биш*
-   Энэ бол хэрэглээний тархвар судлалд хэрэглэгдэх *R гарын авлага* - хэрэглээний тархвар судлалын шинжлэх ухаан эсвэл аргачлалын гарын авлага биш
-   Энэхүү ном амьд ном байхыг зорьж буй - тодорхой үйлдэл хийхэд хамгийн тохиромжтой R багцууд өөрчлөгдөх нь түгээмэл бөгөөд бид энэхүү гарын авлагад алийг нь тусгах талаар хэлэлцүүлгийг таатай хүлээн авах болно

### R багцууд {.unnumbered}

**Маш олон сонголтууд**

R сурахад хамгийн төвөгтэй талуудын нэг нь тухайн даалгаварт яг аль R багцыг ашиглахаа мэдэх явдал юм. Нэг даалгавар гүйцэтгэхийн тулд маш их код бичсэний дараа тухайн даалгаврыг ганцхан мөр кодоор хийчихдэг R багц байдгийг мэдэх нь түгээмэл.

Бид энэхүү гарын авлагад даалгавар бүрийг гүйцэтгэх хоёроос доошгүй аргыг санал болгохыг хичээсэн: нэг нь туршиж үзсэн, найдвартай арга (магадгүй **суурь** R эсвэл **tidyverse**), нөгөө нь тухайн даалгаварт тусгайлан зориулж бүтээсэн R багц. Өгөгдсөн багцыг татаж авах боломжгүй эсвэл өөр шалтгаанаар ажиллахгүй байж болох учир бид уншигчдыг хэд хэдэн сонголттой байлгахыг хүссэн.

Аль багцыг ашиглахаа сонгохдоо бид олон нийтийн зүгээс туршиж, шалгаж үзсэн, энгийн ажлын үед хэрэглэгддэг багцуудын тоог багасгадаг, тогтвортой (ойр ойрхон өөрчлөгддөггүй), тухайн даалгаврыг энгийн бөгөөд тодорхой гүйцэтгэдэг R багцууд болон арга барилуудыг урьдал болгосон.

Энэхүү гарын авлага ерөнхийдөө **tidyverse**-ийн R багцууд, функцуудыг голчлон хэрэглэсэн болно. Tidyverse бол үндсэн дүрэм, өгөгдлийн бүтцийн хувьд ижил, өгөгдлийн шинжлэх ухаанд зориулагдсан R багцуудын цуглуулга юм. Бүх tidyverse-ийн багцуудыг **tidyverse** багц ашиглан суулгаж эсвэл ачаалж болно. Дэлгэрэнгүйг [tidyverse вэбсайт](https://www.tidyverse.org/) дээрээс уншина уу.

Бид мөн шаардлагатай тохиолдолд ашиглаж болох **суурь** R ашигласан кодын сонголтыг оруулсан. Суурь R (base R) гэдэг нь R суулгах явцад түүнтэй хамт ирдэг багцууд, функцуудыг хэлж буй. Үүний учир нь энэ номын зарим уншигчид нэмэлт багц татаж авах найдвартай интернетгүй байж магадгүй юм.

**Функцийг багцтай ил тод холбох нь**

R-ийн зарим хичээлүүдийн кодонд нэг функцыг ашиглаж буй боловч тухайн функц ямар багцаас ашиглагдаж буйг харуулдаггүй нь нэлээд төвөгтэй байдаг. Бид ийм нөхцөл байдлаас зайлсхийхийг хичээсэн.

Номын өгүүлэл текстэнд багцын нэрүүд тодоор (ж.нь **dplyr**) бичигдсэн бөгөөд функцууд дараах байдлаар бичигдсэн: `mutate()`. Ойролцоох текст дэх багцыг дурдах эсвэл кодонд багцыг ийм байдлаар (`dplyr::mutate()`) тодорхой зааж өгөх замаар тухайн функц нь ямар багцаас гаралтай болохыг тодорхой харуулахыг бид хичээсэн. Энэ нь илүү ажил мэт санагдаж болох ч бид үүнийг албаар ингэж харуулж байгаа болно.

[R-ын суурь] хэсгээс багцууд, функцуудын талаар дэлгэрэнгүй мэдээлэл авч болно.

### Кодын загвар {.unnumbered}

Бид гарын авлагадаа "шинэ мөрнүүд"-ийг тогтмол ашигласнаар бидний код "урт" мэт харагдана. Бид үүнийг хэд хэдэн шалтгааны улмаас хийж байна:

-   Бид кодын жижиг хэсэг бүрийн хажууд `#` тэмдэг ашиглан тайлбар бичиж болно\
-   Ерөнхийдөө урт (босоо) кодыг уншихад илүү амар байдаг\
-   Нарийхан дэлгэц дээр уншихад илүү амар (хажуу тийш нь гүйлгэх шаардлагагүй)\
-   Догол мөрөөс харахад ямар аргументууд аль функцэд хамааралтай болохыг мэдэхэд илүү хялбар болно

Үүний үр дүнд дараах байдлаар бичигдэж болох код:

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>%  # мөрүүдийг эмнэлгээр бүлэглэх
  slice_max(date, n = 1, with_ties = F) # хэрвээ (огнооны) давхцал байвал эхний мөрийг нь сонгох
```

...ингэж бичигдэнэ:

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>% # мөрүүдийг эмнэлгээр бүлэглэх
  slice_max(
    date,                # бүлэг тус бүрийн хамгийн сүүлийн (өндөр) огноо бүхий мөрийг үлдээх
    n = 1,               # хамгийн өндөр ганцхан мөрийг үлдээх 
    with_ties = F)       # хэрвээ (огнооны) давхцал байвал эхний мөрийг нь сонгох
```

Шинэ мөр эсвэл догол мөрнүүд ерөнхийдөө R кодод нөлөөлдөггүй. Код бичихдээ таслалын дараа шинэ мөр эхлүүлбэл догол мөрийг автоматаар ашиглах болно.

Бид мөн уншихад илүү хялбар байдаг тул хоосон зайг ихээр ашигладаг (жишээлбэл `n=1` биш `n = 1`). Таны кодыг уншиж буй хүмүүсээ бодоорой!

### Нэр томъёо {.unnumbered}

Энэхүү гарын авлагад бид "хувьсагч (variables)", "ажиглалт (observations)" гэхийн оронд ерөнхийдөө "багана (columns)" ба "мөр (rows)"-ийг ашигласан. Энэхүү ["цэгцтэй өгөгдөл"](https://tidyr.tidyverse.org/articles/tidy-data.html) гэсэн материалд тайлбарласнаар ихэнх эпидемиологийн статистикийн өгөгдлийн багц нь бүтцийн хувьд мөр, багана, утгуудаас бүрддэг.

Хувьсагч нь ижил үндсэн шинж чанарыг хэмжсэн утгыг агуулдаг (насны бүлэг, үр дүн, эхлэх огноо гэх мэт). Ажиглалт нь нэг нэгжээр хэмжигдэх бүх утгыг агуулдаг (жишээлбэл, хүн, байршил эсвэл лабораторийн сорьц). Тиймээс иймэрхүү шинж чанарыг бодитоор тодорхойлоход төвөгтэй байж магадгүй юм.

"Цэгцтэй" өгөгдлийн багцад багана бүр хувьсагч, мөр бүр ажиглалт, нүд бүр нэг утгатай байна. Хэдий тийм боловч таны ашиглаж буй зарим өгөгдлийн багц энэ загварт тохирохгүй байх нь элбэг - жишээ нь "өргөн" форматтай өгөгдлийн багц нь хэд хэдэн баганад хуваагдсан хувьсагчтай байж болно ([Pivoting data] хуудсан дээрх жишээг үзнэ үү). Үүний нэгэн адил ажиглалт мөн хэд хэдэн мөрөнд хуваагдсан байж болдог.

Энэхүү гарын авлагын ихэнх нь өгөгдлийг удирдах, өөрчлөх тухай байгаа тул хийсвэр ойлголтууд болох ажиглалт, хувьсагчаас илүүтэй тодорхой ойлголтууд болох мөр, баганаар өгөгдлийн бүтцийг дурдах нь илүү ойлгомжтой юм. Үүнд хамаарахгүй зүйлүүд нь голчлон өгөгдлийн дүн шинжилгээний талаарх хуудсуудад гарч ирэх бөгөөд дүн шинжилгээний хувьд та хувьсагч, ажиглалт гэсэн ойлголтуудтай түлхүү тулгарах болно.

### Тэмдэглэл {.unnumbered}

Энэхүү гарын авлагад дурдагдах тэмдэглэлийн төрлүүд энд байна:

[***ТЭМДЭГЛЭЛ:*** Энэ бол тэмдэглэл.]{style="color: black;"}\
[***ЗӨВЛӨГӨӨ:*** Энэ бол зөвлөгөө.]{style="color: darkgreen;"}\
[***СЭРЭМЖЛҮҮЛЭГ:*** Энэ бол сэрэмжлүүлэх тэмдэглэл.]{style="color: orange;"}\
[***АЮУЛ:*** Энэ бол анхааруулга.]{style="color: red;"}

## Редакцийн шийдвэр

Доорх хүснэгтээр бид багц болон функцын сонголтын талаархи редакцийн чухал шийдвэрүүдийг хянан дагаж байна. Хэрэв та санал нийлэхгүй байгаа эсвэл шинэ багц/функц санал болгохыг хүсвэл манай [Github хуудсан](https://github.com/epirhandbook/Epi_R_handbook) дээр нэгдэж харилцан яриа эхлүүлнэ үү.

**Багц, функц болон бусад редакцийн шийдвэрийн хүснэгт**

+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Сэдэв                         | Авч үзсэн                                                                       | Үр дүн                                                                                                                                                   | Товч үндэслэл                                                                                        |
+===============================+=================================================================================+==========================================================================================================================================================+======================================================================================================+
| Ерөнхий кодлох арга барил     | **tidyverse**, **data.table**, **base**                                         | **tidyverse**, with a page on **data.table**-ийн талаар нэг хуудас бүхий, мөн интернетгүй уншигчдад зориулан **base** хувилбаруудын талаар дурдсан болно | **tidyverse** уншигдах байдал, түгээмэл байдал, хамгийн их заагддаг                                  |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Багц ачаалах                  | `library()`,`install.packages()`, `require()`, **pacman**                       | **pacman**                                                                                                                                               | Ихэнх олон багц суулгах/ачаалах тохиолдлын кодыг богиносгож, хялбаршуулдаг                           |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Импорт, экспорт               | **rio**, бусад олон багцууд                                                     | **rio**                                                                                                                                                  | Олон төрлийн файлын хувьд хялбар                                                                     |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Дүгнэлт статистикийг бүлэглэх | **dplyr** `group_by()`, **stats** `aggregate()`                                 | **dplyr** `group_by()`                                                                                                                                   | **tidyverse**-тэй нийцдэг                                                                            |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Пивот хийх                    | **tidyr** (пивот функцууд), **reshape2** (melt/cast), **tidyr** (spread/gather) | **tidyr** (пивот функцууд)                                                                                                                               | **reshape2**-ийн хөгжүүлэлт зогссон, **tidyr**-ийн v1.0.0-ээс эхлээд тусгай пивот функцуудтай болсон |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Баганын нэрүүдийг цэвэрлэх    | **linelist**, **janitor**                                                       | **janitor**                                                                                                                                              | Багцуудын нэгтгэлийг онцлов                                                                          |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Epiweeks                      | **lubridate**, **aweek**, **tsibble**, **zoo**                                  | Голчлон **lubridate**, бусдыг нь онцгой тохиолдлуудад                                                                                                    | **lubridate**-ийн уян хатан байдал, тогтвортой байдал, багцын цаашдын хөгжүүлэлтийн төлөв            |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| ggplot шошгууд                | `labs()`, `ggtitle()`/`ylab()`/`xlab()`                                         | `labs()`                                                                                                                                                 | бүх шошго нэг дор, энгийн байдал                                                                     |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Фактор болгон хөрвүүлэх       | `factor()`, **forcats**                                                         | **forcats**                                                                                                                                              | энэхүү багцын төрөл бүрийн функцууд нь тухайн командын дотор мөн фактор болгон хувиргадаг            |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Эпидемийн муруй               | **incidence**, **ggplot2**, **EpiCurve**                                        | **incidence2** хурднаар, **ggplot2** нарийвчлалтайгаар                                                                                                   | найдвартай байдал                                                                                    |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Холболт (Concatenation)       | `paste()`, `paste0()`, `str_glue()`, `glue()`                                   | `str_glue()`                                                                                                                                             | `paste()` функцээс илүү энгийн синтакстай; **stringr** багцад багтдаг                                |
+-------------------------------+---------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------+

## Гол өөрчлөлт

| Огноо               | Томоохон өөрчлөлтүүд      |
|---------------------|---------------------------|
| 2021 оны 5 сарын 10 | 1.0.0 хувилбарыг гаргасан |

## Session мэдээлэл (R, RStudio, багцууд)

Энэхүү гарын авлагыг гаргах явцад ашигласан R, RStudio, R багцын хувилбаруудын талаархи мэдээллийг доор өгөв.

```{r}
sessioninfo::session_info()
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/editorial_style.Rmd-->

---
editor_options: 
  markdown: 
    wrap: 72
---

# Гарын авлага, өгөгдлийг татаж авах

<!-- Note to self: If you want to create a download link to Github, right-click the "View Raw" button on Github, copy the address, and use that in the HTML below. -->

## Офлайн гарын авлагыг татаж авах

Та энэ гарын авлагын офлайн хувилбарыг HTML файл хэлбэрээр татаж авах
боломжтой бөгөөд ингэснээр та интернет холболтгүй болсон ч гэсэн вэб
хөтөч дээрээ файлыг үзэх боломжтой болно. Хэрэв та Epi R гарын авлагыг
офлайнаар ашиглах гэж байгаа бол дараах хэдэн зүйлийг анхаарах хэрэгтэй:

-   Файлыг нээхэд зурагнууд болон агуулгын хүснэгтийг ачаалахад ганц
    хоёр минут шаардагдаж магадгүй

-   Офлайн гарын авлага нь арай өөр бүтэцтэй - зүүн талд нь агуулгын
    хүснэгт бүхий маш урт хуудастай. Тодорхой нэр томъёо хайхын тулд
    Ctrl+f (Cmd-f) командыг ашиглана уу.

-   \[Санал болгож буй багцууд\] хуудсыг үзээд интернет холболт
    тасрахаас өмнө тохирох R багцуудыг суулгаж болно

-   Бүх жишээ өгөгдлийг агуулсан манай R багц **epirhandbook**-ийг
    суулгаарай (суулгах процессыг доор тайлбарласан болно)

**Гарын авлага татаж авах хоёр арга бий::**

### Татаж авах линкийг ашиглах {.unnumbered}

Түргэн хандахын тулд [**энэ
холбоос**](https://github.com/epirhandbook/Epi_R_handbook/raw/master/offline_long/Epi_R_Handbook_offline.html)
**дээр хулганы баруун товчийг дараад "Save link as"-г сонгоно уу.**

Хэрэв Mac дээр бол Cmd+дарна уу. Хэрэв гар утас дээр байгаа бол
холбоосыг дараад "Save link"-г сонгоно уу. Гарын авлага нь таны
төхөөрөмжид татагдах болно. Хэрэв raw HTML кодтой дэлгэц гарч ирвэл
дээрх зааврыг дагаж мөрдсөн эсэхээ шалгах эсвэл 2-р аргыг туршиж
үзээрэй.

### Манай R багцыг ашиглах {.unnumbered}

Бид **epirhandbook** нэртэй R багцыг санал болгож байна. Энэ багц нь
гарын авлагын файлыг манай Github репозитороос таны компьютерт татаж
авдаг `download_book()` функцийг агуулдаг.

Мөн энэ багц нь бүх жишээ өгөгдлийг таны компьютерт татаж авдаг
`get_data()` функцийг агуулдаг.

[Github репозитори
*appliedepi*](https://github.com/appliedepi/epirhandbook)-ээс манай R
багц **epirhandbook**-ийг суулгахын тулд дараах кодыг ажиллуулна уу. Энэ
багц нь CRAN дээр байдаггүй тул Github-аас суулгахын тулд
`p_install_gh()` тусгай функцийг ашиглана уу.

```{r, eval=F}
# Epi R Handbook багцын хамгийн сүүлийн хувилбарыг суулга
pacman::p_install_gh("appliedepi/epirhandbook")
```

Та одоогийн R session-дээ ашиглахын тулд багцыг ачаална уу:

```{r, eval=F}
# ашиглахын тулд багцыг ачаал
pacman::p_load(epirhandbook)
```

Дараа нь гарын авлагыг компьютер дээрээ татаж авахын тулд энэхүү багцын
`download_book()` (хоосон хаалттай нь) функцийг ажиллуулна уу. Хэрэв та
RStudio-дээр ажиллаж байгаа бол хадгалагдах байршлыг сонгох боломжтой
цонх гарч ирнэ.

```{r, eval=F}
# офлайн гарын авлагыг компьютер дээрээ татаж ав
download_book()
```

## Дагаж ажиллахын тулд өгөгдлийг татаж авах

Гарын авлагын хуудсыг "дагаж ажиллахын" тулд та жишээ өгөгдөл, гаралтыг
татаж авах боломжтой.

### Манай R багцыг ашиглах {.unnumbered}

Бүх өгөгдлийг татаж авах хамгийн хялбар арга бол манай R багц
**epirhandbook**-ийг суулгах явдал юм. Энэ багц нь бүх жишээ өгөгдлийг
таны сонгосон хавтсанд хадгалдаг `get_data()` функцийг агуулдаг.

Манай R багц **epirhandbook**-ийг суулгахын тулд дараах кодыг ажиллуулна
уу. Энэ багц нь CRAN дээр байдаггүй тул үүнийг суулгахын тулд
`p_install_gh()` функцийг ашиглана. Оролт нь манай Github байгууллага
("*appliedepi*") болон **epirhandbook** багцыг харуулж байна.

```{r, eval=F}
# Epi R Handbook багцын хамгийн сүүлийн хувилбарыг суулга
pacman::p_install_gh("appliedepi/epirhandbook")
```

Та одоогийн R session-дээ ашиглахын тулд багцыг ачаална уу:

```{r, eval=F}
# ашиглахын тулд багцыг ачаал
pacman::p_load(epirhandbook)
```

Үүний дараа нь `get_data()` функцийг ашиглан жишээ өгөгдлийг компьютер
дээрээ татаж аваарай. *Бүх* жишээ өгөгдлийг авахын тулд
`get_data("all")`-ийг ажиллуулна эсвэл зөвхөн нэг файлыг авахын тулд
ишлэл дотор тухайн файлын нэрийг өргөтгөлийн хамт оруулна уу.

Өгөгдлийг багцтай аль хэдийн татаж авсан бөгөөд үүнийг компьютер дээрх
хавтас руу шилжүүлэх шаардлагатай. Хадгалах хавтасны байршлыг сонгох
боломжийг олгодог попап цонх гарч ирнэ. 30 орчим файл (жишээ өгөгдөл,
жишээ гаралтыг оруулаад) байгаа тул танд шинэ "data" фолдер үүсгэхийг
санал болгож байна.

```{r, eval=F}
# бүх жишээ өгөгдлийг компьютер дээрх хавтас руу татаж ав
get_data("all")

# зөвхөн linelist жишээний өгөгдлийг компьютер дээрх хавтаст татаж ав
get_data(file = "linelist_cleaned.rds")

```

```{r, eval=F}
# тодорхой файлыг компьютер дээрх хавтас руу татаж ав
get_data("linelist_cleaned.rds")
```

Та `get_data()` функцыг ашиглан файлыг компьютер дээрээ хадгалсан хэдий
ч үүнийг R руу импортлох шаардлагатай хэвээр байх болно. Дэлгэрэнгүй
мэдээллийг \[Импорт ба экспорт\] хуудаснаас үзнэ үү.

Хэрэв та хүсвэл энэ гарын авлагад ашигласан бүх өгөгдлийг манай Github
репозиторийн ["data"
хавтсанд](https://github.com/epirhandbook/Epi_R_handbook/tree/master/data)
үзэх боломжтой.

### Нэг нэгээр нь татаж авах {.unnumbered}

Энэ сонголт нь манай Github репозитороос тухайн файлд зориулагдсан линк
эсвэл R командын тусламжтайгаар өгөгдлийг нэг нэгээр нь татаж авах
боломжийг олгох юм. Зарим файлын төрлүүд татаж авах товчлуурыг
зөвшөөрдөг бол заримыг нь R командын тусламжтайгаар татаж авах
боломжтой.

#### Тохиолдлын linelist {.unnumbered}

Энэ бол **outbreaks** багц дахь дадлагын өгөгдлийн багц болох
`ebola_sim`-ийг гарын авлагын баг өргөжүүлсэн Эбола вирусын зохиомол
дэгдэлтийн өгөгдөл юм.

-   <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>"Боловсруулаагүй"
    linelist (.xlsx) татаж авахын тулд дарна уу</span></a>.
    "Боловсруулаагүй" linelist нь замбараагүй өгөгдөл бүхий Excel
    хүснэгт юм. Үүнийг ашиглан \[Өгөгдөл цэвэрлэх ба үндсэн функцууд\]
    хуудсыг дагаж ажиллана уу.

-   <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"Цэвэр"
    linelist (.rds) татаж авахын тулд дарна уу</a>. Энэ гарын авлагын
    энэхүү linelist-ийг ашиглаж буй бусад бүх хуудсан дээр энэ файлыг
    ашиглана уу. Энэхүү .rds файл нь баганын төрлүүдийг хадгалдаг R-ын
    өвөрмөц файлын төрөл юм. Энэ файлыг ашигласнаар өгөгдлийг R руу
    импортлосны дараа хамгийн бага цэвэрлэгээ хийх болно.

*Бусад холбогдох файлууд:*

-   <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.xlsx' class='download-button'>"Цэвэр"
    linelist-ийг Excel файл болгон татаж авахын тулд дарна уу</a>

-   Цэвэрлэх хуудасны нэг хэсэг нь "цэвэрлэх толь бичиг" (.csv файл)
    ашигладаг. Та дараах командуудыг ажиллуулснаар үүнийг R руу шууд
    ачаалж болно:

```{r, eval=F}
pacman::p_load(rio) # rio багцыг суулгах/ачаалах

# файлыг Github-аас шууд импортлох
cleaning_dict <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/cleaning_dict.csv")
```

#### Хумхаагийн тоон өгөгдөл {#data_malaria .unnumbered}

Энэхүү өгөгдөл нь хумхаа өвчний тохиолдлыг насны бүлэг, байгууламж,
өдрөөр нь гаргасан зохиомол тоонууд болно. Энэхүү .rds файл нь баганын
төрлүүдийг хадгалдаг R-ын өвөрмөц файлын төрөл юм. Энэ файлыг
ашигласнаар өгөгдлийг R руу импортлосны дараа хамгийн бага цэвэрлэгээ
хийх болно.

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>
Хумхаа өвчний тоон өгөгдлийг татаж авахын тулд дарна уу (.rds файл) </a>

#### Ликерт-хэмжүүртэй өгөгдөл {.unnumbered}

Эдгээр нь \[Хүн ам зүйн пирамидууд ба Ликерт-хэмжүүр\] хуудсан дээр
ашиглагдсан Ликерт-загварын судалгааны зохиомол өгөгдөл юм. Та дараах
командуудыг ажиллуулснаар эдгээр өгөгдлийг R руу шууд ачаалж болно:

```{r, eval=F}
pacman::p_load(rio) # rio багцыг суулгах/ачаалах

# файлыг Github-аас шууд импортлох
likert_data <- import("https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv")
```

#### Flexdashboard {.unnumbered}

Доорх нь \[R Markdown бүхий хяналтын самбар\] хуудастай холбоотой файлын
линкүүд:

-   Дэгдэлтийн хяналтын самбарын R Markdown-ийг татаж авахын тулд энэ
    [холбоос](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/flexdashboard/outbreak_dashboard.Rmd)
    дээр хулганы баруун товчийг дараад (Mac дээр Cmd+дарна уу) "Save
    link as" сонгоно уу.

-   HTML хяналтын самбарыг татаж авахын тулд энэ
    [холбоос](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/flexdashboard/outbreak_dashboard_test.html)
    дээр хулганы баруун товчийг дараад (Cmd+Mac дээр дарна уу) "Save
    link as" сонгоно уу.

#### Хавьтал мөшгөлт {#хавьтал-мөшгөлт .unnumbered}

[Хавьтал мөшгөлт](#хавьтал-мөшгөлт) хуудас нь
[Go.Data](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting)-аас
авсан өгөгдлийн жишээг ашиглан хавьтал мөшгөлтийн мэдээллийн анализыг
харуулсан. Энэхүү хуудас дээр ашигласан өгөгдлийг дараах холбоосууд дээр
дарж .rds файл хэлбэрээр татаж авах боломжтой:

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true' class='download-button'>
Тохиолдлын судалгааны өгөгдлийг татаж авахын тулд дарна уу (.rds файл)
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true' class='download-button'>
Хавьтлын бүртгэлийн өгөгдлийг татаж авахын тулд дарна уу (.rds файл)
</a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true' class='download-button'>
Хавьтлын хяналтын өгөгдлийг татаж авахын тулд дарна уу (.rds файл) </a>

[***ТЭМДЭГЛЭЛ:*** Бусад програм хангамж (жишээ нь KoBo, DHIS2 Tracker,
CommCare)-аас авсан тогтсон бүтэцтэй хавьтал мөшгөлтийн өгөгдөл өөр
харагдаж магадгүй юм. Хэрэв та энэ хуудсанд өөр жишээ өгөгдөл эсвэл
агуулгыг оруулахыг хүсч байвал бидэнтэй [холбоо барина
уу.](#contact_us)]{style="color: black;"}

[***ЗӨВЛӨГӨӨ:*** Хэрэв та Go.Data ашиглаж байгаа бөгөөд өөрийн API-тай
холбогдохыг хүсч байвал Импорт, экспортын хуудас ([API
хэсэг](#import_api)) болон [Go.Data Community of
Practice](https://community-godata.who.int/)-г үзнэ
үү.]{style="color: darkgreen;"}

#### GIS {.unnumbered}

Шэйпфайл (shapefile) нь олон дэд файлуудтай бөгөөд эдгээр нь бүгд өөр
өөр файлын өргөтгөлтэй байдаг. Нэг файл ".shp" өргөтгөлтэй байхад бусад
нь ".dbf", ".prj" гэх мэт өргөтгөлтэй байж болно.

\[GIS-ийн үндсэн ойлголтууд\] хуудас дээр байгаа *Хүмүүнлэгийн өгөгдлийн
солилцооны* вэбсайтын холбоос байгаа бөгөөд та энэхүү вэбсайтаас
шэйпфайлуудыг зип хэлбэрээр шууд татаж авах боломжтой.

Жишээлбэл, эрүүл мэндийн байгууллагын онооны өгөгдлийг
[эндээс](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities)
татаж авах боломжтой.
"hotosm_sierra_leone_health_facilities_points_shp.zip" файлыг татаж авна
уу. Энэхүү файл таны компьютерт хадгалагдсаны дараа фолдерыг "задлах"
(unzip) хэрэгтэй. Та өөр өөр өргөтгөлтэй хэд хэдэн файлыг харах болно
(жишээ нь ".shp", ".prj", ".shx") - эдгээрийг бүгдийг нь таны компьютер
дээрх нэг хавтсанд хадгалах ёстой. Дараа нь R руу импортлохын тулд
файлын зам болон ".shp" файлын нэрийг **sf** багцын `st_read()` функц
руу оруулна уу (\[GIS-ийн үндсэн ойлголтууд\] хуудсанд тайлбарласны
дагуу).

Хэрвээ та 1-р сонголтын дагуу бүх жишээ өгөгдлийг татаж авсан бол (манай
R багц **epirhandbook**-ээр) тэр дотор бүх шэйпфайлууд орсон байгаа.

Эсвэл та шэйпфайлуудыг R Handbook Github "data" хавтсаас татаж авах
боломжтой ("gis" дэд хавтсыг үзнэ үү). Ингэж татах үедээ та дэд файл
бүрийг тус тусад нь компьютер дээрээ татаж авах хэрэгтэй гэдгийг
санаарай. Github дээр файл тус бүр дээр дарж, "Download" товчийг дарж
татаж аваарай. Доор "sle_adm3" шэйпфайл нь хэрхэн олон файлаас бүрдэж
буйг харуулж буй бөгөөд эдгээр файл тус бүрийг Github-аас татаж авах
шаардлагатай.

```{r out.height = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```

#### Удмын мод {#удмын-мод .unnumbered data-link="Phylogenetic trees"}

[Удмын мод](#удмын-мод)-ны талаарх хуудсыг үзнэ үү. Shigella sonnei-ийн
299 сорьцын бүтэн геномын дарааллыг тогтоож гаргасан удмын модны Ньюик
(Newick) файл ба сорьцын бусад холбогдох өгөгдөл (текст файл болгон
хөрвүүлсэн). Бельгийн Salmonella, Shigella сорьцууд, тэдгээрийн үр
дүнгийн өгөгдлийг ECDC EUPHEM-ийн суралцагчийн төслийн хүрээнд Бельгийн
үндэсний лавлагаа лабораториос өгсөн бөгөөд энэхүү судалгааны үр дүн мөн
хэвлэгдэх болно. Олон улсын өгөгдөл олон нийтийн өгөгдлийн сан (NCBI)
дээр нээлттэй хэлбэрээр байрладаг бөгөөд өмнө нь хэвлэгдэж байсан.

-   "Shigella_tree.txt" удмын модны файлыг татаж авахын тулд энэ
    [линк](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/phylo/Shigella_tree.txt)
    дээр хулганы баруун товчийг дараад (Mac дээр Cmd+дарж) "Save link
    as" сонгоно уу.

-   Сорьц тус бүрийн нэмэлт мэдээллийг агуулсан
    "sample_data_Shigella_tree.csv" файлыг татаж авахын тулд энэ
    [линк](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/phylo/sample_data_Shigella_tree.csv)
    дээр хулганы баруун товчийг дараад (Mac дээр Cmd+дарж) "Save link
    as" сонгоно уу.

-   Шинээр үүсгэсэн дэд модыг харахын тулд энэ
    [линк](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/phylo/Shigella_subtree_2.txt)
    дээр хулганы баруун товчийг дараад (Cmd+Mac дээр дарна уу) "Save
    link as" сонгоно уу. Таны компьютерт .txt файл татагдах болно.

Та хуудсан дээр тайлбарласны дагуу .txt файлыг **ape** багцын
`read.tree()` функц ашиглан импортлох боломжтой.

```{r, eval=F}
ape::read.tree("Shigella_tree.txt")
```

#### Стандартчилал {.unnumbered}

\[Стандартчилсан түвшин\]-ий талаарх хуудсыг үзнэ үү. Та дараах
командуудыг ашиглан интернет дээрх манай Github репозитороос өөрийн R
session рүү өгөгдлийг шууд ачаалах боломжтой:

```{r, eval=F}
# rio багцыг суулгах/ачаалах
pacman::p_load(rio) 

##############
# A улс
##############
# А улсын хүн ам зүйн мэдээллийг Github-аас шууд импортлох
A_demo <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/country_demographics.csv")

# А улсын нас баралтын мэдээллийг Github-аас шууд импортлох
A_deaths <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryA.csv")

##############
# B улс
##############
# B улсын хүн ам зүйн мэдээллийг Github-аас шууд импортлох
B_demo <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/country_demographics_2.csv")

# B улсын нас баралтын мэдээллийг Github-аас шууд импортлох
B_deaths <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryB.csv")


###############
# Лавлагаа хүн ам
###############
# Дэлхийн стандартчилсан хүн ам зүйн мэдээллийг Github-аас шууд импортлох
standard_pop_data <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/world_standard_population_by_sex.csv")
```

#### Цагийн цуврал (time series) ба дэгдэлт илрүүлэлт {#data_outbreak .unnumbered}

[Цагийн цуврал ба дэгдэлт илрүүлэлт](#data_outbreak) хуудсыг үзнэ үү.
Бид **surveillance** R багцад байдаг Германд 2002-2011 онд бүртгэгдсэн
Campylobacter-ийн тохиолдлуудыг ашигладаг. (nb. Сургалтын зорилгоор
энэхүү өгөгдлийн 2011 оны сүүлийн 3 сарын өгөгдлийг устгаж эх
хувилбараас нь өөрчилсөн болно)

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/campylobacter_germany.xlsx' class='download-button'>
Герман дахь Campylobacter өгөгдлийг татаж авахын тулд дарна уу (.xlsx)
</a>

Бид мөн Германы 2002-2011 оны цаг уурын мэдээллийг ашигладаг (температур
нь цельсийн градус, борооны хэмжээ нь миллиметрээр). Эдгээрийг Европын
Холбооны Коперникус хиймэл дагуулын дахин шинжилгээний өгөгдлийн сангаас
**ecmwfr** багц ашиглан татаж авсан болно. Та эдгээрийг бүгдийг нь татаж
аваад цагийн цувралын хуудсанд тайлбарласны дагуу `stars::read_stars()`
функцыг ашиглан импортолж болно.

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2002.nc' class='download-button'>
2002 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2003.nc' class='download-button'>
2003 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2004.nc' class='download-button'>
2004 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2005.nc' class='download-button'>
2005 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2006.nc' class='download-button'>
2006 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2007.nc' class='download-button'>
2007 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2008.nc' class='download-button'>
2008 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2009.nc' class='download-button'>
2009 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2010.nc' class='download-button'>
2010 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/weather/germany_weather2011.nc' class='download-button'>
2011 оны Германы цаг агаарыг татаж авахын тулд дарна уу (.nc файл) </a>

#### Асуумж судалгааны (survey) дүн шинжилгээ {#data_survey .unnumbered}

[Асуумж судалгааны дүн
шинжилгээ](https://epirhandbook.com/survey-analysis.html) хийх хуудасны
хувьд бид MSF OCA асуумж судалгааны загвар дээр үндэслэн нас баралтын
талаархи зохиомол өгөгдлийг ашигласан. Энэхүү зохиомол өгөгдлийг
["R4Epis" төслийн](https://r4epis.netlify.app/) хүрээнд үүсгэсэн болно.

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/surveys/survey_data.xlsx' class='download-button'>
Зохиомол асуумж судалгааны өгөгдлийг татаж авахын тулд дарна уу (.xlsx)
</a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/surveys/survey_dict.xlsx' class='download-button'>
Зохиомол асуумж судалгааны өгөгдлийн толь бичгийг татаж авахын тулд
дарна уу (.xlsx) </a>

<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/surveys/population.xlsx' class='download-button'>
Зохиомол асуумж судалгааны хүн амын мэдээллийг татаж авахын тулд дарна
уу (.xlsx) </a>

#### Shiny {#data_shiny .unnumbered}

\[Shiny бүхий хяналтын самбар\] дээрх хуудас нь хумхаа өвчний өгөгдлийг
харуулах энгийн аппликейшн бүтээснийг харуулав.

Shiny аппликейшн үүсгэдэг R файлуудыг татаж авахын тулд:

Та
<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_app/app.R' class='download-button'>
энд дараад Shiny аппликейшний UI болон Серверийн кодыг агуулсан app.R
файлыг татаж авна уу. </a>

Та
<a href='https://github.com/epirhandbook/Epi_R_handbook/blob/master/data/malaria_app/data/facility_count_data.rds' class='download-button'>
энд дараад facility_count_data.rds файлыг татаж авна уу. <span></a> Энэ
файл нь Shiny аппликейшний хумхаа өвчний өгөгдлийг агуулж буй. `here()`
файлын замыг зөв ажиллуулахын тулд та үүнийг "data" хавтсанд хадгалах
хэрэгтэй байж магадгүй гэдгийг анхаарна уу.

Та
<a href='https://github.com/epirhandbook/Epi_R_handbook/blob/master/data/malaria_app/global.R' class='download-button'>
энд дарж global.R файлыг татаж авна уу. <span></a> Хуудсанд тайлбарласны
дагуу энэ файлыг аппликейшнээ нээхээс өмнө ажиллуулах шаардлагатай.

Та
<a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_app/funcs/plot_epicurve.R' class='download-button'>
энд дарж global.R скриптэд ашиглагддаг plot_epicurve.R файлыг татаж авна
уу. <span></a> `here()` файлын замыг зөв ажиллуулахын тулд та үүнийг
"funcs" хавтсанд хадгалах хэрэгтэй байж магадгүй гэдгийг анхаарна уу.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/data_used.Rmd-->

# R суурь ойлголтууд

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "basics_header_close.png"))
```

Тавтай морилно уу!

Энэхүү бүлэгт бид R-ын талаарх үндсэн ойлголтуудыг авч үзнэ. Энэ нь дэлгэрэнгүй заавар болох зорилгогүй бөгөөд танд R-ын талаар анхан шатны мэдлэгийг өгч, мөн өмнө ашиглаж байсан хүмүүст ой санамжаа сэргээхэд тустай байх болно. [Сургалтын материалууд](#learning) хэсэгт илүү дэлгэрэнгүй сургалтын линкүүд буй.

Энэ хуудасны зарим хэсгийг [R4Epis төслийн](https://r4epis.netlify.app/) зөвшөөрлөөр бага зэрэг өөрчлөн авч ашигласан.

STATA, SAS, эсвэл Excel-ээс R руу шилжих зөвлөмжийг \[R руу шилжих\] хуудаснаас үзнэ үү.

```{r, echo=F}
# цэвэрлэсэн Эбола лайнлистийг импортлох
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->

## Яагаад R-г ашиглана гэж?

[R төслийн вэбсайтад](https://www.r-project.org/about.html) дурдсанчлан R бол статистикийн тооцоолол, график хийхэд зориулсан програмчлалын хэл, түүний орчин юм. R нь маш уян хатан, өргөтгөх боломжтой, хөгжил нь хэрэглэгчдээрээ удирдуулдаг программ юм.

**Зардал**

R ашиглахад үнэгүй! Чөлөөт, нээлттэй эх сурвалжийн эргэн тойрон өндөр ёс зүйтэй байдаг.

**Давтагдах чадвар**

Дата менежмент, дата анализийг програмчлалын хэлээр (Excel эсвэл бусад голчлон товчлуур дээр дардаг/гараар хийдэг хэрэгслүүдтэй харьцуулахад) хийх нь **давтагдах чадварыг** сайжруулж, **алдааг илрүүлэхэд** амар болж, таны ажлын ачааллыг хөнгөвчилдөг.

**Хамт олон**

R хэрэглэгчдийн хамт олон маш том бөгөөд нэгэндээ үргэлж туслан хамтран ажилладаг. Амьдрал дээр тулгарч буй олон асуудлыг шийдвэрлэх шинэ багц, хэрэгслүүд өдөр бүр гарч, тэдгээрийг нь R хэрэглэгчид хэрэглэж үзэн байнга шалгаж байдаг. Үүний нэг жишээ болох [R-Ladies](https://rladies.org/) нь дэлхий даяар салбартай, R хэрэглэгчдийн хамгийн том байгууллагуудын нэг бөгөөд гол зорилго нь R хэрэглэгчдийн дундах жендэрийн олон талт байдлыг хангах, дэмжих явдал юм. Таны ойролцоо ч салбар нь байдаг байж магадгүй!

## Гол нэр томъёо

**RStudio** - RStudio бол **R**-ийг ашиглахад хялбар болгож буй хэрэглэгчийн график интерфэйс (GUI) юм. Дэлгэрэнгүйг [RStudio хэсгээс](#rstudio) уншина уу.

**Объектууд** - Таны R-д хадгалдаг бүх зүйл - датасетүүд, хувьсагч, тосгоны нэрсийн жагсаалт, хүн амын нийт тоо, тэр ч байтугай график гэх мэт гаралтууд - нь нэр оноогдсон объект бөгөөд тэрхүү нэрийг ашиглан дараагийн командуудад дуудаж болдог. Дэлгэрэнгүйг [Объектууд хэсгээс](#objects) уншина уу.

**Функцууд** - Функц нь оролтыг хүлээн авч, хувиргасан гаралтыг буцааж өгдөг кодын үйлдэл юм. Дэлгэрэнгүйг [Функц хэсгээс](#functions) уншина уу.

**Багцууд** - R багц гэдэг нь функцүүдийн нэгдэл юм. Дэлгэрэнгүй мэдээллийг [Багц хэсгээс](#packages) уншина уу.

**Скриптүүд** - Скрипт бол таны командуудыг агуулсан файл юм. Дэлгэрэнгүйг [Скриптүүд хэсгээс](#scripts) уншина уу

## Сургалтын материалууд {#learning}

### RStudio доторх материалууд {.unnumbered}

**Тусламжийн баримт бичиг**

R багц болон функцуудын талаархи баримт бичгийг RStudio-гийн "Help" таб дээрээс хайж болно. Энэ нь Files, Plots болон Packages бүхий хэсэгт байдаг (ихэвчлэн баруун доод хэсэгт). Хурдан хандая гэвэл та R консол дотор асуултын тэмдгийн дараа тухайн багц эсвэл функцын нэрийг бичсэнээр хамааралтай Help хуудсыг нээж болно. Ингэхдээ хаалтгүйгээр бичнэ үү.

Жишээлбэл: `?filter` эсвэл `?diagrammeR`.

**Интерактив хичээлүүд**

RStudio дотор R-ийг интерактив байдлаар сурах хэд хэдэн арга байдаг.

RStudio өөрөө [learnr](https://blog.rstudio.com/2020/02/25/rstudio-1-3-integrated-tutorials/) хэмээх R багцаар ажилладаг Tutorial хэсгийг санал болгодог. Ердөө л энэ багцыг суулгаад RStudio-ийн баруун дээд хэсэгт байрлах "Tutorial" табыг ашиглан хичээлээ нээнэ үү (Environment болон History табуудыг агуулсан хэсэг).

R багц [**swirl**](https://swirlstats.com/)нь R консол дотор ажиллаж болох интерактив курсуудыг санал болгодог. Энэ багцыг суулгаад ачаалсны дараа R консол дээр `swirl()` (хоосон хаалттай) командыг ажиллуулна уу. Таны консол дээр асуулт гарч ирэх болно. Консол дээрээ бичээд хариулна уу. Ийм байдлаар таны сонгосон хичээлийг удирдан явуулах болно.

### Cheatsheets {.unnumbered}

[RStudio вэбсайт](https://rstudio.com/resources/cheatsheets/) дээр олон PDF "cheatsheets" байдаг, жишээлбэл:

-   Факторын **forcats** багц

-   Огноо, цагийн **lubridate** багц

-   Стрингүүдийн **stringr** багц

-   Давтагдах үйлдлүүдэд зориулсан **purrr** багц

-   Дата импортлох

-   **dplyr** багцын дата хувиргах cheatsheet

-   R Markdown (PDF, Word, Powerpoint гэх мэт баримт бичиг үүсгэхийн тулд)

-   Shiny (интерактив вэб апп бүтээх)

-   Дата зураглалын **ggplot2** багц

-   Картографи (GIS)

-   **leaflet** багц (интерактив газрын зураг)

-   Python-ийг R-тай хамт ашиглах (**reticulate** багц)

Энэ бол [Excel хэрэглэгчдэд](https://jules32.github.io/r-for-excel-users/) зориулагдсан онлайн материал.

### Twitter {.unnumbered}

R нь маш идэвхтэй жиргээчдийн хамт олонтой бөгөөд эндээс та R-тай холбоотой төрөл бүрийн зөвлөгөө, товчлол, мэдээ авч болно. Эдгээр хаягуудыг дагана уу:

-   Биднийг дагаарай! [\@epiRhandbook](https://twitter.com/epirhandbook)\
-   Өдөрт нэг R функц [\@rfuntionaday](https://twitter.com/rfunctionaday) хэмээх энэ хаяг бол *маш сайн* мэдээлэлтэй\
-   Дата шинжлэх ухаанд R-ыг [\@rstats4ds](https://twitter.com/rstats4ds?lang=en)\
-   RStudio [\@RStudio](https://twitter.com/rstudio?lang=en)\
-   RStudio зөвлөгөөнүүд [\@rstudiotips](https://twitter.com/rstudiotips)\
-   R-Bloggers [\@Rbloggers](https://twitter.com/Rbloggers)\
-   R-ladies [\@RLadiesGlobal](https://twitter.com/RLadiesGlobal)\
-   Hadley Wickham [\@hadleywickham](https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)

Мөн:

**#epitwitter** болон **#rstats**

### Үнэгүй онлайн материалууд {.unnumbered}

Hadley Wickham, Garrett Grolemund нарын бичсэн [Дата шинжлэх ухаанд R](https://r4ds.had.co.nz/)-ыг ном нь энэ чиглэлийн хамгийн гол сурах бичиг юм.

[R4Epis төслийн](https://r4epis.netlify.app/) вэбсайт нь "[MSF](https://www.msf.org/)-ийн яаралтай тусламжийн нөхцөлд тохиолддог дэгдэлтийн түгээмэл төрлүүд болон хүн амд суурилсан асуумж судалгааны дата цэвэрлэх, анализ хийх, тайлан гаргахад зориулсан стандартчилагдсан хэрэгслүүдийг боловсруулах" зорилготой юм. Та эндээс R-ын анхан шатны сургалтын материалууд, дэгдэлт, асуумж судалгааны RMarkdown тайлангийн загвар болон тэдгээрийг ашиглаж эхлэхэд туслах хичээлүүдийг олж болно.

### Англи хэлээс бусад хэл {.unnumbered}

[Materiales de RStudio en Español](https://www.rstudio.com/collections/espanol/)

[Introduction à R et au tidyverse (Francais)](https://juba.github.io/tidyverse/index.html)

<!-- ======================================================= -->

## Суулгалт

### R болон RStudio {.unnumbered}

**R хэрхэн суулгах вэ**

<https://www.r-project.org/> вэбсайт руу орж өөрийн компьютерт тохирсон R-ын хамгийн сүүлийн хувилбарыг татаж авна уу.

**RStudio хэрхэн суулгах вэ**

<https://rstudio.com/products/rstudio/download/> вэбсайт руу орж өөрийн компьютерт тохирсон RStudio-гийн хамгийн сүүлийн үеийн үнэгүй хувилбарыг татаж авна уу.

**Зөвшөөрлүүд**\
Та R ба RStudio-г өөрийн унших (read), бичих (write) зөвшөөрөлтэй драйвт суулгах ёстойг анхаарна уу. Тэгэхгүй бол таны R багцуудыг суулгах явцад (түгээмэл тохиолддог) сөргөөр нөлөөлөх болно. Хэрэв танд асуудал тулгарвал RStudio нээх лого дээр хулганы баруун товчийг дараад "Run as administrator" сонгон нээхийг оролдоно уу. Бусад зөвлөмжийг \[Сүлжээний драйв дээрх R\] хуудаснаас олж болно.

**R болон RStudio-г хэрхэн шинэчлэх вэ**

R-ийг эхлүүлэх үед консол дээр таны R программын хувилбар харагддаг. Мөн та `sessionInfo()` функцийг ажиллуулан харж болно.

R-г шинэчлэхийн тулд дээр дурдсан вэбсайт руу орж R-г дахин суулгаарай. Өөрөөр **installr** багцын (Windows дээр) `installr::updateR()` функцыг ажиллуулснаар шинэчилж болно. Энэ функц нь танд хамгийн сүүлийн үеийн R хувилбарыг татаж авах, багцуудаа шинэ R хувилбар болгон шинэчлэхэд туслах харилцах цонхыг нээх болно. Дэлгэрэнгүй мэдээллийг **installr** [баримт бичгээс](https://www.r-project.org/nosvn/pandoc/installr.html) олж болно.

Ингэж суулгасны дараа R-ын хуучин хувилбар таны компьютер дээр байсаар байх болно гэдгийг анхаарна уу. Та RStudio дээрх "Tools" -> "Global Options" дээр дарж R хувилбарыг сонгож R-ын хуучин хувилбарыг (хуучин "суулгац") түр ажиллуулж болно. Энэ үйлдэл нь та R-ын хамгийн сүүлийн хувилбарт зориулан шинэчлэгдээгүй байгаа багцыг ашиглах шаардлагатай үед хэрэг болдог.

RStudio-г шинэчлэхийн тулд та дээрх вэбсайт руу орж RStudio-г дахин татаж авах боломжтой. Өөр нэг сонголт нь RStudio дотор "Help" -> "Check for Updates" дээр дарах бөгөөд гэвч энэ нь хамгийн сүүлийн үеийн шинэчлэлтийг харуулахгүй байж магадгүй.

Энэхүү гарын авлагыг бүтээхэд R, RStudio эсвэл багцуудын аль хувилбарыг ашигласан болохыг харахын тулд \[Редакцийн болон техникийн тэмдэглэл\] хуудсыг үзнэ үү.

### Суулгах шаардлагатай болж магадгүй бусад програм хангамж {.unnumbered}

-   TinyTeX (*RMarkdown-ыг PDF болгон нэгтгэхэд зориулсан*)\
-   Pandoc (*RMarkdown-ыг нэгтгэхэд зориулсан*)\
-   RTools (*R-ын багцуудыг угсрахад зориулсан*)\
-   phantomjs (*халдварын гинжин хэлхээ гэх мэт хөдөлгөөнт сүлжээнүүдийн хөдөлгөөнгүй зургийг хадгалахад зориулсан*)

#### TinyTex {.unnumbered}

TinyTex бол LaTeX-ийн custom түгээлт бөгөөд R-аас PDF үүсгэхэд хэрэгтэй байдаг. Дэлгэрэнгүй мэдээллийг <https://yihui.org/tinytex/> харна уу.

R-аас TinyTex-ийг суулгахын тулд:

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# TinyTeX-ийг устгахын тулд tinytex::uninstall_tinytex() ажиллуулна
```

#### Pandoc {.unnumbered}

Pandoc бол баримт бичиг хөрвүүлэгч, R-аас тусдаа програм хангамж юм. **Энэ нь RStudio-той цуг ирдэг тул тусад нь татаж авах шаардлагагүй.** Pandoc нь Rmarkdown-ыг .pdf гэх мэт формат руу хөрвүүлэх, комплекс үйлдлүүд хийхэд тусалдаг.

#### RTools {.unnumbered}

RTools бол R-д зориулсан багц үүсгэх програм хангамжийн цуглуулга юм.

Энэ вэбсайтаас суулгана: <https://cran.r-project.org/bin/windows/Rtools/>

#### phantomjs {.unnumbered}

Энэ нь ихэвчлэн вэб хуудсуудын "screenshot" авахад ашиглагддаг. Жишээлбэл, та **epicontacts** багц ашиглан халдварын гинжин хэлхээ хийх үед интерактив, динамик HTML файлыг гаргадаг. Хэрэв та үүнээс статик зураг авахыг хүсч байвал энэ үйл явцыг автоматжуулахын тулд [**webshot**](https://wch.github.io/webshot/articles/intro.html)багцыг ашиглаж болно. Үүний тулд "phantomjs" програм шаардлагатай. Та **webshot** багцаар дамжуулан `webshot::install_phantomjs()` командын тусламжтайгаар phantomjs-ийг суулгаж болно.

<!-- ======================================================= -->

## RStudio {#rstudio}

### RStudio чиг баримжаа {.unnumbered}

**Эхлээд RStudio-г нээ.** Тэдний лого нь хоорондоо маш төстэй харагддаг тул та R биш *RStudio*-г нээж байгаа эсэхээ шалгаарай.

RStudio-ийг ажиллуулахын тулд та компьютер дээрээ R суулгасан байх ёстой (суулгах зааврыг дээрээс үзнэ үү).

**RStudio** нь R ашиглахыг хялбарчилж буй интерфэйс юм (GUI). Та R-ыг машины хөдөлгүүр, гол ажлыг нь хийж байгаа гэж, харин RStudio-г тухайн хөдөлгүүрийг урагшлуулахад тусалдаг машины их бие (суудал, дагалдах хэрэгсэл гэх мэт) гэж ойлгож болно! Та RStudio хэрэглэгчийн интерфэйсийн бүрэн cheatsheet-ийг (PDF) [эндээс](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) үзэх боломжтой.

Хамгийн эхний байдлаар RStudio нь дөрвөн тэгш өнцөгт самбарыг харуулдаг.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```

[***ЗӨВЛӨГӨӨ:*** Хэрэв таны RStudio зүүн талдаа ганцхан дэлгэцтэй байгаа бол энэ нь та скриптүүд хараахан нээгээгүй байгаатай холбоотой юм.]{style="color: black;"}

**Үүсвэр самбар (Source pane)**\
Эхний байдлаар зүүн дээд буланд байдаг энэ самбар нь [скриптүүдээ](#scripts) засварлах, ажиллуулах, хадгалах зай юм. Скриптүүд нь таны ажиллуулахыг хүссэн командуудыг агуулдаг. Энэ самбар нь мөн датасетүүд (датафрэйм) харуулах боломжтой.

Stata хэрэглэгчдийн хувьд энэ самбар нь таны Do-file болон Data Editor цонхтой төстэй юм.

**R консол самбар (Console pane)**

RStudio дотор R консол нь зүүн эсвэл зүүн доод хэсэгт эхний байдлаар байрладаг бөгөөд R-ын "хөдөлгүүр"-ийн гэр юм. Энэ нь командуудын ажилладаг хэсэг бөгөөд график бус гаралт, алдаа/анхааруулах мессеж гарч ирдэг. Та R консолд командуудыг шууд оруулж ажиллуулж болох боловч скриптээс командыг ажиллуулахад хадгалагдаж үлддэг шиг эдгээр командууд хадгалагддаггүй гэдгийг ойлгоорой.

Хэрэв та Stata мэддэг бол R консол нь Command Window болон Results Window-тэй адил юм.

**Орчны самбар (Environment Pane)**\
Програм нээгдэх үед баруун дээд буланд байдаг энэ самбарыг ихэвчлэн тухайн ажиллаж буй үеийн R-ын орчинд буй [объектуудын](#objects#objects#objects#objects#objects#objects#objects) товч мэдээллийг харахад ашигладаг. Эдгээр объектууд нь импортолсон, өөрчлөгдсөн эсвэл үүсгэсэн датасетүүд, таны тодорхойлсон параметрүүд (жишээлбэл, тухайн анализад зориулсан тодорхой эпи долоо хоног), эсвэл анализ хийх үед тодорхойлсон векторууд эсвэл листүүд (жишээлбэл, бүс нутгийн нэрс) байж болно. Та датафрэймийн нэрний хажууд байгаа сумыг дарж хувьсагчдыг нь харах боломжтой.

STATA-д энэ нь Variables Manager цонхтой хамгийн төстэй юм.

Энэ самбарт мөн өмнө нь ажиллуулсан командуудыг харах боломжтой *History* таб орно. Мөн та **learnr** багцыг суулгасан бол интерактив R хичээл хийх боломжтой "Tutorial" таб энд байдаг. Эдгээрээс гадна энэхүү самбарт гадаад холболт хийхэд зориулсан "Connections" таб, Github-тай интерфэйс хийвэл гарч ирдэг "Git" хэмээх табуудыг агуулагддаг.

**Plots, Viewer, Packages, болон Help самбар**

Баруун доод хэсэгт хэд хэдэн чухал табууд байдаг. Газрын зураг зэргийг багтаасан түгээмэл график дүрслэлүүдийг Plot таб дээр харуулна. Интерактив эсвэл HTML гаралтууд нь Viewer табд гарч ирнэ. Help таб нь баримт бичиг, тусламжийн файлуудыг харуулдаг. Файлын самбар нь файл нээх эсвэл устгахад зориулагдсан хөтөч юм. Packages таб нь танд R багцыг харах, суулгах, шинэчлэх, устгах, ачаалах/буулгах, танд байгаа багцын хувилбарыг харах боломжийг олгодог. Багцын талаар илүү ихийг мэдэхийг хүсвэл доорх [багц хэсгээс](#packages) үзнэ үү.

Энэ самбар нь Stata-гийн Plots Manager болон Project Manager цонхнуудтай төстэй мэдээлэл агуулдаг.

### RStudio тохируулгууд {.unnumbered}

RStudio-ийн тохиргоо болон харагдах байдлыг Tools цэснээс Global Options-ийг сонгон өөрчилнө үү. Тэнд та харагдах байдал/дэвсгэр өнгө зэрэг үндсэн тохиргоонуудыг өөрчилж болно.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options_1.png"))

knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```

**Дахин эхлүүлэх (Restart)**

Хэрэв таны R гацвал Session цэс рүү ороод "Restart R" дээр дарж R-г дахин эхлүүлж болно. Энэ нь RStudio-г бүхэлд нь хааж, нээхээс зайлсхийдэг. Үүнийг хийснээр таны R орчинд байгаа бүх зүйл устах болно.

### Гарын товчлолууд (Keyboard shortcuts) {.unnumbered}

Зарим тун хэрэгтэй гарын товчлолуудыг доор харуулав. Энэхүү RStudio [хэрэглэгчийн интерфэйсийн cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf)-ийн хоёр дахь хуудаснаас Windows, Mac, Linux-ийн бүх гарын товчлолыг үзнэ үү.

| Windows/Linux                          | Mac                    | Үйлдэл                                                                                                                                         |
|----------------------------------------|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| Esc                                    | Esc                    | Одоогийн командыг зогсоох (хэрэв та санамсаргүйгээр бүрэн бус командыг ажиллуулаад R консол дээр "+" тэмдэг гарчихаад байгаа үед хэрэг болдог) |
| Ctrl+s                                 | Cmd+s                  | Хадгалах (скрипт)                                                                                                                              |
| Tab                                    | Tab                    | Автоматаар дүүргэх                                                                                                                             |
| Ctrl + Enter                           | Cmd + Enter            | Одоогийн кодын мөр(үүд)/сонголтыг ажиллуулах                                                                                                   |
| Ctrl + Shift + C                       | Cmd + Shift + c        | Тодруулсан мөрүүдэд тайлбар нэмэх/тайлбарыг арилгах                                                                                            |
| Alt + -                                | Option + -             | `<-` тэмдэг оруулах                                                                                                                            |
| Ctrl + Shift + m                       | Cmd + Shift + m        | `%>%` тэмдэг оруулах                                                                                                                           |
| Ctrl + l                               | Cmd + l                | R консол цэвэрлэх                                                                                                                              |
| Ctrl + Alt + b                         | Cmd + Option + b       | Эхнээс одоогийн мөр хүртэл ажиллуулах                                                                                                          |
| Ctrl + Alt + t                         | Cmd + Option + t       | Одоогийн кодын хэсгийг ажиллуулах (R Markdown)                                                                                                 |
| Ctrl + Alt + i                         | Cmd + Shift + r        | Кодын хэсэг оруулах (R Markdown руу)                                                                                                           |
| Ctrl + Alt + c                         | Cmd + Option + c       | Кодын хэсэг ажиллуулах (R Markdown)                                                                                                            |
| R консолд дээшээ/доошоо сумаар         | Ижил                   | Саяхан ажиллуулсан командуудыг сэлгэх                                                                                                          |
| Скрипт дотор Shift + дээшээ/доошоо сум | Ижил                   | Олон кодын мөрийг сонгох                                                                                                                       |
| Ctrl + f                               | Cmd + f                | Одоогийн скрипт дотор хайж олоод солих                                                                                                         |
| Ctrl + Shift + f                       | Cmd + Shift + f        | Файлуудаас хайх (олон скриптийн дунд хайх/солих)                                                                                               |
| Alt + l                                | Cmd + Option + l       | Сонгосон кодыг хумих                                                                                                                           |
| Shift + Alt + l                        | Cmd + Shift + Option+l | Сонгосон кодыг дэлгэх                                                                                                                          |

[***ЗӨВЛӨГӨӨ:*** RStudio-ийн автоматаар дүүргэх үйлдлийг ашиглахын тулд бичихдээ Tab товчлуураа ашиглана уу. Ингэснээр функцын нэрийг буруу бичихээс урьдчилан сэргийлэх боломжтой юм. Бичлэгийн дундаа Tab товчийг дарснаар одоог хүртэл бичсэн байгаа зүйл дээр үндэслэн байж болох боломжит функцууд болон объектуудын жагсаалтыг гаргана.]{style="color: darkgreen;"}

<!-- ======================================================= -->

## Функцууд {#functions}

Функцууд нь R-ыг ашиглах гол цөм болдог. Функцын тусламжтайгаар та төрөл бүрийн даалгавар, үйлдлүүдийг гүйцэтгэх боломжтой болж буй юм. Нэлээд олон функцууд R-тай хамт суулгагдан ирдэг бөгөөд бусад олон функцуудыг *багц* хэлбэрээр татаж авах боломжтойгоос ([багцууд](#packages) хэсэгт тайлбарласан) гадна та өөрийн хүссэн функцээ өөрөө бичиж болно!

Энэхүү функцийн талаархи суурь ойлголтын хэсэгт дараах зүйлийг тайлбарласан болно:

-   Функц гэж юу вэ, тэд хэрхэн ажилладаг талаар

-   Функцын аргументууд гэж юу болох талаар

-   Тодорхой функцийг ойлгоход хэрхэн тусламж авах талаар

*Синтаксийн талаархи товч тэмдэглэл:* Энэхүү гарын авлагад функцуудыг код-текст маягаар нээлттэй хаалт бүхий бичсэн болно, жишээ нь: `filter()`. [Багцууд](#packages) хэсэгт тайлбарласны дагуу функцуудыг *багцууд* дотор татаж авдаг. Энэхүү гарын авлагад багцын нэрийг **dplyr** гэж байгаа шиг тодоор (**bold**) бичсэн. Заримдаа жишээ код дээр та функцын нэрийг багцын нэртэй хоёр цэгээр (`::`) буюу ийм байдлаар `dplyr::filter()` холбон бичсэн байхыг харж болно. Энэхүү холболтын зорилгыг [багцууд](#packages) хэсэгт тайлбарласан.

<!-- ======================================================= -->

### Энгийн функцууд {.unnumbered}

**Функц нь оролтыг хүлээн авч, тэдгээр оролтон дээр ямар нэгэн үйлдэл хийж, гаралт гаргадаг машинтай адил юм.** Ямар гаралт байх нь тухайн функцээс хамаарна.

**Функцууд нь ихэвчлэн функцын хаалтанд байрлуулсан зарим объект дээр ажилладаг.** Жишээлбэл, `sqrt()` функц нь тооны квадрат язгуурыг тооцоолно:

```{r basics_function_sqrt}
sqrt(49)
```

Мөн функцэд оруулж буй объект нь датасетийн багана байж болно (бүх төрлийн объектуудын талаар дэлгэрэнгүйг [Объектууд](#objects) хэсгээс үзнэ үү). R нь олон тооны датасет хадгалах боломжтой тул та датасет болон баганыг хоёуланг нь зааж өгөх хэрэгтэй. Үүнийг хийх нэг арга бол \$ тэмдэглэгээг ашиглан датасетийн нэр болон баганын нэрийг (`dataset$column`) холбох юм. Доорх жишээн дээр `linelist` хэмээх датасетийн `age` хэмээх тоон баганыг `summary()` функцэд оруулснаар тухайн баганы тоон болон дутуу утгуудын хураангуй мэдээлэл гарч байна.

```{r basics_functions_summary}
# 'linelist' датасетийн 'age' баганы хураангуй статистикүүдийг хэвлэх 
summary(linelist$age)
```

[***ТЭМДЭГЛЭЛ:*** Хөшигний цаана функц нь хэрэглэгчдэд зориулж нэг хялбар командад багтаасан комплекс нэмэлт кодуудын бүрдэл байдаг.]{style="color: black;"}

<!-- ======================================================= -->

### Олон аргументтай функцууд {.unnumbered}

Функцууд нь ихэвчлэн таслалаар хоорондоо тусгаарлагдсан, функцын хаалтан дотор байрлах ***аргумент*** гэж нэрлэгддэг хэд хэдэн оролтыг шаарддаг.

-   Зарим аргумент функцыг ажиллуулахын тулд заавал шаардлагатай байдаг бол зарим нь заавал байх шаардлагагүй

-   Заавал байх шаардлагагүй аргументууд нь анхдагч утгатай байдаг

-   Аргументууд нь тэмдэгт (character), тоон, логик (ҮНЭН/ХУДАЛ) болон бусад оролтыг авч болно

Энд ердийн функцийн жишээ болгон `oven_bake()` гэсэн зохиомол функц байна. Энэ функц нь оролтын объектыг (жишээлбэл, датасет эсвэл энэ жишээнд байгаа шиг "dough") авч, нэмэлт аргументуудаар тодорхойлсон (`minutes =` ба `temperature =`) үйлдлүүдийг гүйцэтгэж байна. Гаралтыг консол дээр шууд хэвлэх эсвэл оноох операторыг (\<-) ашиглан объект болгон хадгалах боломжтой .

```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```

**Илүү бодитой жишээ дурдвал** доорхи `age_pyramid()` команд нь тодорхой насны бүлгүүд болон `gender` гэх мэт хоёртын баганууд дээр үндэслэн насны пирамидын зургийг гаргадаг. Энэхүү функцэд хаалтан дотор нь таслалаар тусгаарлагдсан гурван аргумент өгөгдсөн байна. Аргументэд өгсөн утгууд нь `linelist`-ийг ашиглах датафрэймээр, `age_cat5`-ийг тоолох баганаар, `gender`-ийг пирамидыг өнгөөр хуваахад ашиглах хоёртын баганаар ашиглаж байна.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE,}
## категорийн завсар үүсгэх байдлаар насны бүлгийн хувьсагч үүсгэх
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# насны пирамид зурах
age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

Дээрх командыг аргумент бүр шинэ мөрөн дээр байх замаар урт болгон доорхтой адилаар бичиж болно. Ингэж кодоо бичих нь уншихад илүү хялбар, хэсэг тус бүрийг тайлбарлахын тулд `#`-тэй "тайлбар" бичихэд илүү хялбар болгодог (дэлгэрэнгүй тайлбар хийж явах нь сайн практик!). Энэхүү урт командыг ажиллуулахын тулд та тушаалыг бүхэлд нь тодруулан "Run" дээр дарах эсвэл курсороо эхний мөрөнд байрлуулаад Ctrl, Enter товчлууруудыг нэгэн зэрэг дарж болно.

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# насны пирамид зурах
age_pyramid(
  data = linelist,        # тохиолдлын linelist хэрэглэх
  age_group = "age_cat5", # насны бүлгийн баганыг зааж өгөх
  split_by = "gender"     # 2 талтай пирамид зурахын тулд хүйсийн баганыг ашиглах
  )
```

Аргументыг тодорхой дарааллаар бичсэн тохиолдолд (функцын баримт бичигт заасны дагуу) тухайн аргументын эхний хагасыг (жишээ нь, `data =`) бичих шаардлагагүй. Доорх код нь дээрхтэй яг ижил пирамид үүсгэдэг, учир нь энэхүү функц нь датафрэйм, `age_group` хувьсагч, `split_by` хувьсагчийн аргументуудыг яг ийм дараалалтайгаар хүлээж байдаг.

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# Энэ команд нь дээрхтэй яг ижил график үүсгэх болно
age_pyramid(linelist, "age_cat5", "gender")
```

**Илүү комплекс `age_pyramid()` команд нь заавал шаардлагагүй дараахь аргументуудыг агуулж болно:**

-   Тооны оронд пропорцыг харуулах (анхдагч утга нь `FALSE` үед `proportional = TRUE` гэж өөрчилнө)

-   Ашиглах хоёр өнгийг тодорхойлох (`pal =` гэдэг нь "palette" гэсэн үгийн товчлол бөгөөд хоёр өнгөний нэр бүхий вектороор хангагдсан байна. `c()` функц хэрхэн вектор үүсгэдэгийг [объектууд](#objectstructure) хуудаснаас үзнэ үү)

[***ТЭМДЭГЛЭЛ:*** Аргументийн хоёр хэсгийг хоёуланг нь зааж өгсөн (жишээ нь `proportional = TRUE`) үед тухайн аргумент дарааллын хувьд хаана байрлах нь хамаагүй болно.]{style="color: black;"}

```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(
  linelist,                    # тохиолдлын linelist хэрэглэх
  "age_cat5",                  # насны бүлгийн багана
  "gender",                    # хүйсээр хуваах
  proportional = TRUE,         # тооны оронд хувь хэрэглэх
  pal = c("orange", "purple")  # өнгөнүүд
  )
```

<!-- ======================================================= -->

### Функц бичих {.unnumbered data-link="Writing functions"}

R бол функцэд чиглэсэн хэл тул та өөрийн функцийг бичих мэдлэгийг эзэмшсэн байх ёстой. Өөрөө функц бичих нь хэд хэдэн давуу талтай:

-   Модульчлагдсан програмчлалыг хөнгөвчлөх - кодыг бие даасан, удирдах боломжтой хэсгүүдэд хуваадаг

-   Алдаа гаргах магадлал өндөртэй байдаг давтагдсан copy, paste хийхийг орлох

-   Кодын хэсгүүдэд мартагдахааргүй нэр өгөх

Функцийг хэрхэн бичих талаар Функц бичих хуудсан дээр дэлгэрэнгүй авч үзсэн болно.

<!-- A function is given a name and defined with the assignment operator `<-` to a special **base** R function called `function()`. Within the parentheses, the arguments that the function will accept are defined. This is followed by curly brackets `{ }`, within which the actual code of the function is written.     -->

```{r, eval=F, echo=F}
my_function <- function( ЭНД АРГУМЕНТУУД ){ ЭНД КОД }
```

<!-- The arguments should be provided in the syntax `argument = default`, separated by commas.   -->

<!-- Here is an example where we create a function `staff_calc()` to serve as a staffing calculator for COVID-19 case investigation and contact tracing calls.   -->

<!-- The arguments (inputs) and their default values will be:   -->

<!-- * `daily_cases = NULL` The number of new COVID-19 cases per day   -->

<!-- * `contacts_each = 5` The number contacts enumerated for each case   -->

<!-- * `time_case = 0.5`  Number of hours to complete a case investigaton by phone   -->

<!-- * `time_contact = 0.25`  Number of hours to complete a contact follow-up by phone   -->

<!-- * `time_day = 8` The number of hours one staff works per day   -->

<!-- Below, the function is created. The code ends with the special function `return()`, which is what the function produces.    -->

<!-- ```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->

<!-- staff_calc <- function(daily_cases = NULL, contacts_each = 5, -->

<!--                        time_case = 0.5, time_contact = 0.25, time_day = 8){ -->

<!--   # Define total daily hours for calling cases -->

<!--   case_hours <- daily_cases * time_case  -->

<!--   # Define total daily hours for calling contacts -->

<!--   contact_hours <- daily_cases * contacts_each * time_contact -->

<!--   # Calculate number of staff required -->

<!--   staff_required <- (case_hours + contact_hours)/time_day -->

<!--   return(staff_required) -->

<!-- } -->

<!-- ``` -->

<!-- Once this code is run, the function will be defined and will appear in the R Environment. We can run the function. Below all the default values are used and the `daily_cases = ` is set to 150.   -->

```{r eval=F, echo=F, message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
staff_calc(daily_cases = 150)
```

```{r, eval=F, echo=F}
case_incidence <- tibble(
  dates = seq.Date(from = as.Date("2020-05-01"), to = as.Date("2020-05-21"), by = 1),
  projected_incidence = c(102,110,50,37,106,190,146,138,135,111,60,43,189,184,185,80,44,97,254,291,288),
  staff_needed = staff_calc(projected_incidence)
)

ggplot(case_incidence, aes(x = dates))+
  geom_line(aes(y = projected_incidence))+
  geom_line(aes(y = staff_needed))
```

<!-- There are many other nuances to understand when writing functions, as discussed in the page [Writing functions].   -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багцууд {#packages}

**Багцууд нь функцуудээс бүрддэг.**

R багц гэдэг нь урьдчилан тодорхойлсон функцуудыг агуулсан код, баримт бичгийн нэгдэл юм. R-ын хэрэглэгчид тодорхой асуудлуудад зориулагдсан багцуудыг үргэлж хөгжүүлж байдаг бөгөөд таны ажилд тусалж чадах багц байгаа нь ч эргэлзээгүй! Та R ашиглах явцдаа хэдэн зуун багцыг суулгаж ашиглах болно.

Анх R суулгахад түгээмэл, энгийн даалгавруудыг гүйцэтгэх чадвартай "**base**" багцууд болон функцууд хамт ирдэг. Гэвч олон R хэрэглэгчид өөрсдийн тусгай функцууд зохион **багц** болгосноор бусад хэрэглэгчид хэрэглэн функцуудын үйл ажиллагааг шалгах боломжтой болдог. Энэхүү гарын авлагад багцын нэрийг **тодоор** бичсэн. R -ын бага зэрэг төвөгтэй талуудын нэг нь тодорхой даалгаврыг биелүүлэхийн тулд олон функц, багцуудаас сонгох явдал байдаг.

### Суулгах, ачаалах {.unnumbered}

Интернетээс компьютер дээрээ татаж авдаг ("суулгадаг") **багцуудад** *функцууд* агуулагдсан байдаг. Багцыг татаж авсны дараа таны "library"-д хадгалагдах болно. Дараа нь та багцаа "ачаалах" замаар тухайн багцын агуулж буй функцыг R ашиглах үедээ хэрэглэх боломжтой.

*Та R-г өөрийн хувийн номын сан гэж бод:* Та багц татаж авахад таны номын сан тухайн багцын функцүүд бүхий шинэ номтой болж байна гэсэн үг, улмаар та тухайн номны функц ашиглахыг хүсэх болгондоо тэр номыг номын сангаасаа зээлэх ("ачаалах") ёстой.

Дүгнээд хэлэхэд: R багцад байгаа функцийг ашиглахын тулд 2 алхамыг хэрэгжүүлэх ёстой:

1.  Багцыг (нэг удаа) **суулгасан (installed)** байх ёстой

2.  Багцыг **ачаалах (load)** ёстой (R ашиглах бүртээ)

#### Таны номын сан (library) {.unnumbered}

Таны "номын сан" нь үнэндээ таны компьютер дээр суулгагдсан багц бүрийн хавтсыг агуулсан хавтас юм. R таны компьютерт хаана суусан болохыг олж мэдээд "win-library" нэртэй хавтас хайж олоорой. Жишээ нь: `R\win-library\4.0` (4.0 бол R-ын хувилбар юм. Таны татаж авсан R-ын хувилбар бүр өөрийн номын сантай).

Та `.libPaths()` (хоосон хаалттай) функцыг R консол дээр ажиллуулснаар таны номын сангийн файлын байршлыг харах боломжтой. Ялангуяа \[сүлжээний хөтчүүд дээр R\]-тай ажиллахад энэ нь онцгой ач холбогдолтой.

#### CRAN-аас суулгах {.unnumbered}

Ихэнх тохиолдолд R хэрэглэгчид CRAN-аас багц татаж авдаг. CRAN (Comprehensive R Archive Network - R-ын цогц архивын сүлжээ) нь R хэрэглэгчдийн нийтэлсэн R багцын олон нийтийн, онлайн агуулах юм.

CRAN-аас багц татаж авахдаа вирус, аюулгүй байдлын талаар санаа зовж байна уу? Энэ сэдвээр [энэ нийтлэлийг](https://support.rstudio.com/hc/en-us/articles/360042593974-R-and-R-Package-Security) уншина уу.

#### Хэрхэн суулгаж, ачаалах вэ? {.unnumbered}

Энэхүү гарын авлагад бид **pacman** багцыг ашиглахыг санал болгож байна ("package manager" гэсэн үгийн товчлол). Энэхүү багц нь хэрэглэхэд хялбар `p_load()` хэмээх функцтэй бөгөөд энэхүү функц нь шаардлагатай бол багцыг суулгаж, одоогийн R сесст ачаалдаг.

Синтакс нь маш энгийн. Хэрэглэх багцуудын нэрийг таслалаар тусгаарлан `p_load()` функцын хаалтанд жагсаан бичнэ. Доорх команд нь **rio**, **tidyverse** болон **here** багцуудыг хараахан суулгаагүй байвал суулгаж, ашиглахаар ачаалах болно. Ингэснээр `p_load()` ашиглах арга нь скриптээ бусадтай хуваалцахыг хялбар, тодорхой болгодог. Багцын нэрүүдийн үсгийн том, жижгийн хэмжээ чухал гэдгийг анхаарна уу.

```{r}
# Хэрэглэх багцуудыг (хэрэв шаардлагатай бол) суулгаад ачаалах
pacman::p_load(rio, tidyverse, here)
```

Бид функцийн нэр (`p_load()`)-ийн өмнө багцын нэрийг (**pacman**) хоёр цэгээр `::` холбон бичдэг `pacman::p_load()` синтаксыг ашигласан болохыг анхаарна уу. Энэ синтаксыг ашигласнаар **pacman** багцыг (өмнө нь суулгасан үед) шууд ачаалж байгаа тул амар байдаг.

Та мөн **base** R-ын алтернатив функцуудыг түгээмэл харах болно. Багц суулгах **base** R функц нь `install.packages()` юм. Суулгах багцын нэрийг хаалтнд *ишлэл* доторбичих ёстой. Хэрэв та нэг командаар олон багц суулгахыг хүсвэл тэдгээрийг `c()` тэмдэгтийн вектор дотор жагсаан бичнэ.

Тэмдэглэл: энэ команд нь багцыг *суулгадаг* боловч одоогийн сешн дээр ашиглахаар ачаалдаггүй.

```{r, eval=F}
# base R ашиглан нэг багц суулгах
install.packages("tidyverse")

# base R ашиглан олон багц суулгах
install.packages(c("tidyverse", "rio", "here"))
```

Мөн point-and-click замаар багц суулгая гэвэл RStudio-ийн "Packages" таб дээр очоод "Install" дээр дарж хүссэн багцын нэрийг хайж олон суулгаж болдог.

Суулгасны дараа багцыг ашиглахаар **ачаалах base** R функц нь `library()` юм. Энэ функц нь нэг удаад зөвхөн нэг багцыг ачаалах боломжтой (`p_load()` ашиглах өөр нэг шалтгаан). Та багцын нэрийг ишлэлтэй эсвэл ишлэлгүйгээр өгөх боломжтой.

```{r, eval=F}
# base R ашиглан багц ачаалах
library(tidyverse)
library(rio)
library(here)
```

Багц суулгасан ба/эсвэл ачаалагдсан эсэхийг шалгахын тулд RStudio дахь Packages табыг үзэх боломжтой. Хэрэв багцыг суулгасан бол хувилбарын дугаараар тэнд харуулна. Хэрэв багцын өмнөх хайрцаг тэмдэглэгдсэн байвал тухайн багц нь одоогийн сешнд ачаалагдсан байна гэсэн үг.

**Github-аас суулгах**

Зарим тохиолдолд CRAN-д хараахан байхгүй байгаа багцыг суулгах шаардлагатай болдог. Эсвэл тодорхой багц CRAN дээр байгаа боловч тэрхүү илүү тогтвортой CRAN дээрх хувилбарт хараахан орж ирээгүй байгаа шинэ боломжуудтай *хөгжлийн хувилбарыг* хэрэглэх шаардлага гарч магад юм. Эдгээр нь ихэвчлэн [github.com](https://github.com/) вэбсайт дээр олон нийтэд нээлттэй, үнэгүй кодын "репозитор"-д байршиж байдаг. Github-ын талаар дэлгэрэнгүйг гарын авлагын \[Хувилбарын хяналт ба Git, Github ашиглан хамтран ажиллах\] хуудаснаас уншина уу.

Github-аас R багц татаж авахын тулд та **pacman** багцын `p_load_gh()` функцийг ашиглаж болох бөгөөд энэ функц нь шаардлагатай бол багцыг суулгаж, одоогийн R сешнд ашиглах боломжтой болгон ачаалах болно. Өөрөөр **remotes** эсвэл **devtools** багцыг ашиглан Github-аас багц суулгах боломжтой. **pacman** багцын бүх функцын талаар [багцын баримт бичгээс](https://cran.r-project.org/web/packages/pacman/pacman.pdf) уншина уу.

Github-аас багц суулгахын тулд та дараах мэдээлэлтэй байх шаардлагатай:

1.  Репозитор эзэмшигчийн Github ID

2.  Багцыг агуулсан репозиторын нэр

3.  *(заавал биш) Татаж авахыг хүсч буй "салбар"-ын нэр (хөгжлийн тусгай хувилбар)*

Доорх жишээнүүдэд ишлэл дэх эхний үг бол репозитор эзэмшигчийн Github ID бөгөөд ташуу зураасны дараа репозиторын нэр (багцын нэр) байгаа болно.

```{r, eval=F}
# epicontacts багцыг Github репозитороос нь суулгах/ачаалах
p_load_gh("reconhub/epicontacts")
```

Хэрэв та үндсэн салбараас өөр "салбар" (хувилбар) суулгахыг хүсвэл репозиторын нэрний ард "\@" тэмдгийн дараа салбарын нэрийг нэмнэ үү.

```{r, eval=F}
# epicontacts багцын "timeline" салбарыг Github-аас суулгах/ачаалах
p_load_gh("reconhub/epicontacts@timeline")
```

Хэрэв Github хувилбар болон таны компьютер дээрх хувилбаруудын хооронд ялгаа байхгүй бол ямар ч үйлдэл явагдахгүй. Та `p_load_current_gh()` функцыг `update = TRUE` аргументтэй ашиглан "хүчээр" дахин суулгаж болно. **pacman** тухай нэмэлтээр энэхүү [онлайн винетээс](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html) уншина уу.

**ZIP эсвэл TAR файлаас суулгах**

Та URL ашиглан багцыг суулгаж болно:

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

Эсвэл үүнийг зип файл хэлбэрээр компьютер дээрээ татаж аваад:

Сонголт 1: **remotes** багцын `install_local()` функц ашиглан

```{r, eval=F}
remotes::install_local("~/Downloads/dplyr-master.zip")
```

Сонголт 2: **base** R-ын `install.packages()` ашиглан, `type = "source"`, `repos = NULL` хэмээн зааж файлын байршлыг ZIP файлд өгнө.

```{r, eval=F}
install.packages("~/Downloads/dplyr-master.zip", repos = NULL, type = "source")
```

### Кодын синтакс {.unnumbered}

Энэхүү гарын авлагад ойлгомжтой болгох үүднээс зарим тохиолдолд функцүүдийн өмнө `::` тэмдгийг ашиглан багцынх нь нэрийг дараах байдлаар бичсэн: `package_name::function_name()`

Багцыг тухайн сешнд ачаалсны дараа багцыг ингэж зааж өгөх шаардлагагүй байдаг. Та зүгээр л `function_name()` ашиглаж болно. Гэсэн хэдий ч нэг функцын нэр нийтлэг хэлбэрээр олон багцад байж болдог бөгөөд энэ тохиолдолд багцын нэрийг бичиж дуудах нь тустай байдаг (жишээ нь `plot()`). Мөн багцын нэрийг ингэж бичихэд хэрэв тухайн багц ачаалагдаагүй байгаа бол багцыг ачаалах болно.

```{r eval=FALSE}
# Энэ команд "rio" багцыг ашиглан түүний "import()" функцыг ашиглан датасет импорт хийж байна
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

### Функцын тусламж {.unnumbered}

Тодорхой функцийн талаар дэлгэрэнгүй уншихын тулд та RStudio-ийн баруун доод хэсэгт байрлах Help таб дээрээс хайх боломжтой. Та мөн `?thefunctionname` (асуултын тэмдгийн дараа функцийн нэрийг оруулна) гэсэн командыг ажиллуулснаар тухайн функцын тусламжийн хуудас нь Help таб дээр гарч ирнэ. Мөн онлайнаар тусламж хайж үзээрэй.

### Багц шинэчлэх {.unnumbered}

Та багцыг дахин суулгах замаар шинэчлэх боломжтой. Та мөн RStudio-ийн Packages таб дээрх ногоон "Update" товчийг дарж аль багцууд шинэ хувилбартай болсныг харж болно. Багц шинэчлэх үед тодорхой функц хэрхэн ажилладаг талаар томоохон өөрчлөлт орсон тохиолдолд хуучин кодоо шинэчлэх шаардлагатай болж магадгүйг анхаарна уу!

### Багц устгах {.unnumbered}

**pacman** багцын `p_delete()` эсвэл **base** R-ын `remove.packages()` функц ашиглана уу. Эсвэл өөрийн library агуулсан хавтсыг компьютер дээрээ олоод багцын хавтсыг гараар устгаж болно.

### Хамааралт багц {.unnumbered}

Багцууд нь ажиллахын тулд ихэвчлэн бусад багцуудыг ашигладаг. Эдгээрийг хамааралт багц (dependencies) гэж нэрлэдэг. Хэрэв хамааралт багцыг суулгаж чадахгүй бол үүнээс хамаарсан багцыг мөн суулгаж чадахгүй байж магадгүй юм.

Тухайн багцын хамааралт багцуудыг `p_depends()` функц ашиглан харах ба `p_depends_reverse()` ашиглан тухайн багцад ямар багцууд хамааралтай болохыг харж болно.

### Далдлах функцууд {.unnumbered}

Хоёр ба түүнээс дээш багц ижил нэртэй функц агуулах нь түгээмэл тохиолддог. Жишээлбэл, **dplyr** багц нь `filter()` функцтэй байхад **stats** багц ч мөн ижил нэртэй функцтэй. Өгөгдмөл (default) `filter()` функц нь эдгээр багцыг R сешнд ачаалах дарааллаас хамаарна - хамгийн сүүлд ачаалагдсан `filter()` өгөгдмөл болох болно.

Та энэхүү дарааллыг R Studio-ийн Environment табаас шалгаж болно - "Global Environment" гэсэн цэсийг дарж, багцын дарааллыг харна уу. Энэ жагсаалтын *доод хэсэгт* байгаа багцын функцууд нь жагсаалтын дээд хэсэгт байгаа багцуудын ижил нэртэй функцийг далдлах болно. Тодорхой багцыг анх ачаалах үед тухайн багцын функц өөр багцын функцийг далдалж байгаа тохиолдолд R консол дээр танд анхааруулах боловч үүнийг анзаарахгүй өнгөрөх нь элбэг байдаг.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

Далдлалтыг засах дараах аргууд байна:

1.  Командад багцын нэрийг зааж өгнө. Жишээлбэл, `dplyr::filter()` ашиглах.

2.  Багцыг ачаалах дарааллыг өөрчлөөд (жишээ нь `p_load()` дотор), **шинэ R сешн эхлүүлнэ**.

### Салгах/буулгах {.unnumbered}

Багцыг салгахын (буулгахын) тулд багцын нэрийг зөвөөр, зөвхөн нэг тодорхойлох цэгтэйгээр энэ командыг бичнэ. Энэ нь далдлах асуудлыг шийдэж чадахгүй байж болохыг анхаарна уу.

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```

### Хуучин хувилбар суулгах {.unnumbered}

Тодорхой багцын хуучин хувилбарыг суулгахын тулд энэ [зааврыг](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages) үзнэ үү.

### Санал болгож буй багцууд {.unnumbered data-link="Suggested packages"}

Өдөр тутмын тархвар судлалын ажилд санал болгож буй багцуудын жагсаалтыг \[Санал болгож буй багцуудын\] хуудаснаас үзнэ үү.

<!-- ======================================================= -->

## Скриптүүд {#scripts}

Скрипт бол програмчлалын үндсэн хэсэг юм. Скрипт гэдэг нь таны командуудыг (жишээ нь датасет үүсгэх, өөрчлөх, дүрслэлийг харуулах функцууд гэх мэт) хадгалдаг баримт бичиг юм. Та скриптийг хадгалаад дараа нь дахин ажиллуулж болно. Скриптэд командуудаа хадгалаад дараа нь скриптээсээ шууд ажиллуулах нь олон давуу талтай байдаг (командуудаа R консол "command line" дээр нэг нэгээр нь бичихийн оронд).

-   Зөөвөрлөх чадвар - та скриптүүдээ илгээх замаар бусадтай хуваалцах боломжтой

-   Давтагдах чадвар - ингэснээр та болон бусад хүмүүс таны яг юу хийснийг мэдэх боломжтой

-   Хувилбарын хяналт - ингэснээр та өөрийн эсвэл хамтран ажиллагсдын хийсэн өөрчлөлтийг хянах боломжтой

-   Тайлбар/тэмдэглэл - хийсэн зүйлээ хамтран ажиллагсаддаа тайлбарлах

### Тайлбар бичих {.unnumbered}

Скрипт дээр та R кодынхоо эргэн тойронд тэмдэглэл ("тайлбар") оруулах боломжтой. Тайлбар бичих нь юу хийж байгаагаа ирээдүйн өөртөө болон бусад кодыг тань хэрэглэгчдэд тайлбарлахад тустай. Та чагт тэмдгийг (#) бичээд дараа нь тайлбараа бичиж болно. Тайлбарласан текст нь R кодоос өөр өнгөөр харагдах болно.

#-тэмдгээс хойш бичигдсэн аливаа код ажиллахгүй. Тиймээс кодын өмнө \# оруулах нь та устгахыг хүсэхгүй байгаа кодын мөрийг түр хаахад ("comment out") ашигладаг арга юм. Та олон кодын мөрийг нэг дор тодруулж Ctrl+Shift+c (Mac дээр Cmd+Shift+c) товчийг дарснаар түр хааж/нээж болно.

```{r, eval = F}
# Тайлбар нь нэг мөрөнд дангаараа байж болно
# дата импортлох
linelist <- import("linelist_raw.xlsx") %>%   # тайлбар кодын дараа бас орж болно
# filter(age > 50)                          # Үүнийг мөн тодорхой кодын мөрийг идэвхгүй болгох/хасахад ашиглаж болно 
  count()

```

-   *Юу* хийж байгаагаа, **яагаад** хийж байгаагаа тайлбарлах.

-   Кодыг логиктой хэсгүүдэд хуваах

-   Өөрийн хийж буй зүйлийн алхам тус бүрийн тайлбарыг кодтойгоо дагалдуулах (жишээлбэл дугаарласан алхамууд)

### Загвар {.unnumbered}

Кодлох загварынхаа талаар тодорхой бодолтой байх нь чухал, ялангуяа багаар ажиллаж байгаа бол. Бид **tidyverse** [загварын зааврын](https://style.tidyverse.org/) дагуу кодоо бичихийг зөвлөж байна. Мөн энэ загварт нийцэхэд тань туслах **styler**, **lintr** гэх мэт багцууд байдаг.

Таны кодыг бусад хүн уншихад хялбар болгох цөөн хэдэн зөвлөмж:

-   Объектуудыг нэрлэхдээ зөвхөн жижиг үсэг, тоо, доогуур зураас `_` ашиглах, жишээ нь `my_data`

-   Space буюу зайг сайн ашиглах, операторуудыг тойруулаад `n = 1` ба `age_new <- age_old + 3` гэх мэт

### Жишээ скрипт {.unnumbered}

Богино R скриптийн жишээг доор харуулав. Та кодоо товч, ойлгомжтой тайлбарлах тусам хамтран ажиллагсад тань танд талархах болно гэдгийг санаарай!

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "example_script.png"))
```

<!-- ======================================================= -->

### R markdown {.unnumbered}

R markdown скрипт бол тухайн скрипт нь өөрөө гаралтын баримт бичиг (PDF, Word, HTML, Powerpoint гэх мэт) болдог R скриптийн төрөл юм. Эдгээр нь динамик, автомат тайланг гаргахад ихэвчлэн хэрэглэгддэг маш хэрэгцээтэй, олон талын хэрэгсэл юм. Энэ вэбсайт, гарын авлагыг хүртэл R markdown скриптээр хийдэг!

R анхлан сурж буй хэрэглэгчид ч R Markdown-ийг ашиглаж болно гэдгийг хэлэх нь зүйтэй - сүрдэх зүйл байхгүй! Нэмж суралцахын тулд \[R Markdown тайлан\] хэмээх гарын авлагын хуудсыг үзнэ үү.

<!-- ======================================================= -->

### R notebook {.unnumbered}

R markdown болон R notebook бичих хоёрын хооронд ялгаа байхгүй. Гэсэн хэдий ч ажиллагааны хувьд бага зэрэг ялгаатай байдаг. Дэлгэрэнгүй мэдээллийг энэ [сайтаас](http://uc-r.github.io/r_notebook) үзнэ үү.

<!-- ======================================================= -->

### Shiny {.unnumbered}

Shiny апп/вэбсайтууд нь `app.R` гэсэн нэртэй нэг скрипт дотор агуулагддаг. Энэ файл нь гурван бүрэлдэхүүн хэсэгтэй:

-   Хэрэглэгчийн интерфэйс (ui)

-   Серверийн функц

-   `shinyApp` функцын дуудлага

\[Shiny хяналтын самбар\] хэмээх гарын авлагын хуудсыг эсвэл энэ онлайн хичээлийг үзнэ үү: [Shiny хичээл](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)

*Өмнө нь дээрх файлыг хоёр файл болгон хуваадаг байсан (`ui.R` ба `server.R`).*

### Код эвхэх {.unnumbered}

Та өөрийн скриптийг уншихад хялбар болгохын тулд кодын хэсгийг эвхэж болно.

Үүнийг хийхийн тулд \# ашиглан текстийн гарчиг үүсгэж, гарчгаа бичээд зураас (-), чагт ( #) эсвэл тэнцүү (=) гэсэн тэмдгийг 4-ээс доошгүйг бичнэ. Ингэхэд зүүн талын "суваг" хэсэгт жижиг сум гарч ирнэ (мөрний дугаарын хажууд). Та энэ сум дээр дарахад гарчгийн доорх кодоос дараагийн гарчиг хүртэл эвхэгдэж оронд нь хоёр толгойтой сум гарч ирэх болно.

Кодыг дэлгэхийн тулд суваг дээрх сум эсвэл хоёр толгойтой сумны дүрс дээр дахин дарна. Энэ хуудасны [RStudio хэсэгт](#rstudio) тайлбарласан шиг гарын товчлолууд бас байдаг.

Чагт (#) ашиглан гарчиг үүсгэснээр та скриптийнхээ доод хэсэгт Агуулгын хүснэгтийг идэвхжүүлэх болно (доороос үзнэ үү). Та \# тэмдгийг нэмж дэд гарчгууд үүсгэж болно, жишээ нь \# нэгдүгээр шатны, ## хоёрдугаар шатны, ##\# гуравдугаар шатны гарчиг гэх мэт.

Жишээ скриптийн хоёр хувилбарыг доор харуулав. Зүүн талд тайлбарласан гарчгууд бүхий эх хувь байна. Баруун талд гарчиг тус бүрийн ард дөрвөн зураас бичин тэдгээрийг эвхэгддэг болгосон. Тэдгээрийн хоёр нь эвхэгдсэн байгаа бөгөөд та доорх Агуулгын хүснэгтэд хэсэг бүрийг харуулсныг харж болно.

```{r, out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "code_folding1.png"))
knitr::include_graphics(here::here("images", "code_folding2.png"))
```

Автоматаар эвхэх боломжтой кодын бусад хэсэгт функцүүдийн тодорхойлолт зэрэг `{ }` хаалт бүхий "braced" бүсүүд эсвэл нөхцөлт блокууд (if else statements) орно. Та код эвхэх тухай дэлгэрэнгүй мэдээллийг RStudio [сайтаас](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections) уншиж болно.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Ажлын директор

Ажлын директор нь R таны ажилд ашигладаг үндсэн хавтасны байршил бөгөөд R нь энэ хавтас дотор файлуудыг хайж, хадгалдаг. Зориудаар өөрчлөөгүй үед шинэ файлууд болон үр дүнг энэ байршилд шууд хадгалах бөгөөд эндээс импортлох файлуудыг (жишээ нь, датасет) мөн хайх болно.

Ажлын директор нь RStudio Console самбарын дээд талд саарал текстээр харагдана. Та мөн `getwd()` функцыг (хашилтыг хоосон орхи) ажиллуулснаар одоогийн ашиглаж байгаа директорийг харж болно .

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "working_directory_1.png"))
```

### Санал болгож буй арга {.unnumbered}

**Та ажлын директорио хэрхэн ашиглах талаар бидний санал болгож буй аргын дэлгэрэнгүйг \[R төслүүд\] хуудаснаас үзнэ үү.**\
Өөрийн ажлын директор болон файлын замыг удирдах нийтлэг, үр дүнтэй, асуудалгүй арга бол эдгээр 3 элементийг \[R project\]\[R projects\]-д чиглэсэн ажлын урсгалд нэгтгэх явдал юм.

1.  Таны бүх файлыг хадгалах R төсөл (\[R төслүүд\] дээрх хуудсыг үзнэ үү)

2.  Файлуудыг олох **here** багц (\[Импорт, экспорт\] дээрх хуудсыг үзнэ үү)

3.  Файлуудыг импортлох/экспортлох **rio** багц (\[Импорт, экспорт\] дээрх хуудсыг үзнэ үү)

<!-- ======================================================= -->

### Командаар тохируулах {.unnumbered}

Саяхныг хүртэл R сурч буй олон хүмүүст `setwd()` командаар скриптээ эхлүүлэхийг заадаг байсан. Оронд нь \[R project\]\[R projects\]-д чиглэсэн ажлын урсгалыг ашиглах талаар бодож үзээд [`setwd()`-г ашиглахгүй байгаа шалтгааныг](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/) уншина уу. Товчхондоо, таны ажил таны хэрэглэж буй компьютертэй хамааралтай болж, файлуудыг импортлох, экспортлоход ашигладаг файлын замууд "хэврэг" болж, бусад компьютер дээр таны кодыг ашиглах, хамтран ажиллахад ихээхэн саад учруулдаг. Үүнээс зайлсхийх өөр хялбар аргууд байна!

Дээр дурдсанчлан бид ихэнх тохиолдолд ийм аргыг хэрэглэхийг зөвлөдөггүй ч та `setwd()` командыг хүссэн хавтасныхаа файлын замыг ишлэл дотор бичсэнээр ашиглаж болно, жишээлбэл:

```{r, eval=F}
setwd("C:/Documents/R Files/My analysis")
```

[***АЮУЛ:*** Хэрэв файлын зам нь нэг компьютерт зориулагдсан бол `setwd()`-аар ажлын директор тохируулах нь "хэврэг" *байж болно*. Үүний оронд R Project-ийн үндсэн директортой харьцангуй холбоотой файлын замуудыг ашиглана уу (**here** багцтай).]{style="color: red;"}

<!-- ======================================================= -->

### Гараар тохируулах {.unnumbered}

Ажлын директорийг гараар тохируулахын тулд (`setwd()`-ийн товч дарахтай дүйцэхүйц) Session унадаг цэсийг товшиж "Set Working Directory", дараа нь "Choose Directory" руу очно уу. Энэ нь тухайн R сессийн ажлын директорийг тохируулах болно. Тэмдэглэл: Хэрэв энэ аргыг хэрэглэж байгаа бол RStudio-г нээх болгондоо үүнийг гараар хийх шаардлагатай болно.

<!-- ======================================================= -->

### R төслийн дотор {.unnumbered}

Хэрэв R төслийг ашиглаж байгаа бол ажлын директор нь ".rproj" файлыг агуулсан R төслийн үндсэн хавтсыг ашиглах болно. Та R Project (".rproj" өргөтгөлтэй файл) дээр дарж RStudio-г нээвэл энэ нь хэрэгжинэ.

<!-- ======================================================= -->

### R markdown-ы ажлын директор {.unnumbered}

R markdown скриптийн үндсэн ажлын директор нь Rmarkdown файлын (.Rmd) хадгалагдаж буй хавтас юм. Хэрэв R төсөл болон **here** багцыг ашиглаж байгаа бол энэ нь хамаарахгүй бөгөөд \[R төслүүд\] хуудсанд тайлбарласны дагуу ажлын директор `here()` байх болно.

Хэрэв та бие даасан (R төсөл дотор биш) R markdown-ы ажлын директорийг `setwd()` ашиглан өөрчлөх гэж байвал энэ нь зөвхөн тухайн кодын хэсэгт хамаарна. R markdown дах бүх кодын хэсгүүдэд өөрчлөлт оруулахын тулд тохиргооны хэсгийг засварлаж `root.dir =` параметрийг доорх жишээ шиг нэмж оруулаарай:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/directorypath')
```

R markdown-ыг R төслийн дотор **here** багцтай хамт ашиглах нь хамаагүй хялбар юм.

<!-- ======================================================= -->

### Файлын замууд бичих {.unnumbered}

R эхлэн суралцагчдын бухимдлын хамгийн түгээмэл эх үүсвэр (наад зах нь Windows машин дээр) бол магадгүй дата импортлох, экспортлох файлын замыг бичих явдал юм. \[Импорт, экспорт\] хуудсанд файлын замыг хэрхэн хамгийн сайн оруулах талаар дэлгэрэнгүй тайлбар байгаа боловч энд цөөн хэдэн гол санааг дурдав:

**Эвдэрсэн замууд**

Доорх нь "үнэмлэхүй" эсвэл "бүтэн хаяг" файлын замын жишээ юм. Хэрэв өөр компьютер ашиглавал эдгээр нь эвдрэх магадлалтай. Хэрэв та дундын/сүлжээний драйв ашиглаж байгаа бол үүнд хамаарахгүй.

    C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  

**Налуу зураасны чиглэл**

*Хэрэв ташуу зураас файлын замд бичиж байгаа бол түүний чиглэлийг анхаараарай.* Бүрэлдэхүүн хэсгүүдийг ("data/provincial.csv") салгахын тулд *урагшаа налуу зураасыг* (`/`) ашиглана уу. Windows хэрэглэгчдийн хувьд файлын замыг *арагшаа налуу зураасаар* (\\) харуулдаг тул та налуу зураас бүрийн чиглэлийг өөрчлөх шаардлагатай болно. Хэрэв та \[R төслүүд\] хуудсанд тайлбарласны дагуу **here** багцыг ашиглавал налуу зураасны чиглэл асуудал болохгүй.

**Харьцангуй файлын замууд**

Бид ерөнхийдөө "харьцангуй" файлын замууд ашиглахыг зөвлөж байна, өөрөөр хэлбэл таны R төслийн үндсэн хавтастай *харьцангуй* холбоотой зам. Та үүнийг \[R төслүүд\] хуудсанд тайлбарласны дагуу **here** багцыг ашиглан хийж болно. Харьцангуй файлын зам дараах байдлаар харагдаж болно:

```{r, eval=F}
# R төслийн data/linelist/clean/ дэд хавтаснаас csv лайнлист импортлох
linelist <- import(here("data", "clean", "linelists", "marin_country.csv"))
```

R төсөл дотор харьцангуй файлын замыг ашиглаж байсан ч та R төслөөс гадуур байгаа датаг үнэмлэхүй зам ашиглан импортолж/экспортолж болно.

<!-- ======================================================= -->

## Объектууд {#objects}

R-д байгаа бүх зүйл нь объект бөгөөд R нь "объект-чиглэлтэй" (object-oriented) хэл юм. Доорх хэсгүүд дараах зүйлсийг тайлбарлах болно:

-   Хэрхэн объект үүсгэх вэ (`<-`)

-   Объектуудын төрлүүд (жишээ нь, датафрэймүүд, векторууд..)

-   Объектуудын дэд хэсгүүдэд (жишээ нь, датасетийн хувьсагчид) хэрхэн хандах вэ

-   Объектуудын ангилал (жишээлбэл, тоон, логик, бүхэл тоо, давхар тоо, тэмдэгт, фактор)

<!-- ======================================================= -->

### Бүх зүйл объект {.unnumbered}

*Энэ хэсгийг [R4Epis төслөөс](https://r4epis.netlify.app/training/r_basics/objects/) ашигласан.*

R-д хадгалагдаж буй бүх зүйл - датасет, хувьсагч, тосгоны нэрсийн жагсаалт, нийт хүн амын тоо, тэр ч байтугай график гэх мэт гаралтууд нь **нэр оноогдсон** **объектууд** бөгөөд эдгээрийг дараагийн командуудад **ашиглаж болдог**.

Тухайн объектод утга оноох үед объект бий болдог (доорх оноолтын хэсгийг үзнэ үү). Түүнд утга оноох үед тухайн объект Environment хэсэгт гарч ирнэ (RStudio-ийн баруун дээд хэсгийг харна уу). Ингэснээр түүнийг ажиллуулж, удирдаж, өөрчилж, дахин тодорхойлж болно.

<!-- ======================================================= -->

### Объектуудыг тодорхойлох (`<-`) {.unnumbered}

**Объектуудад \<- операторын тусламжтайгаар тодорхой утгыг оноож үүсгэнэ.**

Та оноох оператор `<-` -ыг "гэж тодорхойлсон" гэсэн үг гэж бодож болно. Оноолтын командууд нь ерөнхийдөө дараах стандарт дараалалтай байдаг:

**объектын_нэр \<- утга** (эсвэл тодорхой утга үүсгэдэг процесс/тооцоолол)

Жишээлбэл, та одоогийн эпидемиологийн тайлангийн долоо хоногийг дараагийн кодын лавлагааны объект болгон тэмдэглэхийг хүсч байж болох юм. Энэ жишээнд `"2018-W10"` гэсэн утгыг оноох үед `current_week` объект үүсч байна (ишлэл нь үүнийг тэмдэгтийн утга болгодог). Ингэснээр `current_week` объект RStudio Environment хэсэгт (баруун дээд талд) гарч ирэх ба дараагийн командуудад ашиглаж болно.

R командууд болон тэдгээрийн гаралтыг доор харна уу.

```{r basics_objects_assignment}
current_week <- "2018-W10"   # Энэ команд нь утга оноосноор current_week объект үүсгэнэ
current_week                 # Энэ команд нь консол дахь current_week объектын одоогийн утгыг хэвлэнэ 
```

[***ТЭМДЭГЛЭЛ:*** R консолын гаралт дахь \[1\] нь ердөө л таныг гаралтын эхний зүйлийг харж байгааг илэрхийлж байгаа болно.]{style="color: black;"}

[***АНХААРУУЛГА:*** Объектын утгыг дахин тодорхойлох оноолтын командыг ажиллуулснаар ямар ч үед тухайн **объектын өмнөх утгыг дарж шинэ утга оноож болно**. Тиймээс **командуудыг гүйцэтгэх дараалал нь маш чухал** юм.]{style="color: orange;"}

Дараах команд нь `current_week` утгыг дахин тодорхойлох болно:

```{r basics_objects_reassignment}
current_week <- "2018-W51"   # current_week объектод ШИНЭ утгыг онооно 
current_week                 # current_week утгыг консол дээр хэвлэнэ
```

**Тэнцүүгийн тэмдэг `=`**

Та R код дотор тэнцүүгийн тэмдэгтэй олон таарах болно:

-   Хоёр объект эсвэл утгын хоорондох давхар тэнцүүгийн тэмдэг `==` "энэ нь үүнтэй тэнцүү юу?" гэсэн логик *асуултыг* тавьдаг.

-   Та мөн функц дотор функцийн аргументуудын утгыг тодорхойлоход ашигладаг тэнцүүгийн тэмдгийг харах болно (үүний талаар дараагийн хэсгүүдээс уншина уу), жишээ нь `max(age, na.rm = TRUE)`.

-   Мөн та объект үүсгэж, тодорхойлохын тулд `<-`ын оронд `=` нэг тэнцүү тэмдгийг ашиглаж болох боловч энэ үйлдлийг хийхийг бид зөвлөдөггүй. Үүнийг яагаад зөвлөдөггүй талаар [эндээс](https://renkun.me/2014/01/28/difference-between-assignment-operators-in-r/) уншиж болно.

**Датасетүүд**

Датасет нь мөн объект (ихэвчлэн "датафрэйм") бөгөөд тэдгээрийг импортлохдоо нэр өгөх ёстой. Доорх кодонд **rio** багцын `import()` функц ашиглан импортолсон CSV файлын утгыг `linelist` гэсэн объект руу оноож шинээр үүсгэж байна.

```{r basics_objects_dataframes, eval=FALSE}
# linelist-ийг үүсгэж, импортолсон CSV файлын утгыг оноож өгч байна
linelist <- import("my_linelist.csv")
```

Та \[Импорт, экспорт\] хэсгээс датасет импортлох, экспортлох талаар дэлгэрэнгүй унших боломжтой.

[***АНХААРУУЛГА:*** Объектуудыг нэрлэх тухай товч тэмдэглэл:]{style="color: orange;"}

-   Объектын нэрэнд хоосон зай байх ёсгүй, гэхдээ зайны оронд доогуур зураас (\_) эсвэл цэг (.) ашиглаж болно.

-   Объектын нэр нь үсгийн том жижгээр ялгагддаг (Dataset_A нь dataset_A-аас өөр гэсэн үг).

-   Объектын нэр үсгээр эхлэх ёстой (1, 2, 3 гэх мэт тоогоор эхэлж болохгүй).

**Гаралтууд**

Хүснэгт, график гэх мэт гаралтууд нь гаралтыг хэрхэн объект болгон хадгалах, эсвэл хадгалахгүйгээр хэвлэх боломжтой жишээг харуулдаг. **base** R функц болох `table()` ашиглан хүйс, үр дүнгийн хүснэгтийг R консол дээр шууд хэвлэх боломжтой (*хадгалахгүйгээр*).

```{r}
# зөвхөн R консол дээр хэвлэнэ
table(linelist$gender, linelist$outcome)
```

Гэхдээ яг ижил хүснэгтийг нэрлэсэн объект болгон хадгалах боломжтой. Дараа нь хүсвэл үүнийг хэвлэж болно.

```{r}
# хадгал
gen_out_table <- table(linelist$gender, linelist$outcome)

# хэвлэ
gen_out_table
```

**Баганууд**

Датасетийн баганууд нь мөн объектууд бөгөөд "Баганууд" хэсэгт доор тайлбарласны дагуу тодорхойлж, дахин бичиж, шинээр үүсгэж болно.

Та шинэ багана үүсгэхийн тулд **base** R-ын оноолтын операторыг ашиглаж болно. Доорх кодонд мөр бүрийн хувьд `wt_kg` болон `ht_cm` багана дахь мөрийн утгуудыг ашиглан математик үйлдлийн үр дүнд шинэ утга гарган түүнийг шинэ багана `bmi` (Биеийн жингийн индекс) дотор хадгалж байна.

```{r, eval=F}
# base R синтакс ашиглан шинэ "bmi" багана үүсгэнэ
linelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2
```

Хэдий ингэж болох боловч энэхүү гарын авлагад бид багануудыг тодорхойлох өөр арга болох **dplyr** багцын `mutate()` функц болон пайп оператораар (`%>%`) дамжуулан пайплахыг санал болгож байна. Ингэснээр синтаксийг уншихад хялбар бөгөөд \[Дата цэвэрлэх болон үндсэн функцууд\] хуудсанд тайлбарласан бусад давуу талууд байдаг. Та *пайпын* талаар дэлгэрэнгүй мэдээллийг дараах "Пайплах" хэсгээс уншиж болно.

```{r, eval=F}
# dplyr синтакс ашиглан шинэ "bmi" багана үүсгэнэ
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

<!-- ======================================================= -->

### Объектын бүтэц {.unnumbered}

**Объектууд нь зөвхөн нэг ширхэг дата байж болно (жишээ нь, `my_number <- 24`) эсвэл тодорхой бүтэцтэй датанаас бүрдэж болно.**

Доорх графикийг [энэхүү онлайн R хичээлээс](http://venus.ifca.unican.es/Rintro/dataStruct.html) авсан болно. Энэ нь зарим нийтлэг дата бүтэц, тэдгээрийн нэрийг харуулж байна. Энэ зурагт орон зайн мэдээлэл ороогүй бөгөөд үүнийг \[GIS-ын суурь\] хуудсанд авч үзсэн болно.

```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```

Эпидемиологт (ялангуяа талбарын эпидемиологт) та датафрэймүүд ба векторуудтай хамгийн их тулгарах болно:

| Нийтлэг бүтэц | Тайлбар                                                                                      | Жишээ                                                                                       |
|---------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|
| Векторууд     | Бүгд ижил ангиллын ганц бие объектуудын дараалалд зориулсан агуулах (жишээ нь тоо, тэмдэгт). | **Датафрэймүүдийн "Хувьсагчид" (баганууд) нь векторууд юм** (жишээ нь: `age_years` багана). |
| Датафрэймүүд  | Бүгд ижил тооны мөртэй, хоорондоо холбогдсон векторууд (жишээ нь багана).                    | `linelist` бол датафрэйм                                                                    |

Датафрэймийн нэг хэсэг биш "дан" вектор үүсгэхийн тулд `c()` функцийг өөр өөр элементүүдийг нэгтгэхэд ашигладаг болохыг анхаарна уу. Жишээлбэл, графикийн өнгөний хуваарь болгон ашиглах өнгөний вектор үүсгэх тохиолдолд : `vector_of_colors <- c("blue", "red2", "orange", "grey")`

<!-- ======================================================= -->

### Объектын ангиуд {.unnumbered}

R-д хадгалагдсан бүх объектууд R-д тухайн объектыг хэрхэн зохицуулахыг хэлдэг ангитай байдаг. Олон боломжит ангиуд байдаг боловч нийтлэг байдаг нь:

| Анги                | Тайлбар                                                                                                                                                                      | Жишээ                                                                                               |
|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| Тэмдэгт (character) | Эдгээр нь **"ишлэлийн доторх"** текст/үг/өгүүлбэр юм. Эдгээр объектууд дээр математик үйлдэл хийх боломжгүй.                                                                 | "Тэмдэгтийн объектууд ишлэл дотор байна"                                                            |
| Бүхэл тоо           | Зөвхөн **бүхэл тоо** (аравтын бутархай байхгүй)                                                                                                                              | -5, 14, эсвэл 2000                                                                                  |
| Тоо                 | Эдгээр нь тоо бөгөөд **аравтын бутархайг агуулж болно**. Хэрэв ишлэл дотор байвал тэдгээрийг тэмдэгтийн ангилалд тооцно.                                                     | 23.1 эсвэл 14                                                                                       |
| Фактор              | Эдгээр нь **тодорхой дараалал** эсвэл утгуудын шатлалтай векторууд юм.                                                                                                       | Орлогын түвшний дараалалт утга бүхий хувьсагч                                                       |
| Огноо               | **R-д тодорхой дата нь огноо гэж мэдэгдсэний дараа** эдгээр датаг тусгай аргаар удирдаж, харуулах боломжтой. Дэлгэрэнгүй мэдээллийг \[Огноотой ажиллах\] хуудаснаас үзнэ үү. | 2018-04-12 эсвэл 15/3/1954 эсвэл Wed 4 Jan 1980                                                     |
| Логик               | Утга нь TRUE эсвэл FALSE гэсэн хоёр тусгай утгын нэг байх ёстой (эдгээр нь ишлэл доторх "TRUE" ба "FALSE" биш гэдгийг анхаарна уу)                                           | TRUE эсвэл FALSE                                                                                    |
| data.frame          | Датафрэйм нь R **ердийн датасетийг** хадгалдаг арга юм. Энэ нь бүгд ижил тооны ажиглалттай (мөр) хоорондоо холбогдсон дата векторуудаас (баганууд) бүрдэнэ.                  | `linelist_raw` нэртэй AJS жишээ датасет нь тус бүр 300 ажиглалт (мөр) бүхий 68 хувьсагчийг агуулна. |
| tibble              | tibble нь датафрэймийн хувилбар бөгөөд үйл ажиллагааны гол ялгаа нь консол дээр илүү сайн хэвлэдэг (эхний 10 мөр, зөвхөн дэлгэцэн дээр багтах багануудыг харуулна)           | Ямар ч датафрэйм, лист эсвэл матрицыг `as_tibble()` ашиглан tibble болгон хувиргаж болно.           |
| лист                | Лист нь вектор шиг боловч өөр өөр ангийн объектуудыг агуулж чаддагаараа ялгаатай.                                                                                            | Листэд нэг тоо, датафрэйм, вектор, тэр ч байтугай дотор нь өөр лист ч байж болно!                   |

**Та `class()` функцад нэрийг нь оруулснаар тухайн объектын ангийг шалгаж болно.** Тэмдэглэл: Та `$` тэмдэглэгээг ашиглан датасетийн нэр болон баганын нэрийг тусгаарласнаар тухайн датасет доторх тодорхой баганыг ашиглаж болно.

```{r, echo=TRUE,}
class(linelist)         # анги нь датафрэйм эсвэл tibble байх ёстой

class(linelist$age)     # анги тоон байх ёстой

class(linelist$gender)  # анги тэмдэгт байх ёстой
```

Заримдаа R баганыг автоматаар өөр анги руу хөрвүүлдэг. Үүнээс болгоомжил! Жишээлбэл, хэрэв танд тоонуудын вектор эсвэл багана байгаа боловч тэмдэгтийн утга оруулсан бол... багана бүхэлдээ тэмдэгт ангитай болж өөрчлөгдөнө.

```{r}
num_vector <- c(1,2,3,4,5) # векторыг дан тоогоор тодорхойлно
class(num_vector)          # вектор нь тоон анги
num_vector[3] <- "three"   # гурав дахь элементийг тэмдэгт болгон хувиргана
class(num_vector)          # вектор нь одоо тэмдэгтийн анги болжээ
```

Үүний нэг нийтлэг жишээ бол хүснэгтийг хэвлэхийн тулд датафрэймтэй ажиллах үед - хэрэв та нийт гэсэн мөр гаргаж, тоонуудтай нэг нүдэнд хувийг буулгах/наах (жишээ нь `23 (40%)`) гэж оролдвол дээрх тоон багана нь тэмдэгт болж хувирах бөгөөд цаашид математик тооцоололд ашиглагдах боломжгүй болно. **Тиймээс заримдаа та объект эсвэл баганыг өөр анги руу хөрвүүлэх шаардлагатай болдог.**

| Функц            | Үйлдэл                                                                                                        |
|------------------|---------------------------------------------------------------------------------------------------------------|
| `as.character()` | Тэмдэгт анги руу хөрвүүлдэг                                                                                   |
| `as.numeric()`   | Тоон анги руу хөрвүүлдэг                                                                                      |
| `as.integer()`   | Бүхэл тоон анги руу хөрвүүлдэг                                                                                |
| `as.Date()`      | Огноо анги руу хөрвүүлдэг - Тэмдэглэл: дэлгэрэнгүй мэдээллийг [огнооны](#dates) хэсгээс үзнэ үү               |
| `factor()`       | Фактор анги руу хөрвүүлдэг - Тэмдэглэл: утгын түвшний дарааллыг дахин тодорхойлох нь нэмэлт аргумент шаарддаг |

Үүний нэгэн адил `is.numeric()`, `is.character()`, `is.double()`, `is.factor()`, `is.integer()` зэрэг тодорхой ангиллын объект МӨН эсэхийг шалгах **base** R функцууд байдаг.

[R хэл дээрх анги, датаны бүтцийн талаархи онлайн материалыг](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/) эндээс үзнэ үү.

<!-- ======================================================= -->

### Баганууд/Хувьсагчид (`$`) {.unnumbered}

**Датафрэйм дэх багана нь техникийн хувьд "вектор" (дээрх хүснэгтийг харна уу)** - бүгд ижил ангитай (тэмдэгт, тоон, логик гэх мэт) байх ёстой утгуудын цуврал юм.

Вектор нь датафрэймээс хамааралгүй оршиж болно, жишээ нь моделд тайлбарлах хувьсагч болгон оруулахыг хүссэн баганын нэрнүүдийн вектор. "Бие даасан" вектор үүсгэхийн тулд дараах байдлаар `c()` функцийг ашиглана уу:

```{r, warning=F, message=F}
# тэмдэгтийн утгууд бүхий бие даасан векторыг тодорхойлно
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")

# энэ нэрлэсэн вектор дахь утгуудыг хэвлэх
explanatory_vars
```

**Датафрэймийн баганууд нь мөн векторууд бөгөөд `$` тэмдэг ашиглан дуудаж, лавлаж, задалж эсвэл шинээр үүсгэж болно.** `$` тэмдэг нь баганын нэрийг датафрэймийн нэртэй холбодог. Энэхүү гарын авлагад бид "хувьсагч" гэхийн оронд "багана" гэсэн үгийг ашиглахыг хичээсэн.

```{r basics_objects_call, eval=F}
# age_years векторын уртыг ол 
length(linelist$age) # (age нь linelist датафрэймийн нэг багана юм)

```

Датафреймийн нэрийн дараа `$` тэмдэг оруулснаар та тухайн датафрэйм дэх бүх баганын унадаг цэсийг харах болно. Та сумны товчийг ашиглан тэдгээрийг гүйлгэж, Enter товчлуураар нэгийг нь сонгосноор зөв бичгийн алдаа гаргахаас зайлсхийх боломжтой!

```{r echo=F, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```

[***АХИСАН ТҮВШНИЙ ЗӨВЛӨМЖ:*** Зарим илүү комплекс объектууд (жишээ нь лист, эсвэл `epicontacts` объект) олон доллар тэмдэгтээр хандах боломжтой олон түвшинтэй байж болно. Жишээлбэл, `epicontacts$linelist$date_onset`]{style="color: darkgreen;"}

<!-- ======================================================= -->

### Хаалт ашиглан хандах/индекслэх (`[ ]`) {.unnumbered}

Та объектын хэсгүүдийг харах, өөрөөр "индекслэх" гэж нэрлэгддэг, шаардлагатай байж болох бөгөөд үүнийг ихэвчлэн дөрвөлжин хаалт `[ ]` ашиглан хийдэг. Баганад хандахын тулд датафрэйм дээр `$`-г ашиглах нь мөн индекслэлтийн нэг төрөл юм.

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # векторыг тодорхойлно
my_vector[5]                                  # 5-р элементийг хэвлэх
```

Дөрвөлжин хаалт нь `summary()` функцийн гаралт гэх мэт гарч ирсэн гаралтын тодорхой хэсгийг харуулахад ашиглагддаг:

```{r}
# Бүх хураангуй
summary(linelist$age)

# Нэр бүхий, хураангуйн хоёр дахь элемент (зөвхөн ганц хаалт ашиглан) 
summary(linelist$age)[2]

# Нэргүй, хураангуйн хоёр дахь элемент (давхар хаалт ашиглан)
summary(linelist$age)[[2]]

# Нэрийг харуулахгүйгээр элементийг нэрээр нь задлах
summary(linelist$age)[["Median"]]

```

Хаалт нь тодорхой мөр, баганыг харахын тулд датафрэйм дээр ажилладаг. Та үүнийг `датафрэйм[мөр, багана]` синтакс ашиглан хийж болно:

```{r basics_objects_access, eval=F}
# Датасетийн тодорхой мөрийг (2) бүх баганын хамт харах (таслалыг бүү март!) 
linelist[2,]

# Бүх мөрүүдийг харах, гэхдээ зөвхөн нэг баганатай
linelist[, "date_onset"]

# 2-р мөр болон 5-аас 10-р багана хүртэлх утгыг харах 
linelist[2, 5:10] 

# 2-р мөр болон 5-аас 10, 18-р багануудын утгыг харах
linelist[2, c(5:10, 18)] 

# 2-оос 20 хүртэлх мөр, тодорхой багануудыг харах
linelist[2:20, c("date_onset", "outcome", "age")]

# Тодорхой шалгуурт үндэслэн мөр, баганыг харах 
# *** Датафрэймийг шалгуурт нэрлэсэн хэвээр байх ёстойг анхаарна уу! 
linelist[linelist$age > 25 , c("date_onset", "outcome", "age")]

# RStudio Viewer самбар дээрх гаралтыг харахын тулд View()-г ашиглана уу (уншихад хялбар) 
# *** View() функцийн том "V" үсгийг анхаарна уу 
View(linelist[2:20, "date_onset"])

# Шинэ объект болгон хадгалах
new_table <- linelist[2:20, c("date_onset")] 
```

Та мөн **dplyr** синтакс (мөрүүдэд `filter()` функц, багананд `select()` функцийг) ашиглан датафрэйм болон тибл дээр дээрхтэй ижлээр мөр/баганыг индексжүүлэх боломжтойг анхаарна уу. Эдгээр үндсэн функцуудын талаар \[Дата цэвэрлэх ба үндсэн функцууд\] хуудаснаас дэлгэрэнгүй уншина уу.

"Мөрийн дугаар" дээр үндэслэн шүүх бол та **dplyr**-ын`row_number()` функцийг хоосон хаалттайгаар логик шүүлтийн хэсэг болгон ашиглаж болно. Доор үзүүлсэн шиг ихэнх тохиолдолд та `%in%` оператор болон тооны хүрээг логик хэллэгийн нэг хэсэг болгож болдог. *Эхний* N мөрийг харахын тулд та тусгай **dplyr** функц `head()` ашиглах боломжтой.

```{r, eval=F}
# Эхний 100 мөрийг харах
linelist %>% head(100)

# Зөвхөн 5-р мөрийг харуулах
linelist %>% filter(row_number() == 5)

# 2-оос 20 хүртэлх мөр, гурван тодорхой баганыг харах (баганын нэр дээр ишлэл хэрэггүй гэдгийг анхаарна уу) 
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

**Лист** ангийн объектыг индекслэх үед зөвхөн ганц объектыг буцаасан ч гэсэн ганц дөрвөлжин хаалт нь лист ангийг буцаана. Харин давхар хаалт нь нэг элементэд хандаж, листээс өөр анги буцаахад ашиглагдаж болно.

Доор үзүүлсэн шиг хаалтуудыг ар араас нь бичиж болно.

[Чинжүү сэгсрэгч ашиглан лист индекслэлтийн талаар тайлбарласан энэхүү дүрсэт тайлбар](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) хошин бөгөөд ойлгоход тустай.

```{r}
# Демо лист тодорхойлох
my_list <- list(
  # Листийн эхний элемент нь тэмдэгтийн вектор
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # Листийн хоёр дахь элемент нь хаягуудын датафрэйм
  addresses   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )
```

Листийг консол дээр хэвлэх үед хэрхэн харагдахыг энд харуулав. Нэрлэгдсэн хоёр элемент байгааг хараарай:

-   `hospitals`, тэмдэгтийн вектор

-   `addresses`, хаягуудын датафрэйм

```{r}
my_list
```

Одоо бид янз бүрийн аргыг ашиглан задалж байна:

```{r}
my_list[1] # энэ нь "лист" анги дахь элементийг буцаана - элементийн нэр харагдсан хэвээр байна 

my_list[[1]] # энэ нь зөвхөн (нэргүй) тэмдэгтийн векторыг буцаана 

my_list[["hospitals"]] # Та мөн листийн элементийн нэрээр индекслэж болно

my_list[[1]][3] # энэ нь "hospitals" тэмдэгтийн векторын гурав дахь элементийг буцаана 

my_list[[2]][1] # Энэ нь хаягийн датафрэймийн эхний баганыг ("street") буцаана

```

<!-- ======================================================= -->

### Объектуудыг устгах {.unnumbered}

Та `rm()` функцэд нэрийг оруулснаар R орчноосоо бие даасан объектуудыг устгаж болно (ишлэлгүй):

```{r, eval=F}
rm(object_name)
```

Та бүх объектыг дараах байдлаар устгаж болно (ажлын талбайгаа цэвэрлэх):

```{r, eval=F}
rm(list = ls(all = TRUE))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Пайплах (`%>%`)

**Объектуудтай ажиллах хоёр ерөнхий арга нь:**

1.  **Pipes/tidyverse** - пайп нь функцээс функц рүү объектыг илгээдэг - объект биш харин үйлдлийг онцолдог.

2.  **Завсрын объектуудыг тодорхойлох** - объект дахин дахин тодорхойлогддог - объект дээр анхаарлаа хандуулдаг

<!-- ======================================================= -->

### **Пайп** {.unnumbered}

**Энгийнээр тайлбарлавал пайп оператор (`%>%`) нь завсрын гаралтыг нэг функцээс нөгөө функц рүү дамжуулдаг.**

Та үүнийг "дараа нь" гэж хэлж байна гэж бодож болно. Олон функцийг `%>%` ашиглан холбож болно.

-   **Пайплах нь үйлдлүүдийг гүйцэтгэж буй объектыг бус харин дараалсан үйлдлүүдийг онцолдог**

-   Нэг объект дээр дараалсан үйлдлүүдийг хийх шаардлагатай үед пайп нь хамгийн тохиромжтой

-   Пайп нь **magrittr** багцаас ашиглагддаг бөгөөд **dplyr** болон **tidyverse** багцад автоматаар ордог

-   Пайп нь кодыг илүү цэвэрхэн, уншихад хялбар, ойлгомжтой болгох боломжтой

Tidyverse [загварын гарын авлагаас](https://style.tidyverse.org/pipes.html) энэ аргын талаар дэлгэрэнгүй уншина уу.

"Бялуу жигнэх" зохиомол функцийг ашиглан харьцуулах хуурамч жишээ энд байна. Эхлээд, пайп арга:

```{r piping_example_pipe, eval=F}
# Пайп синтакс ашиглан бялууг хэрхэн жигнэх тухай хуурамч жишээ 

cake <- flour %>%       # бялууг тодорхойлохдоо гурилаар эхэлж, дараа нь...
  add(eggs) %>%   # өндөг нэмнэ
  add(oil) %>%    # тос нэмнэ
  add(water) %>%  # ус нэмнэ
  mix_together(         # хооронд нь холино
    utensil = spoon,
    minutes = 2) %>%    
  bake(degrees = 350,   # жигнэнэ
       system = "fahrenheit",
       minutes = 35) %>%  
  let_cool()            # хөргөнө
```

Пайп ашиглалтыг тайлбарласан өөр нэг [холбоос](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations) энд байна.

Пайп нь **base** функц биш юм. Пайп ашиглахын тулд **magrittr** багцыг суулгаж, ачаалах ёстой (энэ нь ихэвчлэн үүнийг багтаасан **tidyverse** эсвэл **dplyr** багцыг ачаалах замаар хийгддэг). Та [**magrittr** багцын баримт бичигт пайпын талаар илүү ихийг уншиж](https://magrittr.tidyverse.org/) болно.

Бусад R командуудын нэгэн адил пайп нь `<-` оноох оператор оролцож байгаа эсэхээс хамаарч зөвхөн үр дүнг харуулах, объектыг хадгалах/дахин хадгалахад ашиглагдаж болно гэдгийг анхаарна уу. Доор хоёуланг нь харна уу:

```{r, eval=F}
# Насны ангиллаар нийлбэр тоо болгон тодорхойлох объект үүсгэх буюу дарж бичих (хэвлэсэнгүй) 
linelist_summary <- linelist %>% 
  count(age_cat)
```

```{r}
# Тооллогын хүснэгтийг консол дээр хэвлээрэй, гэхдээ үүнийг бүү хадгал
linelist %>% 
  count(age_cat)
```

**`%<>%`**\
Энэ бол **magrittr** багцын "оноолтын пайп" бөгөөд энэ нь *объектыг урагш нь зөөж, мөн объектыг дахин тодорхойлдог*. Энэ нь гинжин хэлхээний анхны пайп оператор байх ёстой. Энэ нь доор буй хоорондоо ижил утгатай хоёр жишээн дээр үзүүлсэн шиг товчлол юм:

```{r, eval=F}
linelist <- linelist %>%
  filter(age > 50)

linelist %<>% filter(age > 50)
```

<!-- ======================================================= -->

### Завсрын объектуудыг тодорхойлох {.unnumbered}

Объект/датафрэйм өөрчлөх энэ арга нь дараах тохиолдолд илүү дээр байж болох юм:

-   Та олон объектыг өөрчлөх хэрэгтэй

-   Завсрын шатууд нь утга учиртай бөгөөд тусдаа объектын нэрийг авах ёстой

**Эрсдэл:**

-   Алхам бүрт шинэ объект бий болгоно гэдэг нь маш олон объект бий болгоно гэсэн үг. Хэрэв та буруу объект ашиглавал түүнийгээ мэдэхгүй байж магадгүй юм!

-   Бүх объектыг нэрлэх нь төөрөгдөл үүсгэдэг

-   Алдаа илрүүлэхэд амаргүй байж магадгүй

Нэг бол завсрын объект бүрийг нэрлэх эсвэл эх хувийг дарж бичих эсвэл бүх функцийг нэгтгэх. Бүгд өөрийн гэсэн эрсдэлтэй байдаг.

Доорх код нь дээрхтэй адил хуурамч "бялуу" жишээ юм, гэхдээ энэ загварыг ашиглаж байна:

```{r piping_example_redefine, eval=F}
# Энэ аргыг ашиглан бялууг хэрхэн жигнэх тухай хуурамч жишээ (завсрын объектыг тодорхойлох) 
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Бүх функцийг нэгтгэх - үүнийг уншихад хэцүү:

```{r eval=F}
# олон функцийг хослуулах/нэгтгэх жишээ - уншихад хэцүү 
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```

<!-- ======================================================= -->

## Гол операторууд болон функцууд {#operators}

Энэ хэсэгт R хэлний гол операторуудыг дэлгэрэнгүй тайлбарлаж байна, тухайлбал:

-   Тодорхойлогч операторууд

-   Харьцааны операторууд (бага, тэнцүү..)

-   Логик операторууд (ба, эсвэл ...)

-   Хоосон утгатай ажиллах

-   Математикийн операторууд болон функцууд (+/-, >, `sum()`, `median()`, ...)

-   `%in%` оператор

<!-- ======================================================= -->

### Оноолтын операторууд {.unnumbered}

**`<-`**

R хэлний үндсэн оноолтын оператор нь `<-`. `объектын_нэр <- утга` гэж ашиглагддаг. Энэхүү оноолтын операторыг мөн `=` ашиглан бичиж болно. Бид ерөнхий R хэрэглээнд `<-`-г ашиглахыг зөвлөж байна. Мөн уншихад хялбар байх үүднээс ийм операторуудыг зайгаар хүрээлэхийг зөвлөж байна.

**`<<-`**

Хэрэв \[Функц бичих\] эсвэл R-г үүсвэртэй скриптүүдтэй интерактив байдлаар ашиглаж байгаа бол та оноолтын оператор `<<-` (**base** R-аас) ашиглах шаардлагатай болж магадгүй юм. Энэ операторыг дээд түвшний "толгой" R орчин дахь объектыг тодорхойлоход ашигладаг. Үүний талаар энэхүү [онлайн лавлагааг](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html) үзнэ үү.

**`%<>%`**

Энэ бол **magrittr** багцын "оноолтын пайп" бөгөөд энэ нь *объектыг урагш нь зөөж, мөн объектыг дахин тодорхойлдог*. Энэ нь гинжин хэлхээний анхны пайп оператор байх ёстой бөгөөд товчлолын нэг хэлбэр юм. Доорх хоёр команд нь яг ижил үйлдэл хийж байна:

Энэ бол **magrittr** багцын "оноолтын пайп" бөгөөд энэ нь объектыг урагш зөөж, мөн объектыг дахин тодорхойлдог. Энэ нь гинжин хэлхээний анхны хоолойн оператор байх ёстой. Энэ нь доор буй хоорондоо ижил утгатай хоёр жишээн дээр үзүүлсэн шиг товчлол юм:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age_months = age_years * 12)
```

Дээрх код нь доорх кодтой яг ижил үйлдэл хийж байна.

```{r, eval=F}
linelist %<>% mutate(age_months = age_years * 12)
```

**`%<+%`**

Энэ нь **ggtree** багц ашиглан филогенетик модонд дата нэмэхэд хэрэглэгддэг. \[Филогенетик мод\] дээрх хуудас эсвэл энэ [онлайн номыг](https://yulab-smu.top/treedata-book/) үзнэ үү.

<!-- ======================================================= -->

### Харьцааны болон логик операторууд {.unnumbered}

Харьцааны операторууд утгыг хооронд нь харьцуулах, шинэ хувьсагч болон датасетийн доторх хэсгийг тодорхойлоход ихэвчлэн ашиглагддаг. R хэл дээрх нийтлэг харьцааны операторууд энд байна:

| Илэрхийлэл            | Оператор   | Жишээ        | Жишээний үр дүн                                                                                                                                                     |
|-----------------------|------------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Тэнцүү                | `==`       | `"A" == "a"` | `FALSE` (Учир нь R нь үсгийн том, жижигт мэдрэг) == (*давхар тэнцүү*) нь *`<-`* оноолтын оператор шиг ажилладаг = (*ганц тэнцүү*)-ээс ялгаатай гэдгийг анхаарна уу. |
| Тэнцүү биш            | `!=`       | `2 != 0`     | `TRUE`                                                                                                                                                              |
| -аас их               | `>`        | `4 > 2`      | `TRUE`                                                                                                                                                              |
| -аас бага             | `<`        | `4 < 2`      | `FALSE`                                                                                                                                                             |
| -аас их буюу тэнцүү   | `>=`       | `6 >= 4`     | `TRUE`                                                                                                                                                              |
| -аас бага буюу тэнцүү | `<=`       | `6 <= 4`     | `FALSE`                                                                                                                                                             |
| Утга байхгүй          | `is.na()`  | `is.na(7)`   | `FALSE` (\[Хоосон дата\] хуудсыг үзнэ үү)                                                                                                                           |
| Утга байгаа           | `!is.na()` | `!is.na(7)`  | `TRUE`                                                                                                                                                              |

AND ба OR гэх мэт логик операторуудыг ихэвчлэн харьцааны операторуудыг холбож, илүү комплекс шалгууруудыг бий болгоход ашигладаг. Нарийн комплекс мэдэгдлүүд бүлэглэх болон үйлдлийн дарааллыг хадгалахын тулд бөөрөнхий хаалт ( ) ашиглах шаардлагатай байж болно.

Logical operators, such as AND and OR, are often used to connect relational operators and create more complicated criteria. Complex statements might require parentheses ( ) for grouping and order of application.

| Утга            | Оператор                                                                    |
|-----------------|-----------------------------------------------------------------------------|
| AND             | `&`                                                                         |
| OR              | `|` (босоо шугам)                                                           |
| Бөөрөнхий хаалт | `( )` Шалгууруудыг нэгтгэж, үйл ажиллагааны дарааллыг тодруулахад ашигладаг |

Жишээ нь, доор бидэнд тохиолдлын тодорхойлолтыг бий болгохдоо ашиглахыг хүсэж буй хоёр хувьсагч бүхий лайнлист байна: тестийн үр дүн `hep_e_rdt` болон тухайн өрхөд өөр тохиолдол байгаа эсэхийг илтгэх `other_cases_in_hh`. Дараах команд нь `case_when()` функцийг ашиглан `case_def` гэсэн шинэ хувьсагчийг үүсгэнэ.

```{r eval=FALSE}
linelist_cleaned <- linelist %>%
  mutate(case_def = case_when(
    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,
    rdt_result == "Positive"                                 ~ "Confirmed",
    rdt_result != "Positive" & other_cases_in_home == "Yes"  ~ "Probable",
    TRUE                                                     ~ "Suspected"
  ))
```

| Дээрх жишээн дээрх шалгуурууд                                                                | "case_def" шинэ хувьсагчийн үр дүнгийн утга |
|----------------------------------------------------------------------------------------------|---------------------------------------------|
| Хэрэв `rdt_result` болон `other_cases_in_home` хувьсагчийн утга байхгүй бол                  | `NA` (хоосон)                               |
| Хэрэв `rdt_result` дахь утга "Positive" бол                                                  | "Confirmed"                                 |
| Хэрэв `rdt_result` дахь утга "Positive" БИШ БӨГӨӨД `other_cases_in_home` дахь утга "Yes" бол | "Probable"                                  |
| Дээрх шалгууруудын аль нэгийг хангаагүй бол                                                  | "Suspected"                                 |

*R хэл нь үсэгний том, жижигт мэдрэг тул "Positive" нь "positive"-ээс өөр гэдгийг анхаарна уу...*

<!-- ======================================================= -->

### Хоосон утгууд {.unnumbered}

R-д хоосон утгыг `NA` ("нөөцлөгдсөн" утга) гэсэн тусгай утгаар илэрхийлнэ (N ба A том үсэг- ишлэл дотор биш). Хэрэв та хоосон датаг өөр аргаар (жишээ нь 99, "Missing" эсвэл .) бүртгэсэн дата импортлох юм бол эдгээр утгыг `NA` руу дахин кодлохыг хүсэж болох юм. Үүнийг хэрхэн хийх талаар \[Импорт, экспорт\] хуудаснаас үзнэ үү.

**Утга нь `NA` эсэхийг шалгахын тулд `TRUE` эсвэл `FALSE` буцаадаг `is.na()` тусгай функцийг ашиглана.**

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # хоёр эерэг тохиолдол, нэг сэжигтэй, нэг нь тодорхойгүй байна 
is.na(rdt_result)  # rdt_result-ийн утга NA эсэхийг шалгана
```

Хоосон, хязгааргүй (infinite), `NULL` болон боломжгүй утгуудын талаар дэлгэрэнгүйг \[Хоосон дата\] хэсгээс уншина уу. \[Импорт, экспорт\] хуудсан дээр дата импортлохдоо хоосон утгыг хэрхэн хөрвүүлэх талаар олж мэдээрэй.

<!-- ======================================================= -->

### Математик, статистик {.unnumbered}

Энэ хуудасны бүх операторууд болон функцууд нь **base** R-д ашиглахад бэлэн бий.

#### Математик операторууд {.unnumbered}

Эдгээрийг ихэвчлэн нэмэх, хуваах, шинэ багана үүсгэх гэх мэт үйлдлүүдэд ашигладаг. Доорх нь R хэл дээрх нийтлэг математик операторууд юм. Операторуудын эргэн тойронд хоосон зай тавих эсэх нь чухал биш.

| Зорилго              | R дээрх жишээ |
|----------------------|---------------|
| нэмэх                | 2 + 3         |
| хасах                | 2 - 3         |
| үржүүлэх             | 2 \* 3        |
| хуваах               | 30 / 5        |
| зэрэг дэвшүүлэх      | 2\^3          |
| үйлдлүүдийн дараалал | ( )           |

#### Математик функцууд {.unnumbered}

| Зорилго              | Функц                                 |
|----------------------|---------------------------------------|
| бүхэлдэх             | round(x, digits = n)                  |
| бүхэлдэх             | janitor::round_half_up(x, digits = n) |
| тааз (round up)      | ceiling(x)                            |
| шал (round down)     | floor(x)                              |
| үнэмлэхүй утга       | abs(x)                                |
| квадрат язгуур       | sqrt(x)                               |
| илтгэгч              | exponent(x)                           |
| натурал логарифм     | log(x)                                |
| 10 суурьтай логарифм | log10(x)                              |
| 2 суурьтай логарифм  | log2(x)                               |

Тэмдэглэл: `round()` функцын `digits =` аргумент нь аравтын бутархайн тоог заана. `signif()` функцыг ашиглан хэд хэдэн чухал тоо болгон бүхэлдэнэ үү.

#### Шинжлэх ухааны тэмдэглэгээ {.unnumbered}

Шинжлэх ухааны тэмдэглэгээг ашиглах магадлал нь `scipen` тохируулгын утгаас хамаарна.

`?options` хуудаснаас: `scipen` нь тоон утгыг тогтмол эсвэл экспоненциал тэмдэглэгээгээр хэвлэх шийдвэр гаргахад хэрэглэх шийтгэл юм. Эерэг утгууд нь тогтмол, сөрөг утгууд нь шинжлэх ухааны тэмдэглэгээ рүү хазайдаг: "scipen" цифрээс илүү өргөн биш л бол тогтмол тэмдэглэгээг илүүд үзнэ.

Хэрэв үүн дээр бага тоо (жишээ нь 0) тавьсан бол үргэлж "асаалттай" байх болно. R сессийн шинжлэх ухааны тэмдэглэгээг "унтраахын" тулд үүнийг маш өндөр тоонд тохируулна уу, жишээлбэл:

```{r, eval=F}
# шинжлэх ухааны тэмдэглэгээг унтраа
options(scipen=999)
```

#### Бүхэлдэх {.unnumbered}

[***АЮУЛ:*** `round()` функц нь зөвхөн дээд тоо нь тэгш байвал .5-аас дээшээ бүхэлддэг "банкны бүхэлдэх" аргыг ашигладаг. Хагасыг хамгийн ойрын бүхэл тоо хүртэл тогтмол бүхэлдэхийн тулд **janitor** багцын `round_half_up()`-г ашиглана уу. [Энэ тайлбарыг](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) үзнэ үү.]{style="color: red;"}

```{r}
# өөрийн ажилд тохирох бүхэлдэх функцийг ашиглана уу 
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```

#### Статистикийн функцууд {.unnumbered}

[***АНХААРУУЛГА:*** Доорх функцууд нь тооцоололдоо хоосон утгуудыг өгөгдмөлөөр оруулдаг. `na.rm = TRUE` аргументыг заагаагүй бол хоосон утгууд нь `NA` үүсгэнэ. Үүнийг товчоор `na.rm = T` гэж бичиж болно.]{style="color: orange;"}

| Зорилго             | Функц              |
|---------------------|--------------------|
| дундаж (average)    | mean(x, na.rm=T)   |
| голч                | median(x, na.rm=T) |
| стандарт хазайлт    | sd(x, na.rm=T)     |
| квантилүүд\*        | quantile(x, probs) |
| нийлбэр             | sum(x, na.rm=T)    |
| хамгийн бага утга   | min(x, na.rm=T)    |
| хамгийн их утга     | max(x, na.rm=T)    |
| тоон утгуудын хүрээ | range(x, na.rm=T)  |
| хураангуй\*\*       | summary(x)         |

Тэмдэглэл:

-   `*quantile()`: `x` нь шалгах тоон вектор, `probs =` нь 0-ээс 1.0 хоорондахь магадлал бүхий тоон вектор, жишээлбэл `c(0.5, 0.8, 0.85)`
-   `**summary()`: дундаж, голч, нийтлэг персентилүүд зэрэг тоон векторын хураангуйг өгдөг

[***АЮУЛ:*** Хэрэв дээрх функцүүдийн аль нэгэнд тоон вектор өгвөл `c()` дотор тоонуудыг нийлүүлж оруулахаа мартуузай.]{style="color: red;"}

```{r}
# Хэрэв функцэд тоонууд өгч байгаа бол тэдгээрийг c()-д боож өгнө үү. 
mean(1, 6, 12, 10, 5, 0)    # !!! БУРУУ !!!  

mean(c(1, 6, 12, 10, 5, 0)) # ЗӨВ
```

#### Бусад хэрэгтэй функцууд {.unnumbered}

| Зорилго                 | Функц             | Жишээ                                           |
|-------------------------|-------------------|-------------------------------------------------|
| дараалал үүсгэх         | seq(from, to, by) | `seq(1, 10, 2)`                                 |
| x-ийг n удаа давтах     | rep(x, ntimes)    | `rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)`     |
| тоон векторыг хуваах    | cut(x, n)         | `cut(linelist$age, 5)`                          |
| санамсаргүй түүвэр авах | sample(x, size)   | `sample(linelist$id, size = 5, replace = TRUE)` |

<!-- ======================================================= -->

### `%in%` {.unnumbered}

Утгыг тааруулах, утгыг вектор эсвэл датафрэйм дотор байгаа эсэхийг хурдан үнэлэхэд маш хэрэгтэй оператор.

```{r}
my_vector <- c("a", "b", "c", "d")
```

```{r}
"a" %in% my_vector
"h" %in% my_vector
```

Утга нь вектор `%in%` (%дотор%) байхгүй эсэхийг шалгахын тулд логик хэллэгийн **өмнө** анхаарлын тэмдэг (!) тавина:

```{r}
# үгүйсгэхэд өмнө нь анхаарлын тэмдэг тавина
!"a" %in% my_vector
!"h" %in% my_vector
```

**dplyr** багцын `case_when()` функцийг ашиглахад `%in%` маш хэрэгтэй. Та векторыг өмнө нь тодорхойлж, дараа нь лавлаж болно. Жишээлбэл:

```{r eval=F}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")

linelist <- linelist %>% 
  mutate(child_hospitaled = case_when(
    hospitalized %in% affirmative & age < 18 ~ "Hospitalized Child",
    TRUE                                      ~ "Not"))
```

Тэмдэглэл: Хэрэв та **stringr** багцын `str_detect()` ашиглан стрингийн хэсгийг илрүүлэхийг хүсвэл энэ нь `c("1", "Yes", "yes", "y")` гэх мэт тэмдэгтийн векторыг хүлээн авдаггүй. Үүний оронд "1\|Yes\|yes\|y" гэх мэт OR босоо шугам бүхий нэг хураангуй стринг бүхий *ердийн* *илэрхийлэл (regular expression)* өгөх ёстой. Жишээлбэл, `str_detect(hospitalized, "1|Yes|yes|y")`. Дэлгэрэнгүй мэдээллийг \[Тэмдэгт болон стринг\] хуудаснаас үзнэ үү.

Та энэ командыг ашиглан тэмдэгтийн векторыг нэрлэсэн ердийн илэрхийлэл болгон хувиргаж болно:

```{r}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")
affirmative

# багасгах 
affirmative_str_search <- paste0(affirmative, collapse = "|")  # base R
affirmative_str_search <- str_c(affirmative, collapse = "|")   # stringr багц

affirmative_str_search
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Алдаа болон анхааруулга

Энэ хэсэгт дараахь зүйлийг тайлбарласан:

-   Алдаа болон анхааруулгын ялгаа

-   R код бичих ерөнхий синтакс зөвлөмжүүд

-   Кодын туслахууд

Нийтлэг алдаа, анхааруулга, алдааг олж засварлах зөвлөмжийг \[Алдаа болон тусламж\] хуудаснаас олж болно.

<!-- ======================================================= -->

### Алдаа versus анхааруулга {.unnumbered}

Заримдаа команд ажиллуулах үед R консол танд анхааруулга эсвэл алдааны мэдэгдлийг улаан бичвэрээр харуулах болно.

-   **Анхааруулга** нь R таны командыг гүйцэтгэсэн боловч нэмэлт алхмуудыг хийх хэрэгтэй болсон эсвэл таны мэдэж байх ёстой хэвийн бус гаралт гаргасан гэсэн үг юм.

-   **Алдаа** нь R таны командыг гүйцээж чадаагүй гэсэн үг.

Сэжүүр хайх:

-   Алдаа/анхааруулах мессеж нь ихэвчлэн асуудлын мөрийн дугаарыг агуулна.

-   Хэрэв объект "үл мэдэгдэх" эсвэл "олдохгүй" бол та буруу бичсэн, library() функцээр багц ачааллахаа мартсан эсвэл өөрчлөлт хийсний дараа скриптийг дахин ажиллуулахаа мартсан байж магадгүй юм.

Хэрэв эдгээрийн аль нь ч биш байвал алдааны мессежийг зарим үндсэн нэр томъёоны хамт Google рүү хуулна уу - өөр хэн нэгэн үүнийг аль хэдийн даван туулсан байх магадлал өндөр!

<!-- ======================================================= -->

### Синтаксийн ерөнхий зөвлөмжүүд {.unnumbered}

R дээр команд бичихдээ алдаа, анхааруулгаас зайлсхийхийн тулд хэд хэдэн зүйлийг санах хэрэгтэй:

-   Үргэлж хаалт хаах - зөвлөгөө: кодын хэсэг бүрийн нээх "(" ба хаах хаалтуудын ")" тоог тоол.

-   Багана болон объектын нэрэнд хоосон зай оруулахаас зайлсхий. Оронд нь доогуур зураас ( \_ ) эсвэл цэг ( . ) ашиглана уу

-   Функцийн аргументуудыг таслалаар салгахаа бүү мартаарай

-   R нь үсгийн том, жижигт мэдрэг бөгөөд `Variable_A` нь `variable_A`-аас ялгаатай гэсэн үг

<!-- ======================================================= -->

### Кодын туслахууд {.unnumbered}

Аливаа скрипт (RMarkdown эсвэл бусад) нь таныг алдаа гаргасан үед сэжүүр өгөх болно. Жишээлбэл, хэрэв та шаардлагатай газар таслал бичих, эсвэл хаалт хаахаа мартсан бол RStudio танд анхааруулахын тулд тухайн мөрөнд, скриптийн баруун талд туг өргөх болно.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/basics.Rmd-->

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

# R руу шилжих

Хэрэв та R руу өөр программаас шилжиж байгаа бол бид доор зарим зөвлөгөө, материалыг танд өгөх болно.

R нь 1990-ээд оны сүүлээр гарч ирсэн бөгөөд түүнээс хойш хамрах хүрээ нь эрс нэмэгдсэн. R маш өргөн хүрээний чадавхитай тул арилжааны статитистик программууд өрсөлдөх чадвартай хэвээр үлдэхийн тулд R хөгжүүлэлтэд хариу үйлдэл үзүүлсэн! ([R, SPSS, SAS, STATA, Python-г харьцуулсан энэ нийтлэлийг уншина уу](https://www.inwt-statistics.com/read-blog/comparison-of-r-python-sas-spss-and-stata.html)).

Үүний зэрэгцээ R-ыг 10 жилийн өмнөхтэй харьцуулахад сурахад илүү хялбар болсон. Өмнө нь R эхлэн суралцагчдад их хэцүү гэсэн ойлголттой байсан бол RStudio зэрэг хэрэглэгчид ээлтэй интерфэйс, **tidyverse** гэх мэт ойлгомжтой код, сургалтын олон материалын тусламжтайгаар энэ нь илүү хялбар болсон.

[**Та бүү сүрдээрэй- бидэнтэй нийлж R-ын ертөнцтэй танилцаарай!**]{style="color: darkgreen;"}

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "transition_door.png"))
```

## Excel-ээс

Excel-ээс R руу шууд шилжих нь тун хүрч болохуйц зорилго юм. Энэ нь эхэндээ сүрдэм мэт санагдаж болох ч та үүнийг хийж чадна!

Excel-ийн өндөр ур чадвартай хүн VBA гэх мэт скрипт хэрэгслийг ашиглан Excel дээр маш ахисан түвшний үйлдлүүдийг хийж чаддаг. Excel програмыг дэлхий даяар ашигладаг бөгөөд тархвар судлаачийн зайлшгүй шаардлагатай хэрэгсэл юм. Гэсэн хэдий ч үүнийг R-аар орлуулах нь таны ажлын урсгалыг эрс сайжруулж, өргөжүүлэх боломжтой.

### Ашиг тус {.unnumbered}

R-ийг ашиглах нь цаг хугацаа хэмнэсэн, илүү тогтвортой, үнэн зөв дүн шинжилгээ хийх, дахин давтагдах, хуваалцах боломжтой, алдааг хурдан засах зэрэг асар их ашиг тусыг өгдөг гэдгийг та олж мэдэх болно. Аливаа шинэ программ сурахын нэгэн адил та сайн ашиглаж сурахын тулд цаг хугацааны хөрөнгө оруулалт хийх ёстой суралцах "муруй" байдаг. Үүний үр дүнд ирэх ашиг нь мэдэгдэхүйц байх бөгөөд R танд олон шинэ боломжуудыг нээх болно.

Excel бол анхлан суралцагчдад "point-and-click" буюу чиглүүлээд товших замаар энгийн дүн шинжилгээ хийх, дүрслэн харуулахад хялбар байдаг алдартай програм хангамж. Үүнтэй харьцуулахад, R функц болон интерфэйстэй дасахад хэдэн долоо хоног шаардлагатай. Гэсэн хэдий ч R сүүлийн жилүүдэд анхлан суралцагчдад илүү ээлтэй болж хөгжсөн.

Excel-ийн олон ажлын урсгал нь санах ой болон давталт дээр тулгуурладаг тул алдаа гаргах боломж их байдаг. Цаашилбал, ерөнхийдөө дата цэвэрлэх, дүн шинжилгээ хийх арга зүй, ашигласан тэгшитгэлүүд нь нүднээс далд байдаг. Үүний улмаас шинээр ажилд орсон хүн өмнөх Excel-ийн ажлын дэвтэр юу хийж байгааг болон алдааг хэрхэн олж засварлах талаар сурахад ихээхэн цаг хугацаа шаарддаг. Харин R дээр бүх алхмуудыг скрипт дээр тодорхой бичсэн бөгөөд хялбархан харж, засварлаж, засч, бусад датасетэд хэрэглэж болно.

**Excel-ээс R руу шилжихийн тулд та хэд хэдэн чухал замаар сэтгэлгээгээ өөрчлөх шаардлагатай:**

### Цэгцтэй дата (Tidy data) {.unnumbered}

"Хүн уншдаг" замбараагүй датаны оронд машинаар уншигдахуйц "цэгцтэй" датаг ашигла. [R хэл дээрх "цэгцтэй" датаны](https://r4ds.had.co.nz/tidy-data.html) талаарх энэхүү зааварт тайлбарласны дагуу эдгээр нь "цэгцтэй" датанд тавигдах гурван үндсэн шаардлага юм:

-   Хувьсагч бүр өөрийн гэсэн баганатай байх ёстой

-   Ажиглалт бүр өөрийн гэсэн мөртэй байх ёстой

-   Утга бүр өөрийн нүдтэй байх ёстой

Excel-ийн хэрэглэгчдэд - [Excel-ийн "хүснэгтүүд"](https://exceljet.net/excel-tables) датаг стандартчилах, форматыг урьдчилан таамаглах боломжтой болгоход ямар үүрэг гүйцэтгэдэг талаар бодож үзээрэй.

"Цэгцтэй" датаны жишээ бол энэ гарын авлагад ашигласан тохиолдлын лайнлист байж болно - хувьсагч бүр нэг баганад агуулагддаг, ажиглалт (нэг тохиолдол) бүр өөрийн гэсэн мөртэй, утга бүр нь зөвхөн нэг нүдэнд байна. Та лайнлистийн эхний 50 мөрийг доороос харж болно:

```{r, echo=F}
# лайнлистийг R руу импортлох
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, message=FALSE, echo=F}
# лайнлистийг хүснэгт хэлбэрээр харуулах
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

*Эмх цэгцгүй дататай тулгардаг гол шалтгаан нь Excel-ийн олон хүснэгтүүд нь машин/програм хангамжаар уншихад хялбар биш, харин хүн уншихад хялбар болгох зорилгоор бүтээгдсэн байдаг.*

Ялгааг олж харахад тань туслахын тулд *машинд* унших чадвараас илүү *хүний* унших чадварыг чухалчилдаг **эмх цэгцгүй датаны** зарим зохиомол жишээг доор харуулав:

```{r, echo=F, out.width = "100%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_1.png"))
```

*Асуудлууд*: Дээрх хүснэгтэд R-д амархан илэрхийлэгдэггүй, нэгтгэсэн нүднүүд байна. Аль мөрийг "толгой" гэж үзэх нь тодорхойгүй байна. Өнгөнд суурилсан толь бичиг баруун талд байгаа бөгөөд нүдний утгуудыг өнгөөр дүрсэлсэн байдаг нь R-д мөн амар уншигддаггүй (өнгө харалган хүмүүст ч бас!). Цаашилбал, өөр өөр мэдээллийг нэг нүдэнд нэгтгэсэн (нэг хэсэгт ажилладаг олон түнш байгууллагууд, эсвэл "Partner D"-тэй нэг нүдэнд "TBC" статус).

```{r, echo=F, out.width = "100%", out.height="100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_2.png"))
```

*Асуудлууд*: Дээрх хүснэгтэд датасет дотор олон тооны нэмэлт хоосон мөр, багана байна - энэ нь R-д цэвэрлэхэд хүндрэл үүсгэдэг. Цаашилбал, GPS-ийн координатууд нь тодорхой эмчилгээний төв бүрт хоёр мөрөнд дамнаж бичигдсэн байна. Мөн дээрээс нь GPS-ийн координатууд нь хоёр өөр форматтай байна!

"Цэгцтэй" датасет нь хүний нүдээр уншихад хялбар биш байж болох ч дата цэвэрлэх, дүн шинжилгээ хийхэд илүү хялбар болгодог! Цэгцтэй датаг "урт" эсвэл "өргөн" гэх мэт янз бүрийн форматаар хадгалах боломжтой (\[Датаг пивот хийх\] хуудсыг үзнэ үү), гэхдээ дээрх зарчмууд хэвээр байна.

### Функцууд {.unnumbered}

"Функц" гэсэн R үг нь шинэ байж болох ч Excel-д энэ ойлголт томьёо хэлбэрээр байдаг. Excel-ийн томьёо нь мөн нарийн синтакс шаарддаг (жишээ нь, цэг таслал, хаалт байрлуулах). Таны хийх ёстой зүйл бол ердөө л R-н хэдэн шинэ функц болон тэдгээр нь хэрхэн хамтран ажилладаг талаар сурах явдал юм.

### Скриптүүд {.unnumbered}

Товчлуур дээр дарж, нүдийг чирэхийн оронд та алхам, процедур *бүрийг* "скрипт" болгон бичих болно. Зарим Excel-ийн хэрэглэгчид скрипт бичих аргыг ашигладаг "VBA макро"-г мэддэг байх.

*R скрипт нь алхам бүрийн зааварчилгаанаас бүрдэнэ.* Энэ нь ямар ч хамтрагчдад скриптийг уншиж, таны хийсэн алхмуудыг хялбархан харах боломжийг олгоно. Ингэснээр алдаа эсвэл буруу тооцооллыг засахад тусалдаг. Жишээнүүдийг \[R суурь ойлголтууд\] бүлгийн скриптүүд хэсгээс үзнэ үү.

R скриптийн нэг жишээ:

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "example_script.png"))
```

### Excel-ээс-R шилжих материалууд {.unnumbered}

Excel-ээс R руу шилжихэд туслах хэдэн хичээлийг эндээс үзнэ үү:

-   [R vs Excel](https://www.northeastern.edu/graduate/blog/r-vs-excel/)

-   [Excel хэрэглэгчдэд зориулсан R хэл дээрх RStudio курс](https://rstudio-conf-2020.github.io/r-for-excel/)

### R-Excel-ийн харилцан үйлчлэл {.unnumbered}

R нь Excel-ийн ажлын номыг импортлох, дататай ажиллах, Excel файлуудыг экспортлох/хадгалах, Excel хуудасны нарийн ширийн зүйлстэй ажиллах найдвартай аргуудтай.

Зарим илүү гоо зүйн Excel форматыг оруулах үед (жишээ нь налуу текст, босоо текст гэх мэт) алдагдаж болдог. Хэрэв таны ажлын урсгал Excel-ийн анхны форматыг хадгалахын зэрэгцээ R болон Excel хооронд бичиг баримтыг хооронд нь дамжуулах шаардлагатай бол **openxlsx** зэрэг багцуудыг ашиглаж үзээрэй.

## Stata-гаас

<!-- ======================================================= -->

**Stata-гаас R-д ирэх**

Олон тархвар судлаачдад эхлээд Stata-г хэрхэн ашиглахыг заадаг бөгөөд R-д шилжих нь хэцүү юм шиг санагддаг. Гэсэн хэдий ч, хэрэв та Stata-г сайн хэрэглэж сурсан бол R руу шилжих нь таны бодож байгаагаас илүү хялбар байх болно. Дата хэрхэн үүсгэх, өөрчлөх, дүн шинжилгээ хийх функцууд хэрхэн хэрэгжих зэрэгт Stata болон R хоёрын хооронд зарим нэг гол ялгаа байдаг ч эдгээр гол ялгааг сурсны дараа та ур чадвараа хөрвүүлэх боломжтой болно.

Stata болон R-ын хоорондох зарим үндсэн хөрвүүлгийг доор харуулав, энэ нь танд энэхүү гарын авлагыг унших явцад хэрэг болж магадгүй.

**Ерөнхий тэмдэглэл**

+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                                                                                  | **R**                                                                                                                                                                                                              |
+============================================================================================================================================================+====================================================================================================================================================================================================================+
| Та нэг удаад зөвхөн нэг датасет харж, удирдах боломжтой                                                                                                    | Та олон датасетийг нэгэн зэрэг харж, удирдах боломжтой тул код дотор датасетээ байнга зааж өгөх шаардлагатай болдог.                                                                                               |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Онлайн тусламжийг <https://www.statalist.org/> вэбсайтаар дамжуулан авах боломжтой                                                                         | Онлайн тусламжийг [RStudio](https://community.rstudio.com/), [StackOverFlow](https://stackoverflow.com/questions/tagged/r), болон [R-bloggers](https://www.r-bloggers.com/) вэбсайтуудаар дамжуулан авах боломжтой |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Чиглүүлээд товших (point-and-click) функц байгаа                                                                                                           | Маш бага чиглүүлээд товших функцтэй                                                                                                                                                                                |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Командуудын тусламжийг `help [command]` командаар авч болно                                                                                                | Тусламжийг `[function]?` командаар дуудна эсвэл Тусламж хэсэгт хайлт хийнэ                                                                                                                                         |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Кодод дараах тэмдгүүдийг ашиглан тайлбар бичиж болно: \* эсвэл /// эсвэл /\* TEXT \*/                                                                      | Чагт тэмдэг (#) ашиглан тайлбар бичнэ                                                                                                                                                                              |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Бараг бүх командууд Stata-д суурилагдсан байдаг. Шинэ/хэрэглэгчийн бичсэн функцуудыг **ssc install** \[багц\] ашиглан **ado** файл байдлаар суулгаж болно. | R нь **base** функцуудтэй суудаг боловч ердийн хэрэглээний үед CRAN-аас бусад багцуудыг суулгах нь хэвийн үзэгдэл (\[R суурь ойлголтууд\] хуудсыг үзнэ үү)                                                         |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Дүн шинжилгээг ихэвчлэн **do** файлд бичдэг                                                                                                                | Дүн шинжилгээ RStudio үүсвэр хэсэгт R скриптэнд ихэвчлэн бичигддэг. Мөн R markdown скрипт ашиглаж болно.                                                                                                           |
+------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Ажлын директор**

+------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                            | **R**                                                                                                                                          |
+======================================================================================================+================================================================================================================================================+
| Ажлын директор нь үнэмлэхүй файлын замыг агуулдаг (жишээ нь: "C:/username/documents/projects/data/") | Ажлын директор нь үнэмлэхүй эсвэл **here** багцыг ашиглан төслийн үндсэн хавтастай холбоотой байж болно (\[Импорт, экспорт\] хэсгийг үзнэ үү). |
+------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| **pwd** ашиглан одоогийн ажиллаж буй директорийг харна                                               | `getwd()` эсвэл `here()` (хэрэв **here** багцыг ашиглаж байгаа бол) функцуудыг хоосон хаалттай ашиглана                                        |
+------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| **cd** "хавтасны байршил" ашиглан ажлын директорийг тохируулна                                       | `setwd(“хавтасны байршил”)` эсвэл `set_here("хавтасны байршил)` (хэрэв **here** багцыг ашиглаж байгаа бол) ашиглана                            |
+------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+

**Дата импортлох, харах**

+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                                                 | **R**                                                                                                                                                                                                                                 |
+===========================================================================================================================+=======================================================================================================================================================================================================================================+
| Файлын төрөл тус бүрд тусгай командууд                                                                                    | Бараг бүх файлын төрөлд **rio** багцын `import()` функцыг ашиглаж болно. Өөр тусгай функцуудын сонголтууд бий (\[Импорт, экспорт\] хэсгийг үзнэ үү).                                                                                  |
+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| csv файлуудыг унших нь **import delimited** "filename.csv" командаар хийгддэг.                                            | `import("filename.csv")` ашиглана                                                                                                                                                                                                     |
+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| xslx файлуудыг унших нь **import excel** "filename.xlsx" командаар хийгддэг                                               | `import("filename.xlsx")` ашиглана                                                                                                                                                                                                    |
+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **browse** командыг ашиглан датагаа шинэ цонхонд харна                                                                    | `View(dataset)` ашиглан RStudio үүсвэр хэсэгт датасетийг харах боломжтой. *Олон датасетийг нэгэн зэрэг хадгалж болдог тул та R-ын функцэд тухайн датасетийнхээ нэрийг зааж өгөх хэрэгтэй. Дээрх функцийн том "V" үсгийг анхаараарай.* |
+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Хувьсагчийн нэр болон үндсэн мэдээллийг харуулдаг **summarize** командыг ашиглан датасетийнхээ дээд түвшний тоймыг харна. | `summary(dataset)` ашиглан датасетийнхээ дээд түвшний тоймыг харна.                                                                                                                                                                   |
+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Дататай ажиллах үндсэн командууд**

+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                              | **R**                                                                                                                                                                         |
+========================================================================================+===============================================================================================================================================================================+
| Датасетийн багануудыг ихэвчлэн "хувьсагч" гэж нэрлэдэг.                                | Ихэнхдээ "багана" эсвэл заримдаа "вектор" эсвэл "хувьсагч" гэж нэрлэдэг.                                                                                                      |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Датасетийг зааж өгөх шаардлагагүй                                                      | Доорх команд бүрт та датасетийг зааж өгөх хэрэгтэй - жишээнүүдийг \[Дата цэвэрлэх болон үндсэн функцууд\] хуудаснаас үзнэ үү.                                                 |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **generate** *varname* = командыг ашиглан шинэ хувьсагчдыг үүсгэнэ                     | `mutate(varname = )` функцийг ашиглан шинэ хувьсагч үүсгэнэ. Доорх бүх **dplyr**-ынфункцуудын талаар дэлгэрэнгүйг \[Дата цэвэрлэх болон үндсэн функцууд\] хуудаснаас үзнэ үү. |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **rename** *old_name new_name* командаар хувьсагчдын нэрийг өөрчилдөг                  | `rename(new_name = old_name)` функцийг ашиглан хувьсагчдын нэрийг өөрчилж болно                                                                                               |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Хувьсагчдыг **drop** varname ашиглан хасдаг                                            | Хаалтанд хасах тэмдгийн дараа баганын нэрийг бичсэн `select()` функцийг ашиглан багануудыг хасаж болно                                                                        |
|                                                                                        |                                                                                                                                                                               |
| Variables are dropped using **drop** *varname*                                         |                                                                                                                                                                               |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Фактор хувьсагчдыг **label define** гэх мэт хэд хэдэн командыг ашиглан шошголож болно. | Баганыг Фактор анги руу хөрвүүлж, түвшинг зааж өгснөөр утгуудыг нь шошголж болно. \[Фактор\] хуудаснаас харна уу. Ихэнх тохиолдолд баганын нэрийг Stata шиг шошголдоггүй.     |
+----------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Дескриптив дүн шинжилгээ**

+------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                                  | **R**                                                                                                                                                                                            |
+============================================================================================================+==================================================================================================================================================================================================+
| **tab** *varname* ашиглан хувьсагчийн тоог хүснэгтэлдэг.                                                   | `table(dataset$colname)` гэх мэтээр `table()` функцэд датасет болон баганын нэрийг оруулна. Эсвэл \[Дата бүлэглэх\] хэсэгт тайлбарласны дагуу **dplyr** багцын `count(varname)`-г ашиглаж болно. |
+------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 2х2 хүснэгтээр хоёр хувьсагчийн хөндлөн хүснэгтийг харуулахад **tab** *varname1 varname2* команд ашиглана. | `table(dataset$varname1, dataset$varname2` эсвэл `count(varname1, varname2)` ашиглана.                                                                                                           |
+------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Хэдийгээр энэ жагсаалт нь Stata командуудыг R руу хөрвүүлэх үндсэн зарчмуудын тоймыг өгч буй боловч энэ нь бүрэн гүйцэд биш юм. R руу шилжиж байгаа Stata хэрэглэгчдэд сонирхолтой байж болох өөр олон эх сурвалжууд байдаг:

-   <https://dss.princeton.edu/training/RStata.pdf>\
-   <https://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html>\
-   <http://r4stats.com/books/r4stata/>

## SAS-аас

<!-- ======================================================= -->

**SAS-аас R-д ирэх**

SAS нь нийгмийн эрүүл мэндийн агентлагууд болон эрдэм шинжилгээ, судалгааны салбарт түгээмэл хэрэглэгддэг. Хэдийгээр шинэ программ руу шилжих нь тийм ч хялбар биш боловч SAS, R хоёрын гол ялгааг ойлгох нь таныг одоогийн программаа ашиглан шинэ программ руу шилжихэд тусална. SAS болон R-ын дата менежмент болон дескриптив дүн шинжилгээний үндсэн хөрвүүлгүүдийг доор харуулав.

**Ерөнхий тэмдэглэл**

+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                                              | **R**                                                                                                                                                                                                              |
+======================================================================================================================================================================================================+====================================================================================================================================================================================================================+
| Онлайн тусламж [SAS хэрэглэгчийн тусламжаар](https://support.sas.com/en/support-home.html) дамжуулан авах боломжтой                                                                                  | Онлайн тусламжийг [RStudio](https://community.rstudio.com/), [StackOverFlow](https://stackoverflow.com/questions/tagged/r), болон [R-bloggers](https://www.r-bloggers.com/) вэбсайтуудаар дамжуулан авах боломжтой |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Командуудын тусламжийг `help [command]` командаар авч болно                                                                                                                                          | Тусламжийг `[function]?` командаар дуудна эсвэл Тусламж хэсэгт хайлт хийнэ                                                                                                                                         |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `* TEXT ;` эсвэл `/* TEXT */` ашиглан кодын тайлбар бичнэ                                                                                                                                            | Чагт тэмдэг (#) ашиглан тайлбар бичнэ                                                                                                                                                                              |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Бараг бүх командууд нь суурин байдаг. Хэрэглэгчид SAS macro, SAS/IML, SAS Component Language (SCL) болон хамгийн сүүлд `Proc Fcmp` болон `Proc Proto` процедурыг ашиглан шинэ функц бичих боломжтой. | R нь **base** функцуудтэй суудаг боловч ердийн хэрэглээний үед CRAN-аас бусад багцуудыг суулгах нь хэвийн үзэгдэл (\[R суурь ойлголтууд\] хуудсыг үзнэ үү)                                                         |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Дүн шинжилгээг ихэвчлэн Editor цонхонд SAS программ бичих замаар хийдэг.                                                                                                                             | Дүн шинжилгээ RStudio үүсвэр хэсэгт R скриптэнд ихэвчлэн бичигддэг. Мөн R markdown скрипт ашиглаж болно.                                                                                                           |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Ажлын директор**

+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                                   | **R**                                                                                                                                          |
+===========================================================================================================================================================================================+================================================================================================================================================+
| Ажлын директор нь үнэмлэхүй эсвэл `%let rootdir=/root path; %include “&rootdir/subfoldername/filename”` ашиглан үндсэн хавтсыг тодорхойлсноор төслийн эх хавтастай харьцангуй байж болно. | Ажлын директор нь үнэмлэхүй эсвэл **here** багцыг ашиглан төслийн үндсэн хавтастай холбоотой байж болно (\[Импорт, экспорт\] хэсгийг үзнэ үү). |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| `%put %sysfunc(getoption(work));` ашиглан одоогийн ажлын директорийг харна                                                                                                                | `getwd()` эсвэл `here()` (хэрэв **here** багцыг ашиглаж байгаа бол) функцуудыг хоосон хаалттай ашиглана                                        |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+
| `libname “хавтасны байршил”` ашиглан ажлын директорийг тохируулна                                                                                                                         | `setwd(“хавтасны байршил”)` эсвэл `set_here("хавтасны байршил)` (хэрэв **here** багцыг ашиглаж байгаа бол) ашиглана                            |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------+

**Дата импортлох, харах**

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                                                                                           | **R**                                                                                                                                                                                                                                 |
+===================================================================================================================================================================================================================================================+=======================================================================================================================================================================================================================================+
| `Proc Import` процедурыг эсвэл `Data Step Infile` мэдэгдлийг ашиглана.                                                                                                                                                                            | Бараг бүх файлын төрөлд **rio** багцын `import()` функцыг ашиглаж болно. Өөр тусгай функцуудын сонголтууд бий (\[Импорт, экспорт\] хэсгийг үзнэ үү).                                                                                  |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| csv файлуудыг уншихдаа `Proc Import datafile=”filename.csv” out=work.filename dbms=CSV; run;`; ЭСВЭЛ [Data Step Infile мэдэгдлийг](https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/lestmtsref/n1rill4udj0tfun1fvce3j401plo.htm) ашиглана   | `import("filename.csv")` ашиглана                                                                                                                                                                                                     |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| xslx файлуудыг уншихдаа `Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx; run;` ЭСВЭЛ [Data Step Infile мэдэгдлийг](https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/lestmtsref/n1rill4udj0tfun1fvce3j401plo.htm) ашиглана | `import("filename.xlsx")` ашиглана                                                                                                                                                                                                    |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Explorer цонхыг нээж, хүссэн library болон датасетээ сонгосноор шинэ цонхонд датагаа харна                                                                                                                                                        | `View(dataset)` ашиглан RStudio үүсвэр хэсэгт датасетийг харах боломжтой. *Олон датасетийг нэгэн зэрэг хадгалж болдог тул та R-ын функцэд тухайн датасетийнхээ нэрийг зааж өгөх хэрэгтэй. Дээрх функцийн том "V" үсгийг анхаараарай.* |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Дататай ажиллах үндсэн командууд**

+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                              | **R**                                                                                                                                                                         |
+======================================================================================================================================================================+===============================================================================================================================================================================+
| Датасетийн багануудыг ихэвчлэн "хувьсагчид" гэж нэрлэдэг.                                                                                                            | Ихэнхдээ "багана" эсвэл заримдаа "вектор" эсвэл "хувьсагч" гэж нэрлэдэг.                                                                                                      |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Хувьсагч үүсгэхийн тулд тусгай процедур шаардлагагүй. Шинэ хувьсагчийн нэр, дараа нь тэнцүү тэмдэг, дараа нь утгын илэрхийлэл бичих замаар шинэ хувьсагчийг үүсгэнэ. | `mutate(varname = )` функцийг ашиглан шинэ хувьсагч үүсгэнэ. Доорх бүх **dplyr**-ынфункцуудын талаар дэлгэрэнгүйг \[Дата цэвэрлэх болон үндсэн функцууд\] хуудаснаас үзнэ үү. |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `rename *old_name=new_name*` ашиглан хувьсагчдын нэрийг өөрчилнө                                                                                                     | `rename(new_name = old_name)` функцийг ашиглан хувьсагчдын нэрийг өөрчилж болно                                                                                               |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `**keep**=varname` ашиглан хувьсагчдыг үлдээнэ                                                                                                                       | `select()` функцийг ашиглан хаалтан дотор багануудын нэрийг бичин сонгож болно                                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `**drop**=varname` ашиглан хувьсагчдыг хасна                                                                                                                         | Хаалтанд хасах тэмдгийн дараа баганын нэрийг бичсэн `select()` функцийг ашиглан багануудыг хасаж болно                                                                        |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Фактор хувьсагчдыг `Label` мэдэгдлийг ашиглан Data Step-д шошголж болно                                                                                              | Баганыг Фактор анги руу хөрвүүлж, түвшинг зааж өгснөөр утгуудыг нь шошголж болно. \[Фактор\] хуудаснаас харна уу. Ихэнх тохиолдолд баганын нэрийг Stata шиг шошголдоггүй.     |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Data Step-д `Where` эсвэл `If` командыг ашиглан бичлэгүүдийг сонгоно. Олон сонголтын нөхцлийг "and" командыг ашиглан тусгаарлана.                                    | Бичлэгүүдийг AND оператор (&) эсвэл таслалаар тусгаарлагдсан олон сонголтын нөхцөл бүхий `filter()` функцийг ашиглан сонгоно.                                                 |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Data Step-д `Merge` мэдэгдлийг ашиглан датасетүүдийг нэгтгэдэг. Нэгтгэх датасетүүдийг эхлээд `Proc Sort` процедурыг ашиглан сортлох шаардлагатай.                    | **dplyr** багц нь датасетүүдийг нэгтгэх хэд хэдэн функцийг санал болгодог. Дэлгэрэнгүйг \[Дата нэгтгэх\] хуудаснаас үзнэ үү.                                                  |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Дескриптив дүн шинжилгээ**

+-----------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                           | **R**                                                                                                                                                                                                                                       |
+===================================================================================================================================+=============================================================================================================================================================================================================================================+
| Хувьсагчийн нэр болон дескриптив статистикийг харуулдаг `Proc Summary` процедурыг ашиглан датасетийнхээ дээд түвшний тоймыг авна. | `summary(dataset)` эсвэл **skimr** багцын `skim(dataset)` ашиглан датасетийнхээ дээд түвшний тоймыг авна.                                                                                                                                   |
+-----------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `proc freq data=Dataset; Tables varname; Run;` ашиглан хувьсагчийн тоон хүснэгтийг гаргана                                        | \[Дескриптив хүснэгт\] хуудсыг үзнэ үү. Сонголтууд нь **base** R-ын `table()` болон **janitor** багцын `tabyl()` зэрэг функцууд юм. R нь олон датасет агуулж болох тул та датасет болон баганын нэрийг зааж өгөх шаардлагатайг анхаарна уу. |
+-----------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `proc freq data=Dataset; Tables rowvar*colvar; Run;` ашиглан 2 хувьсагчийн 2х2 хөндлөн хүснэгт гаргаж авна                        | Та \[Дескриптив хүснэгт\] хуудсанд тайлбарласны дагуу `table()`, `tabyl()` эсвэл бусад сонголтыг ашиглаж болно.                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Зарим хэрэгтэй нэмэлт материалууд:**

[R for SAS and SPSS Users (2011)](https://www.amazon.com/SAS-SPSS-Users-Statistics-Computing/dp/1461406846/ref=sr_1_1?dchild=1&gclid=EAIaIQobChMIoqLOvf6u7wIVAhLnCh1c9w_DEAMYASAAEgJLIfD_BwE&hvadid=241675955927&hvdev=c&hvlocphy=9032185&hvnetw=g&hvqmt=e&hvrand=16854847287059617468&hvtargid=kwd-44746119007&hydadcr=16374_10302157&keywords=r+for+sas+users&qid=1615698213&sr=8-1)

[SAS and R, Second Edition (2014)](https://www.amazon.com/SAS-Management-Statistical-Analysis-Graphics-dp-1466584491/dp/1466584491/ref=dp_ob_title_bk)

## Датаны харилцан ажиллах чадвар

<!-- ======================================================= -->

R багц **rio** нь STATA-ын .dta файл, SAS-ын .xpt, .sas7bdat файлууд, SPSS-ийн .por, .sav файлууд болон бусад олон файлуудыг хэрхэн импортлох, экспортлох боломжтой талаар дэлгэрэнгүйг \[Импорт, экспорт\] хуудаснаас үзнэ үү.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/transition_to_R.Rmd-->

# Санал болгох багцууд

R -дээр тархвар судлалын ажилд өргөн хэрэглэдэг багцуудыг доор жагсаав. Доорх кодыг шууд хуулж аваад уншуулж болно. Уншуулсан код CRAN --аас эдгээр багцуудыг татаж аваад, тухайн нээлттэй R- дээр шууд ачааллаж өгдөг. Хэрэв өмнө нь татаж авагдсан багц байсан бол зөвхөн ачааллах үйлдэл нь хийгднэ.

Доорх жагсаалтад ашиглах шаардлагагүй багц буй бол кодны урд нь `#` тэмдгийг тавьж идэвхигүйжүүлж болно.

Тэмдэглэл:

-   Доор кодыг уншуулахаас өмнө **pacman** багцыг суулга. `install.packages("pacman")`-кодыг уншуулж татаж авч болно. Энэ багцын `p_load()` функц нь аливаа багцыг шаардлагатай тохиолдолд суулгаад *мөн* ачааллаад тухайн нээлттэй R дээр шууд ашиглахад бэлэн болгож өгдгөөрөө онцлог. Бид энэ номонд ихэвчлэн `p_load()` -ыг ашиглана. Харин **base** R-ын багцуудыг татаж авах шаардлагагүй ба `library()`--ыг шууд уншуулж, ажиллуулж болно.
-   Аливаа багцыг суулгахад хамт суулгагдаж/ачааллагддаг багцуудыг догол мөр, болон "хэш" тэмдгээр тэмдэглэсэн. Жишээ нь **ggplot2** багц бол **tidyverse** багцын харьяа юм.
-   Хэрэв функцын нэрс олон багцуудад давхардаж орсон бол тухайн функцыг ашиглах үед хамгийн сүүлд ачааллагдсан багцын функц ажиллана. Үүнийг *masking* гэх ба энэ талаар [R basics] хэсгээс нэмж уншна уу. Мөн **conflicted** багцыг ашиглаж ийм давхардалтыг шийдвэрлэж боломжтой.
-   [R basics] хэсгийн **pacman** болон masking гэсэн хэсгүүдийг уншна уу.

Энэхүү номыг боловсруулахад R, RStudio, болон R багцуудын хэддүгээр хувилбарыг ашигласан талаар [Editorial and technical notes] хэсгээс харна уу.

## CRAN -ын багцууд

```{r, eval=F}

##########################################
# Тархвар судлалын хэрэглээнд тохиромжтой R –ын багцууд
##########################################

# Энэхүү код pacman багцын p_load() функцыг ашигласан. Энэ нь аливаа кодыг уншуулахад шаардлагатай багц таньд суулгагдаагүй байгаа  тохиолдолд, тухайн багцыг суулгаад, шууд ачааллуулдаг функц.


# "pacman" багц суусан эсэхийг шалга!
if (!require("pacman")) install.packages("pacman")


# CRAN-аас татаж авах боломжтой багцууд
##############################
pacman::p_load(
     
     # R-ыг сурах
     ############
     learnr,   # RStudio Tutorial цонхон дээрх интерактив хичээл
     swirl,    # R console дээрх интерактив хичээл
        
     # R төсөл болон файлын менежмент
     #############################
     here,     # R төслийн үндсэн хавтастай холбоотой файлын зам
     rio,      # өгөгдлийн олон янзын хэлбэрийг импортлох/экспортлох 
     openxlsx, # олон хуудастай (sheet) Excel файлыг импортлох/экспортлох 
  
     # Багц суулгах
     ################################
     pacman,   # багц суулгаж/ачааллана
     renv,     # багаар хамтран ажиллахад багцын хувилбаруудыг тохируулна
     remotes,  # github –аас татаж авч суулгах

     # Өгөгдлийн ерөнхий менежмент  
     #########################
     tidyverse,    # өгөгдлийг цэгцтэй (tidy) байдалд оруулж янзлах, танилцуулахад зориулсан олон багцыг агуулсан 
          #dplyr,      # Өгөгдөл янзлах
          #tidyr,      # Өгөгдөл янзлах
          #ggplot2,    # График зураглал
          #stringr,    # string болон character хэлбэрийн өгөгдлийг янзлах
          #forcats,    # factor хэлбэрийн өгөгдөлтэй ажиллах
          #lubridate,  # dates хэлбэрийн өгөгдөлтэй ажиллах
          #purrr       # давтан үйлдэл болон list –тэй ажиллах 
     linelist,     # linelist хэлбэрийн хүснэгтийг цэвэрлэх
     naniar,       # өгөгдлийн дутуу утгыг шалгаж, үнэлэх 

    # Статистик анализ  
     ############
     janitor,      # хүснэгт болон өгөгдөл цэвэрлэх 
     gtsummary,    # дескрибтив болон статистикийн хүснэгт хийх 
     rstatix,      # статитистикийн тест болон статистикийн хураангуйг түргэн хугацаанд боловсруулна
     broom,        # регрессийн анализийн үр дүнг цэгцтэй хэлбэрт оруулах
     lmtest,       # likelihood-ratio тестүүд
     easystats,
          # parameters, # регрессийн анализийн үр дүнг цэгцтэй хэлбэрт оруулах (өөр хувилбар)
          # see,        # forest plots –ыг харуулаh өөр хувилбар
     
     # Тархвар судлалын математик загварчлал

     epicontacts,  # Халдварт өвчний тархалтын сүлжээг судлах 
     EpiNow2,      # Rt-г тооцох
     EpiEstim,     # Rt-г тооцох
     projections,  # Тохиолдлын тоог урьдчилан тооцоолх
     incidence2,   # Тархвар судлалын муруйг зурж, тохиолдлын тоог тооцох 
     i2extras,     # incidence2 багцын нэмэлт функцууд
     epitrix,      # тархвар судлалд хэрэглэгддэг нэмэлт функцууд
     distcrete,    # Discrete delay тархалт
     
    
     # График зураглал -ерөнхий
     #################
     #ggplot2,         # tidyverse багцын харьяа
     cowplot,          # графикуудыг нэгтгэх  
     # patchwork,      # графикуудыг нэгтгэх  (өөр хувилбар)     
     RColorBrewer,     # өнгө сонгох
     ggnewscale,       # өнгөний нэмэлт тохируулга хийх

    
     # График зураглал – тусгай зориулалтын
     ########################
     DiagrammeR,       # DOT хэлийг ашиглах бүдүүвч, диаграмм хийх
     incidence2,       # тархвар судлалын муруй
     gghighlight,      # тусгай хэсгийг тодотгож харуулах
     ggrepel,          # жижиг гарчиг
     plotly,           # интерактив график
     gganimate,        # хөдөлгөөнт график 

     
    # ГИС орон зайн анализийн чиглэлээр
     ########################
     sf,               # Simple Feature хэлбэрийг ашиглан орон зайн мэдээллийг янзлах
     tmap,             # энгийн газрын зураг боловсруулах (интерактив болон статик газрын зураг)
     OpenStreetMap,    # ggplot-ын газрын зурагт OSM –ын basemap оруулах 
     spdep,            # орон зайн статистик анализ 
     
     # Тайлан, бичиг баримт
     #################
     rmarkdown,        # PDFs, Word, Powerpoint, HTML -ын файлууд үүсгэх
     reportfactory,    # R Markdown –ын үр дүнг автоматаар зохицуулах
     officer,          # powerpoint-ын файлтай ажиллах

     # Хяналтын самбар, аппликэйшн
     ############
     flexdashboard,    # R Markdown –ын кодыг хяналтын самбар болгож хувиргах
     shiny,            # интерактив веб аппликейшн хийх
     
     # Илтгэл, тайлангийн хүснэгт гаргах
     #########################
     knitr,            # R Markdown –ын тайлан болон html-ын хүснэгт үүсгэх
     flextable,        # HTML –ийн хүснэгтүүд
     #DT,              # HTML –ийн хүснэгтүүд (өөр хувилбар)
     #gt,              # HTML –ийн хүснэгтүүд (өөр хувилбар)
     #huxtable,        # HTML –ийн хүснэгтүүд (өөр хувилбар) 
     
     # Филогенетикийн анализ
     ###############
     ggtree,           # модны график зураглал,тэмдэглэгээ хийх
     ape,              # филогенетикийн болон эволюцийн мэдээлэлтэй ажиллах 
     treeio            # филогенетикийн график зураглал хийх
 
)


```

## Github-ын багцууд

Дор бичсэн кодоор дараах хоёр багцыг Github --ын агуулахаас шууд татаж авна

-   Боловсролтын явцдаа буй **epicontacts** багц халдвар тархалтын модыг x-тэнхлэгт хугацаатайгаар харуулж өгдөг.
-   Энэхүү номны дасгалд ашиглах бүх өгөгдөл **epirhandbook** багцад буй. Мөн номын pdf хэлбэрийг татаж авч болно.

```{r, eval=F}
# Github- аас татаж авах багцууд (CRAN-д байхгүй)
##########################################################

# Боловсролтын явцдаа буй epicontacts багц (халдварын хэлхээг x-тэнхлэгт хугацаатайгаар харуулна)
pacman::p_install_gh("reconhub/epicontacts@timeline")

# Энэхүү номонд зориулсан багц (бүх дасгал, жишээг багтаасан) 
pacman::p_install_gh("appliedepi/epirhandbook")


```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/packages_suggested.Rmd-->


# R төсөл {}  

R төсөл нь таны файлуудын иж бүрдэл болсон зөөвөрлөхөд хялбар, бие даасан хавтас юм. Бүх скрипт код, дата файлууд, зураг/үр дүн, үйлдлийн түүх зэрэг нь R төсөл доторх дэд хавтсанд хадгалагддаг. Мөн R төслийн үндсэн хавтас *ажлын байрлал (working directory)* болж өгдгөөрөө онцлог.

## Санал болгож буй хэрэглээ
R-ыг үр өгөөжтэй, амархан, ердийн хэрэглээ болгохын тулд дараах гурван элементийг хавсарч хэрэглэдэг. *One discrete work project is hosted within one R project.* Элемент тус бүрийг дараах хэсгүүдэд тайлбарлав.


1) **R төсөл**  
     - өгөгдөл, код, үр дүн зэргийг тус бүр дэд хавтсанд агуулсан бие даасан ажлын орчин.
2) Файлын холбоотой замд зориулсан **here** багц  
     - Файлын зам R төслийн үндсэн хавтаст холбоотой байдлаар бичигддэг. Энэ талаар [Import and export] хэсэгт илүү дэлгэрүүлж үзнэ үү
3) Файл импорт/экспорт хийхэд зориулсан **rio** багц  
     - `import()` болон `export()` функцууд ямар ч өргөтгөлтэй файлтай ажиллаж чаддаг (.csv, .xlsx, .png г.м).  
     
     
<!-- ======================================================= -->
## R төсөл үүсгэх {}

R төсөл үүсгэхийн тулд File (файл) цэсний “New Project” (шинэ төсөл) -ыг сонго.

* Тухайн төсөлд зориулж шинэ хавтас нээх бол “New directory” (шинэ байрлал) –ыг сонгож хаана үүсгэхээ зааж өгнө.
* Төслийг хуучин хавтаст хадгалах бол “Existing directory” (хуучин байрлал) –ыг сонгож хадгалах хавтсаа зааж өгнө.
* Github –ын агуулахад файлаа хувилах бол “Version Control”-ыг сонгоод дараа нь “Git”-ыг сонгоно [Version control and collaboration with Git and Github] хэсгээс дэлгэрүүлж харж болно.


```{r out.width = "75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "create_project.png"))
```

Шинээр үүсгэсэн R төслийн хавтас *.Rproj* гэсэн өргөтгөлтэй файл агуулсан байна. Энэ файл нь тухайн төслийг нээх шууд холбоос болдог. Төслийг нээх өрр арга бол File цэснээс “Open Project” (төсөл нээх) –ийг сонгож болдог. Мөн RStudio-ын хамгийн баруун дээд буланд байрлах R төслийн лого болон арынх нь цэс дээр дарж болно. 

R төслөөс гарахдаа шинэ төсөл нээ эсвэл тухайн төслийг хаа (File - Close Project).


### Төслүүдийг сэлгэх {.unnumbered}

Төслүүдийн хооронд сэлгэж ажиллахын тулд RStudio-ын хамгийн баруун дээд буланд байрлах R төслийн лого болон арынх нь цэс дээр дар. Цэсийг нээснээр Close Project (төслийг хаах), Open Project (төслийг нээх) болон сүүлд ажиллаж байсан төслүүдийн нэр бүхий сонголтууд гарч ирнэ.


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Rproject_dropdown.png"))
```


### Тохируулга {.unnumbered}  


Rstudio-г асаахдаа "цэвэр хуудас" тайгаар эхлүүлэхийг зөвлөж байна. Өөрөөр хэлбэл өмнө нь хийж байсан ажлын код, бичиглэл ажлын талбайд **байхгүй** хоосон байна гэсэн үг. Энэ нь таны өмнө нь үүсгэсэн обьект, гарсан үр дүнгүүд R нээгдэх болгонд гарч ирэхгүй байхгүй байхыг хэлнэ (хэрэв шаардлагатай бол скрипт кодоо уншуулж дахин үүсгэж болно). Ингэснээр чанартай код бичигддэг ба хэтдээ алдаа бага гаргадаг. 

"Цэвэр хуудас"-аас эхлүүлэхийн тулд:

* Tools (багаж) цэснээс “Project Options”-г сонго.
* "General" хэсэгт буй сонголтуудад RStudio-г нээхэд .RData-г ажлын талбайд *хадгалахгүй*, RStudio-оос гарахад .RData -г ажлын талбайд *хадгалахгүй* гэж тохируул. 


### Бүтэц {.unnumbered}  

Төслийн үндсэн хавтас дотор дэд хавтас нээх нь элбэг. Ийм тохиолдолд “дата”, "скрипт/код", “зураг”, “илтгэл” гэх мэтээр хавтсаа нэрлэх нь тохиромжтой. Шинэ хавтсыг жирийн хавтас нээдэг шигээ үүсгэнэ. R коммандаар хэрхэн шууд шинэ хавтас үүсгэхийг [Directory interactions] хэсгээс харна уу.


### Хувилбаруудыг хянах {.unnumbered}  

Файлын өөр өөр хувилбаруудыг хянах системийг бий болгоорой. Үүний хамгийн энгийн жишээ гэвэл скрипттэй файлдаа огноотой нэр   (“transmission_analysis_2020-10-03.R” г.м) өгөөд "архив" дэд хавтаст хадгалах юм. Мөн скриптийн толгой хэсэгт (header) тайлбар, зохиогч, гарчиг, өөрчлөлтийн дугаар, нэр зэргийг оруулж болно.

Файлын хувилбарыг хянах арай нарийн арга бол Github болон бусад төстэй платформуудыг ашиглах юм. [Version control and collaboration with Git and Github] хэсгээс энэ талаар дэлгэрүүлж уншна уу.

Edit цэсний “Find in Files” -г сонгож төслийн бүх файлд хайлтыг зэрэг хийж болдог.  Энэ үйлдлээр зөвхөн хайгаад зогсохгүй аливаа текстийг олон файлуудад зэрэг өөрчлөх боломжтой. 


## Жишээ  


Доорх кодонд `here()` функцээр файл импортлох, экспортлох, хадгалах жишээ харуулав. **here** багцыг хэрхэн ашиглах талаар дэлгэрүүлж [Import and export] хэсгээс харна уу.


*R төслийн “data” хавтаснаас `linelist_raw.xlsx` гэсэн файлыг импортлох*  

```{r eval=F}
linelist <- import(here("data", "linelist_raw.xlsx"))
```

*`linelist`гэсэн R обьектийг “my_linelist.rds” гэсэн өргөтгөлтэйгээр өөрийн R төсөл доторх “data” хавтсын “clean” хавтаст экспортлох.*   

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.rds"))
```

*Хамгийн сүүлд үүсгэсэн графикийг “epicurve_2021-02-15.png” гэсэн нэртэйгээр өөрийн R төсөл доторх “outputs” хавтсын “epicurves” хавтаст хадгалах.*  

```{r, eval=F}
ggsave(here("outputs", "epicurves", "epicurve_2021-02-15.png"))
```


<!-- ======================================================= -->
##Эх сурвалж {}

RStudio –ын веб хуудсанд буй [using R projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects)





```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/r_projects.Rmd-->

# Файл импортлож экспортлох

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```

Энэ бүлэгт бид файлыг хэрхэн байрлуулж, импортлож, экспортлохыг тайлбарлана:

-   **rio** багц төрөл бүрийн файлыг хэрхэн чөлөөтэй `import()`, `export()` хийдэг эсэх;

-   **here** багцаар файлын байршлыг R төслийн үндсэн хавтастай хэрхэн холбоотойгоор заах;

-   Импортлох файлын төрлүүд:

    -   Excel--ийн sheet-үүд

    -   Цэгцгүй хүснэгтийн толгой болон мөр алгасах

    -   Google sheet-үүд

    -   Вебсайтад хэвлэгдсэн дата

    -   API -ууд

    -   *Хамгийн сүүлд* хэрэглэж байсан файлыг оруулах

-   Гараар өгөгдлийг оруулах

-   R файлын төрлүүд (RDS, RData)

-   Файл, графикыг хадгалж/экспортлох

<!-- ======================================================= -->

## Ерөнхий тойм

"Датасет" -ыг анх R -луу оруулахад R -ын орчинд шинэ *data frame* (хүснэгт) обьект үүсдэг. Үүнийг таны ажлын хавтсанд тодорхой хаяг/байршилтай, импортлогдсон (e.g. Excel, CSV, TSV, RDS) файл гэж үзнэ.

R -луу төрөл бүрийн өргөтгөлтэй файлаас гадна бусад статистикийн программ (SAS, STATA, SPSS) -ын файлыг бас оруулж болно. Мөн relational database (хамааралт өгөгдлийн санд)-т холбож болно.

R бас өөрийн өргөтгөлтэй:

-   RDS файл нь (.rds) нэг ширхэг R обьектийг хадгалдаг (ж: data frame). Ийм өртгөтгөлтэй файлын багана дах дата төрөл хэвээр хадгалдаг тул цэвэрлэгдсэн дата хадгалахад тохиромжтой. Энэ талаар [энэ хэсгээс](#import_rds) тодруулж үзнэ үү.

-   RData файл нь (.Rdata) хэд хэдэн обьект, эсвэл R workspace (ажлын талбай) -г бүтнээр нь хадгалдаг. Энэ талаар [энэ хэсгээс](#import_rdata) тодруулж үзнэ үү.

<!-- ======================================================= -->

## rio багц

**rio** багцаар импорт хийхэд их тохиромжтой. **rio** бол input/output (оролт/гаралт) -ын товчлол "R I/O" гэсэн үг юм.

Энэ багцын `import()`, `export()` функцууд төрөл бүрийн файлтай ажиллаж чаддаг (e.g. .xlsx, .csv, .rds, .tsv) . Эдгээр функцэд файлын байршлыг (өргөтгөлтэй нь хамт) зааж өгснөөр **rio** багц тухайн өргөтгөлд шаардлагатай тохируулгыг хийж, файл импортлогдож, экспортлогддог.

**rio** багцгүйгээр дээрх үйлдлийг хийхэд хэд хэдэн багц хамт ажиллах шаардлага гардаг. Багц болгон тус бүр өөр өргөтгөлийг уншина. Жишээ нь `read.csv()` (**base** R), `read.xlsx()` (**openxlsx** багц), `write_csv()` (**readr** багц) гэсэн функцууд байдаг. Эдгээрийг тэр болгон санаж хэрэглэхэд бэрхшээлтэй. Харин **rio** -ын `import()`, `export()` энэ үйлдлийг хялбар болгодог.

**rio**-ын `import()`,`export()` функцууд тухайн файлын өргөтгөлд шаардлагатай багцыг давхар дуудаж ажилуулдаг. **rio**-ын цаана нь давхар ажиллаж байдаг эдгээр багцыг бүлгийн төгсгөлд хүснэгтэд жагсааж харуулав. **rio** багц STATA, SAS, SPSS программын файлыг мөн зөөвөрлөдөг.

Харин shapefiles--г зөөвөрлөхөд өөр багц шаардлагатай. Энэ талаар [GIS үндсэн ойлголтууд](#GIS%20basics) хэсэгт дэлгэрэнгүй дурьдсан.

## **here** багц {#here}

Аливаа файлыг хаанаас олох, хаана хадгалахаа R-т хэлж, файлын зам үүсгэх үйлдлийг **here** багц, түүний `here()` функцээр хялбархан гүйцэтгэж болдог.

**here** багц R төсөл дэх файлуудын байршлыг тухайн R төслийн үндсэн хавтастай (хамгийн дээд түвшний хавтас) холбоотойгоор зааж өгдөг. R төслийг олон компьютерт дамжуулан хэрэглэж байхад дээрх үйлдэл их хэрэгтэй. **here** багц бүх хэрэглэгчдэд нийтлэг байршилтайгаар (R төслийн үндсэн хавтас) файлын замыг заадаг ба ингэснээр файлын зам компьютер болгонд өвөрмөц бичигдсэнээс болж үүсдэг хүндрэлээс сэргийлж чаддаг (жишээ нь "C:/Users/Laura/Documents...") .

R төсөлд `here()` -ын ажиллах зарчим:

-   Анх **here** багцыг ачаалах үед R төслийн үндсэн хавтас дотор ".here" гэсэн жижиг файл автоматаар үүсгэгдэж "чиглүүлэх", "холбох" үүрэг гүйцэтгэдэг.

-   R төслийн аль нэг дэд хавтаст файл хадгалахаар код бичих үед `here()` функцээр файлын зам үүсгэж энэхүү *чиглүүлэгчид холбож өгдөг*.

-   Файлын зам үүсгэхдээ *үндсэн хавтсан доторх* хавтаснуудын нэрсийг хашилт дотор оруулж, таслалаар тусгаарлаж бичих ба файлын нэрийг өргөтгөлтэй нь хамт бичнэ. Дор жишээ харуулав.

-   `here()` файлын замыг импорт, экспортын аль алинд нь ашиглаж болно.

Дараах `import()` функц дотор `here()` -ээр файлын зам бүтээсэн.

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

`here("data", "linelists", "ebola_linelist.xlsx")` гэсэн комманд үнэн хэрэг дээрээ *тухайн хэрэглэгчийн компьютерт өвөрмөц* файлын бүтэн замыг илэрхийлж байдаг:

    "C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"

`here()` -ээр бичигдсэн энэхүү комманд нь ямар ч компьютер байсан тухайн R төслийг олж чаддагаараа давуу талтай.

[***ЗӨВЛӨГӨӨ:*** ".here" файл хаана байрлаж буйг `here()` функцыг хоосон хаалттайгаар уншуулснаар олж болно.]{style="color: darkgreen;"}

**here** багцын талаарх дэлгэрэнгүй мэдээллийг [энэ линкээс](https://here.r-lib.org/) уншина уу.

<!-- ======================================================= -->

## Файлын зам

Датаг импортлож, экспортлоход тухайн файлын замыг зааж өгөх шаардлагатай. Үүнийг дараахь гурван аргаар хийх боломжтой:

1.  *Санал болгож буй арга*: **here** багцыг ашиглан файлын "холбоотой (relative)" замыг олно.

2.  Файлын "бүтэн" буюу "жинхэнэ (absolute)" замыг бичиж өгнө.

3.  Гараар (manuel) файлыг сонгох

### Файлын "холбоотой (relative)" зам {.unnumbered}

"Холбоотой (relative)" зам гэдэг нь файлын зам R төслийн үндсэн хавтастай холбоотой байхыг хэлнэ. Ингэснээр өөр компьютер дээр ажилласан ч файлыг хялбар олж болохуйц файлын замыг үүсдэг (жишээ нь R төслийг имэйлээр илгээх, эсвэл дундын драйв дээр ашиглах зэрэгт хэрэгтэй). [Дээр](#here) дурьдсанчлан "холбоотой (relative)" байршлыг зааж өгөхдөө **here** багцыг ашиглана.

`here()`-ээр файлын холбоотой замыг бичих жишээ дор харуулав. Жишээнд R төслийн үндсэн хавтаст "data" гэсэн хавтас байх ба энэ хавтаст дахиад дэд хавтас болох "linelists" гэсэн хавтас байгаа ба үүн дотор бидний ажиллах .xlsx өргөтгөлтэй файл байна.

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

### Файлын "жинхэнэ" зам {.unnumbered}

Файлын "бүтэн" замыг `import()` болон бусад төстэй функцэд оруулж өгч болдог. Гэвч энэ нь зөвхөн тухайн ажиллаж буй компьютерт л өвөрмөц зам үүсдэг тул *энэ аргыг хэрэглэхгүй байхыг зөвлөж* байна.

Файлын жинхэнэ замын жишээг дор харуулав. Энд Лаурагийн компьютер дэх "analysis" дэд хавтаст буй "data" дэд хавтас дотор "linelists" гэсэн дэд хавтас байна. Үүн дотор бидний ажиллаж буй .xlsx өргөтгөлтэй файл байрлаж байна.

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

Файлын жинхэнэ замыг ашиглахад анхаарах зүйлс:

-   Өөр хүний компьютер дээр ажиллах үед файлын байршлын холбоос эвдэрдэг тул аль болох **файлын жинхэнэ замыг хэрэглэхээс зайлсхий.**

-   Урагшаа чиглэлтэй ташуу зураасыг (`/`) ашигла (Windows-д байнга хэрэглэгддэг ташуу зурааснаас ӨӨР болохыг анхаар)

-   Давхар ташуу зураасаар ( "//..." гэх мэт) эхэлдэг файлын зам **R программд танигддахгүй** байх өндөр магадлалтай ба ихэвчлэн алдаа заадаг. Ажлаа "нэртэй" эсвэл "J:", "C:" гэх мэт үсгээр дугаарласан дискэнд хадгалахыг зөвлөж байна. Энэ талаар [Directory interactions] хэсгээс нэмж тодруулна уу.

Дундын драйв дээрээс файл импортлоход тухайн файлын жинхэнэ зам бүх хэрэглэгчдэд яг адилхан бичигдсэн тохиодолд файлын жинхэнэ замыг ашиглаж болдлг.

[***ЗӨВЛӨГӨӨ:*** `\` тэмдэгтийг `/`-ээр түргэн солихын тулд Ctrl+f (Windows) дарж гарах цэснээс "In selection"-г сонго. Үүний дараа тэмдэгт солих үйлдэл хийж нэг дор солих боломжтой.]{style="color: darkgreen;"}

<!-- ======================================================= -->

### Гараар байршлыг сонгох {.unnumbered}

Гараар дата импортлоход дараах аргуудыг хэрэглэж болно:

1.  RStudio--ын Environment (орчин) табны "Import Dataset" (датасетийг импортлох)-г дарж, гарсан цэснээс дата төрлийг сонго.

2.  File/Import Dataset -г дарж өгөгдлийн төрлийг сонго.

3.  *base R*-ын `file.choose()` функцыг хоосон хаалттайгаар уншуулахад **pop-up цонхыг** гарч ирэх ба энэ үед компьютерээсээ файлыг гараар сонго. Жишээ:

```{r import_choose, eval=F}
# Гараар файл сонгох. Дараах коммандыг уншуулахад POP-UP цонх нээгдэнэ
# Гараар сонгосон файлын зам import() командын дотор бичигддэг.

my_data <- import(file.choose())
```

[***ЗӨВЛӨГӨӨ:*** **Pop-up цонх** RStudio-гийн цонхны АРД нээгдсэн байж болохыг анхаар.]{style="color: darkgreen;"}

## Дата импортлох

`import()`функцээр датасетийг хялбар импортлодог. Хаалтан дотор файлын замыг (файлын нэр өргөтгэлтэй нь хамт) хашилтанд оруулж бичихэд болно. Хэрэв `here()`-ээр файлын замыг зааж өгөх бол дээр дурьдсан жишээг харна уу. Дор жишээнүүд харуулав:

Таны "working directory" (ажлын хавтас)-д эсвэл R-ын үндсэн хавтаст байрлах csv файлыг оруулах:

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```

R төсөл дэх "data" хавтсын "linelists" дэд хавтаст буй Excel файлын эхний sheet--ийг оруулах (файлын замыг `here()`-ээр зааж өгсөн):

```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```

Файлын жинхэнэ байршлыг дуудаж датаг (.rds файл) импортлох:

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```

### Excel-ийн sheet- тэй ажиллах {.unnumbered}

Excel (.xlsx) файлыг `import()`-д импортлох үед default-оор эхний sheet импортлогддог. Өөр **sheet** --импортлох шаардлагтай тохиолдолд `import()` функцын `which=` аргументэд sheet-ийн нэрийг бич. Жишээ нь:

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

Файлын холбоотой замыг `here()`-ээр бичиж `import()` -д оруулаад `here()`--ийн хаалтыг хаасны дараа нэмэлтээр `which =` аргумент өгч үүндээ тухайн sheet --ийн нэрийг зааж өгдөг.

```{r import_sheet_here, eval=F}
# Файлын холбоотой замыг 'here' -ээр дууудаж Excel sheet-ийг импортлох
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

R --ын хүснэгтийг Excel -ийн аль нэг sheet рүү (бусад sheet-ийг өөрчлөлгүйгээр ) *экспортлох* бол тусгай зориулалтын **openxlsx** гэх мэт багц ашигладаг. Энэ талаар [Directory interactions] эсвэл [at this github page](https://ycphs.github.io/openxlsx/) хэсгээс харна уу.

Excel-ийн .xlsb (binary хэлбэртэй Excel файл) файлыг **rio** багцаар импортолж болдоггүй. Ийм тохиолдолд .xlsb файлаа .xlsx болгон хувиргаж хадгалдаг. Эсвэл [this purpose](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html) энэ зориулалтын **readxlsb** багцыг ашигладаг.

<!-- ======================================================= -->

### Дутуу утга {#import_missing .unnumbered}

Дата дах дутуу утгуудыг зааж өгөх шаардлага гардаг. R дутуу утгыг `NA` гэж бичдэг ([Missing data] гэсэн хэсэгт заасан). Харин таны датанд дутуу утгыг 99, "Дутуу", эсвэл хоосон зайгаар тэмдэглэсэн байх тохиолдол байдаг.

Ийм үед `import()` дотор `na =` -аргумент нэмж өөрийн дата дах дутуу утгын тэмдэглэгээг хашилтад оруулан бичнэ (тоогоор тэмдэглэсэн байсан ч гэсэн). Янз бүрийн дутуу утгуудыг зэрэг зааж өгөх бол `c()`функц ашиглан вектор хэлбэрээр оруулж болдог. Жишээг дор харуулав.

Жишээнд импортолж буй датанд дутуу утгыг "99" --ээр тэмдэглэсэн ба R -д оруулахдаа `NA` болгож хувиргаж байна.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Энэ жишээнд импортолж буй датаны "Дутуу", "" (хоосон нүд), эсвэл " "(нэг зай) гэж бичигдсэн бүх утгуудыг R-т `NA` болгож хувиргаж байна.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```

<!-- ======================================================= -->

### Мөр алгасах {.unnumbered}

Зарим мөрийг оруулалгүйгээр дата импортлох шаардлага гардаг. Үүнийг **rio** -ын `import()` функцийн `skip =` аргументийн тусламжтайгаар хйидэг (.xlsx зэрэг .csv файлтай ажиллаж буй үед). Ингэхдээ алгасах мөрийн тоог зааж өг.

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # толгой (header) мөрийг оруулалгүйгээр импортлоно
```

`skip =` зөвхөн нэг бүхэл тоон утга л авдаг ба дараалласан хэд хэдэн тоон утга оруулж **болдоггүй** (жишээ нь "2:10" гэх боломжгүй). Хүснэгтийг эхнээс дараалласан биш, энд тэнд байрлалтай мөрүүдийг алгасах бол датаг дахин импортлоод **dplyr** -ын `bind_rows()`--ыг хэрэглэдэг. Доор жишээнд ердөө 2 мөр алгасахыг харуулав.

### Хоёр дах толгой (header) мөртэй ажиллах {.unnumbered}

Заримдаа хүснэгтийн толгой хоёр мөрнөөс бүтсэн байдаг. Жишээ нь датаны "нэрсийн тайлбар" --ийг хоёр дах нүдэнд биччихдэг. Ийм датаг тэр чигээр нь импортловол бүх багана "character" хэлбэртэй болж хувирах эрсдэлтэй.

```{r, echo=F}
# УНШИГЧААС НУУЦ
####################
# хүснэгтийн хоёр дах толгойд "нэрсийн тайлбар"-ыг бичиж 2 дах мөрөнд байрлуул; 2. Хүснэгт болгож хадгал.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Ийм датасетын жишээг дор харуулав (эхний мөрөндөө нэрсийн тайлбартай).

```{r message=FALSE, echo=F}
# linelist датаг хүснэгтээр харуул
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Хоёрдах толгой мөрийг арилгах {.unnumbered}

Дата импортлох үйлдлийг хоёр давтан хийснээр хоёр дах мөрийг арилгах боломжтой.

1) Датаг импортлоод баганын жинхэнэ нэрийг хадгал\
2) Датаг дахин импортлох ба ингэхдээ эхний *хоёр* мөрийг (толгой мөр, 2 дах мөр) алгасч оруул\
3) Эхэнд хадгалсан баганын нэрсээ мөр алгассан хүснэгтдээ холбож өг.

Баганын нэрийг хүснэгттэй холбодог үйлдлийн аргумент дата төрлөөс хамаарч өөр байдаг ( жишээ нь .csv, .tsv, .xlsx,). Энэ нь файлын төрлөөс хамаарч **rio** багц өөр функц ашигладагтай холбоотой. (дээрх хүснэгтээс харна уу).

**For Excel files:** (`col_names =`)

```{r, eval=F}
# Эхний удаагийн импорт хийх үйлдлээр зөвхөн нэрсийг хадгал;
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # баганын нэрсийг хадгал

# Датаг дахин импортло; эхний 2 мөрийг алгасаад col_names = аргументэд өмнөх хадгалсан нэрсээ заа.
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**For CSV files:** (`col.names =`)

```{r, eval=F}
# Эхний удаагийн импорт хийх үйлдлээр зөвхөн нэрсийг хадгал;
linelist_raw_names <- import("linelist_raw.csv") %>% names() # баганын нэрсийг хадгал

# csv файлын аргумент 'col.names = ' болохыг анхаар
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Нэмэлт хувилбар** - баганын нэрийг тусдаа коммандаар өөрчилж болно.

```{r, eval=F}
# R base –ийн 'colnames()' функцээр хүснэгтийн толгойд дахин нэр онооно.
colnames(linelist_raw) <- linelist_raw_names
```

#### Датанд нэрсийн тайлбар толь (data dictionary) үүсгэх {.unnumbered}

Бонус! хоёр дах мөрөнд нэрсийн тайлбар бичигдчихсэн байвал үүнийг нэрсийн тайлбар багана болгож хувиргах амархан. Энэ санааг [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/) -д тайлбарласан байсан.

```{r}
dict <- linelist_2headers %>%             # эхлэл: эхний мөрөндөө тайлбартай linelist
  head(1) %>%                             # зөвхөн баганын нэрс болон нэрсийн тайлбарыг авч үлд
  pivot_longer(cols = everything(),       # бүх баганыг урт хэлбэрт шилжүүл
               names_to = "Column",       # шинэ үүссэн хоёр баганад нэр өг
               values_to = "Description")
```

```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Хоёр толгой мөрийг нэгтгэх {.unnumbered}

Хэрэв датасет боловсруулалт хийхээс өмнө *хоёр* толгой мөртэй байвал (баганын туслах гарчиг хоёр дах мөрөнд бичигдсэн г.м) "нэгтгэх", эсвэл хоёр мөрөн дэх утгыг хооронд нь нийлүүлэх шаардлага гардаг.

Дараах коммандыг өгснөөр эхний болон түүний дорх мөр нэтгэгдэж (paste) баганын нэр болж импортлогддог.

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```

<!-- ======================================================= -->

### Google sheet-үүд {.unnumbered}

Google-ийн онлайн spreadsheet-ийг **googlesheet4** багцаар импортлодог. Энэ үед мөн хандах эрхээ баталгаажуулах шаардлагатайг анхаар.

```{r, eval=F}
pacman::p_load("googlesheets4")
```

Google sheet оруулах жишээг дор харуулав. Энэхүү коммандыг уншуулхад google account --ыг баталгаажуулах хүсэлт гарч ирдэг. Интернетийн браузерт гарч ирсэн цонх, pop-up -г дагаж биелүүлсний дараа Tidyverse API- багцууд таны Google Drive дээрх хүснэгтийг засаж, арилгах шинээр үүсгэх зөвшөөрөлтэй болдог.

Дорх хүснэгт "линкээр орсон хүн болгон үзэх боломжтой" ("viewable for anyone with the link") гэсэн тохируулгатай учир та импортлож үзэж болно.

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

Тухайн sheet -ийн ID -г зааж өгсний дараа импортлогддог. ID нь URL-ын богино хэсэгт байрладаг:

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```

Дээрхтэй ижил үйлдэл хийдэг өөр нэгэн багц бол **googledrive**. Үүнийг ашиглаж Google sheet-ийг янзалж, арилгаж, шинээр үүсгэж болно. Энэ багцад `gs4_create()`,`sheet_write()` гэх мэт функцууд байдаг.

Энэ талаар дэлгэрүүлж заасан хичээл, материалуудыг дараах линкүүдээс үзнэ үү:\
[basic Google sheets importing tutorial](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)\
[more detailed tutorial](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)\
[interaction between the googlesheets4 and tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)

## Олон файлтай зэрэг ажиллах - импорт, экспорт, хуваах, нэгтгэх

Олон файлыг зэрэг импортлох, нэгтгэх, эсвэл олон Excel файлтай зэрэг ажиллах жишээг [Iteration, loops, and lists] хэсгээс харна уу. Энэ линкэд мөн хүснэгтийг хэрхэн хуваах, хуваасан хэсэг тус бүрийг экспортлох, Excel-ийн тусгай sheet болгон хадгалах талаар тайлбарласан.

<!-- ======================================================= -->

## Github-аас файл импортлох {#import_github}

Github-аас шууд R-луу дата импортлох нь хялбар, цөөн үйлдэлтэй байдаг. Дараах аргуудаар импортлоно:

### CSV файл {.unnumbered}

Github-аас .csv файлыг R-луу шууд R коммандаар хялбар импортлодог.

1)  Github --ийн агуулахыг нээнэ, импортлох файлаа байрлуулаад дээр нь дар\
2)  "Raw" товчийг дар ("raw" csv гэсэн дата харагдна, доор харуулав)\
3)  URL (вебхаяг)-г хуулж ав\
4)  Хуулсан URL --г хашилттанд хийж `import()` функцэд оруулж уншуул

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### XLSX файл {.unnumbered}

Зарим файл дах "Raw" датаг харж болдоггүй (.xlsx, .rds, .nwk, .shp гэх мэт).

1) Github --ийн агуулахыг нээ, импортлох файлаа байрлуулаад дээр нь дар

2) "Download" товчийг дар (доор зурагт харуулснаар)

3) Файлыг компьютертээ хадгалаад дараа нь R -луу импорт хий.

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered}

Shapefiles файл олон дэд бүрэлдэхүүн хэсгүүдтэй ба хэсэг тус бүр өөр өргөтгөлтэй. Нэг файл ".shp" гэсэн өргөтгөлтэй байхад нөгөө файл ".dbf", ".prj" гэх мэтээр өөр байдаг. Github-аас shapefile татахад дэд бүрэлдэхүүүн бүрийг тусдаа татаж аваад өөрийн компьютерт *ижил* хавтаст хийж хадгал. Github дээрх файл тус бүрийг "Download" товчийг дарж нэг бүрчлэн татаж ав.

Компьютерт хадгалагдсны дараа **sf** багцын `st_read()`--ээр shapefile --аа импорт хийнэ ([GIS basics] хэсэгт заасан буй). Та зөвхөн файлын зам болон ".shp" файлынхаа нэрийг зааж өгөхөд л болно (тухайн ".shp файлтай холбоотой бусад файлууд ижил хавтаст байрлаж байх шаардлагатай).

Дор жишээнд "sle_adm3" гэх shapefile олон янзын файлаас хэрхэн бүрэлддэгийг харуулав. Файл болгоноо Github -аас тусдаа татаж авах шаардлагатай.

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```

<!-- ======================================================= -->

## Гараар дата оруулах

### Мөр болгоноор оруулах {.unnumbered}

**tidyverse** багцуудын нэг **tibble** багцын `tribble` функцийг хэрэглэ ([online tibble reference](https://tibble.tidyverse.org/reference/tribble.html)).

Баганын толгой *tilde* (`~`) тэмдэгтээр эхэлж буйг анхаар. Мөн багана болгон нэг төрлийн дата агуулсан байна (character, numeric гэх мэт.). Кодыг хялбар уншигддаг болгох үүднээс таб, зай авах, шинэ мөр эхлэх зэргээр кодоо тохируулж болно. Утга хооронд зай авах нь чухал биш, харин мөр болгоныг шинэ мөрнөөс эхэлж бичих хэрэгтэй. Жишээ:

```{r import_manual_row}
# датасетийг гараар мөр дагуу бичих
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

Үүсгэсэн хүснэгт дараах байдлаар харагдна::

```{r, echo=F}
# үүсгэсэн шинэ датасетээ харуулах
DT::datatable(manual_entry_rows)
```

### Багана дагуу дата оруулах {.unnumbered}

Хүснэгт нь векторуудаас бүтдэг (вертикал багана) учир **base** R таныг багануудаа эхлэж үүсгээд дараа нь нэгтгэнэ гэж ойлгодог. Харин тархвар судлалын хувьд датаг ихэвчлэн эхэлж мөрийн дагуу оруулдаг онцлогтой (дээрх жишээ).

```{r import_manual_col}
# Бүх векторыг багана бүрээр бичиж оруул; багана бүрт нэр өг
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

[***АНХААРУУЛГА:*** Бүх векторууд ижил урттай байх шаардлагатай (ижил тооны утгатай).]{style="color: orange;"}

Векторуудыг `data.frame()` функцээр нэгтгэдэг:

```{r}
# Векторын нэрсийг data.frame -д оруулснаар хүснэгт нэгтгэгднэ.
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

Үүсгэсэн хүснэгт нь дараах байдлаар харагдна:

```{r, echo=F}
# үүсгэсэн шинэ датасетээ харуулах
DT::datatable(manual_entry_cols)
```

### Clipboard-оос хуулж авах {.unnumbered}

Clipboard -д хуулж авсан датаг дараах хоёр аргаар импорт хийдэг.

**clipr** багцын `read_clip_tbl()`--ыг ашиглан хүснэгт хэлбэрээр,`read_clip()`--ээр character хэлбэрээр импортлоно. Энэ хоёр функцын хаалтыг хоосон орхи.

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # clipboard дах датаг хүснэгт хэлбэрээр импорт хий 
linelist <- clipr::read_clip()      # character хэлбэрээр импорт хий
```

Системийн clipboard-д хуулагдсан бол **clipr**-ийг ашиглан амархан экспортолж болно. Экспорт хэсэгт дэлгэрүүлж бичсэн.

Мөн **base** R-ын `read.table()`--д `file ="clipboard"` гэсэн аргумент өгюөл дата хүснэгт хэлбэрээр импортлогддог.

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # "clipboard"-ийн файл гэдгийг заана
  sep = "t",           # tab, таслал зэргээр тусгаарлагчийг заана.
  header=TRUE)         # баганын эхний мөр толгой мөр мөн эсэхийг заана
```

## Хамгийн сүүлд хэрэглэж байсан файлыг импортлох

Та датанд тогтмол өөрчлөлт оруулдаг бол хамгийн сүүлд хэрэглэж байсан файлыг импортлодог код хэрэгтэй байдаг. Үүнийг гүйцэтгэх хоёр янзын арга буй:

-   файлын нэр дээрх огнооны дагуу файлыг сонгох\
-   файлын метадатан дах огнооны дагуу файлыг сонгох (хамгийн сүүлд хийсэн өөрчлөлтийн огноо)

### Файлын нэр дээрх огноо {.unnumbered}

Үүнийг хийхэд дараах гурван нөхцөл бүрдсэн эсэх хамаатай:

1.  Файлын нэр дээр бичигдсэн огноонд итгэлтэй байх
2.  Огноо тоогоор бичигдсэн ба *ерөнхийдөө* ижил форматтай байна (дараалал нь жил, сар, өдөр гэх мэт)
3.  Файлын нэрэнд тоогоор огнооноос өөр зүйл тэмдэглээгүй байх.

Бид энд алхам бүрийг тайлбарласны дараа нэтгэж харуулав.

Эхлээд **base** R-ын `dir()`-- ийг хэрэглэж, сонгосон хавтас доторх файлын зөвхөн нэрсийг авна. [Directory interactions] хэсгээс `dir()` --ийн талаар харна уу. R төслийн хавтас дах "data" хавтасны "example" хавтсанд буй "linelists" хавтсыг хэрхэн дуудахыг дор жишээнд харуулав.

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # хавтсан дах файлын нэрсийг ав
linelist_filenames                                              # хэвлэ
```

Файлын нэрсийг вектор болгож авсны дараа огноотой хэсгийг салгаж авахын тулд **stringr** багцын `str_extract()`-т дараах regular expression-г оруулж комманд өгнө. Энэ коммандаар файлын нэрэнд буй тоотой бүх хэсгийг салгаж авч болно (дунд нь орсон зураас, ташуу зураас зэргийг оруулаад). **stringr** багцын талаар дэлгэрүүлж [strings болон characters] -аас уншиж болно.

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") #тоо болон тэмдэгтүүдийг салгаж авна.
linelist_dates_raw  # хэвлэ
```

Файлын нэрэн дээрх огнооны формат ижил төстэй (дараалал нь жил, сар, өдөр гэх мэт ), жил нь 4 цифртэйгээр бичигдсэн байвал, **lubridate** багцын хувиргагч функцуудыг (`ymd()`,`dmy()`, `mdy()`) ашиглан амархан хувиргалт хийж болдог. Эдгээр функц зураас, ташуу зураас, хоосон зай зэргийг ажралгүй зөвхөн огнооны дэс дараалаллыг анхаардаг. Энэ талаар [Working with dates] хэсгээс нэмж үзнэ үү.

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```

**base** R -ын `which.max()`-аар огноонуудын индекс байрлалаас (1 дүгээр, 2 дугаар, 3 дугаар) хамгийн ихийг нь дууддаг. Дор жишээнд "case_linelist_2020-10-08.xlsx"-ыг (хамгийн сүүлд хэрэглэсэн файл) 6 дугаар файл гэж зөв дугаарлагдсан байна.

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

Эдгээр коммандыг нэгтгэж доор харуулав. Энэхүү pipe дараалаллын төгсгөлд тухайн pipe -аар бичигдэж буй обьектийг илэрхийлэхдээ `.` тэмдэгтээр бичсэнийг анхаарна уу. Энэ үед бичигдэж буй обьект 6 гэсэн тоо . `dir()` --ээр үүсгэгдсэн файлын нэрстэй векторын 6 дугаар элэментийг гаргаж авахын тулд дээрх тэмдэглэгээг давхар хаалтанд оруулж бичсэн, .

```{r}
# Багцуудыг ачааллах
pacman::p_load(
  tidyverse,         # дата менежмент
  stringr,           # strings/characters-тай ажиллах
  lubridate,         # огноотой ажиллах
  rio,               # импорт / экспорт
  here,              # файлын холбоотой зам
  fs)                # файлын байрлалуудын харилцан үйлчлэл

# сүүлийн хэрэглэсэн файлын нэрийг салгаж ав
latest_file <- dir(here("data", "example", "linelists")) %>%  #файлын нэрсийг "linelists" дэд хавтаснаас ав               
  str_extract("[0-9].*[0-9]") %>%       # нэрнүүд дэх огноог салгаж ав (тоогоор бичигдсэн)
  ymd() %>%                             # тоон утгыг огноо болго (жил-сар-өдөр форматтай тохиолдолд)
  which.max() %>%                   # хамгийн их огнооны индекс байрлал (хамгийн сүүлд хэрэглэсэн файл)
  dir(here("data", "example", "linelists"))[[.]]          # хамгийн сүүлд хэрэглэсэн linelist-ийн файлын нэрийг дуудах

latest_file  # сүүлд хэрэглэсэн файлын нэрийг хэвлэ
```

Одоо энэхүү нэрээ `here()` багцад оруулж тухайн файлын холбоотой замыг гүйцээж бич:

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

Одоо хамгийн сүүлд хэрэглэж байсан файлыг импортлох боломжтой:

```{r, eval=F}
# импорт
import(here("data", "example", "linelists", latest_file)) # импорт
```

### Файлын метадата ашиглах {.unnumbered}

Та файлын нэрэн дээр огноо бичээгүй (эсвэл та нэрэн дээрх огноонд итгэлгүй) тохиолдолд тухайн файлын метадатанаас хамгйин сүүлд ашигласан огноог олж болно. Файлын сүүлд ашигласан огноо, файлын зам зэрэг мэдээллийг шалгахдаа **fs** багцын функцээс хэрэглэдэг.

Дараах жишээнд сонгосон хавтсыг **fs**-ын `dir_info()` -д оруулж бичсэн. Сонгосн хавтас нь R төслийн хавтсан дах "data" хавтасны "example" дэд хавтас доторх "linelists" хавтас юм. Ингэснээр файл тус бүрт нэг мөртэй, `modification_time`,`path` (файлын метадата) гэсэн багануудтай хүснэгт бий болно. [Directory interactions] --д жишээг илүү дэлгэрэнгүй харуулсан.

Үүний дараа хүснэгийг `modification_time` --аар нь эрэмбэлээд **base** R-ын `head()` -ээр зөвхөн эхний мөр буюу хамгийн сүүлд ашигласан файлтай мөрийг авч үлдэж болно. Дараа нь хүснэгтийн `path` баганыг **dplyr** -ын `pull()`--д оруулж сүүлд хэрэглэсэн файлын замыг гаргаж авна. Эцэст нь энэ файлын замыг `import()`-д оруулна. Импортлогдсон файлыг `latest_file` гэж хадгална.

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # энэ байршилд буй бүх файлын метадатаг цуглуул 
  arrange(desc(modification_time)) %>%      # өөрчлөлт оруулсан хугацаагаар нь эрэмблэ
  head(1) %>%                               # зөвхөн толгой мөрийг авч үлд
  pull(path) %>%                            # зөвхөн файлын замыг авч үлд
  import()                                  # файлыг импорт хий

```

<!-- ======================================================= -->

## APIs {#import_api}

Автомат Программчлагдсан Интерфэйс (Automated Programming Interface) (API) --ыг ашиглан дата авах хүсэлтийг шууд вебсайтад нь явуулдаг. API гэдэг нь программ бие биетэйгээ харилцан үйлчлэх боломжийг бүрдүүлж буй дүрмийн багцыг хэлнэ. Үйлчлүүлэгч (та) "хүсэлтээ" илгээсний дараа мэдээлэл агуулсан "хариуг" хүлээж авдаг. R дээр **httr**, **jsonlite** багцууд энэ үйлдлийг гүйцэтгэдэг.

API -г идэвхижүүлсэн вебхуудас бүр өөрийн дүрмийг танилцуулсан байдаг. Зарим вебхуудас нийтэд нээлттэй, хэн ч авч болохоор байхад зарим вебсайт ялангуяа ID, нууц үг хэрэглэдэг платформуудаас мэдээлэлэл авахын тулд баталгаажуулалт хэрэгтэй байдаг.

API --аар мэдээлэл импортлоход мэдээж сүлжээнд холбогдсон байна. API ашиглан мэдээлэл импортлохыг товч жишээгээр харуулж, нэмэлт линкийг дор бичлээ.

*Тэмдэглэл: мэдээлэл вебхуудаст ямар ч API гүйгээр тавигдсан*\* *байж болох* ба ийм тохиолдолд татаж авахад хялбар байх талтай. Жишээ нь сайтын URL-г `import()` дотор оруулснаар CSV файлыг шууд татаж авах боломжтой байж болно. Энэ талаар [importing from Github](#import_github) -д мөн дурьдсан\*

### HTTP request {.unnumbered}

API солилцоог ихэвчлэн HTTP хүсэлтээр гүйцэтгэдэг. HTTP гэдэг нь Hypertext Transfer Protocol --ын товчлол. Энэ бол үйлчлүүлэгч, сервер хоёрын хүсэлт/хариу солилцон явуулахад ашигладаг үндсэн формат юм. API -ын төрлөөс хамаарч оролт/гаралт (input/output) нь бага зэрэг өөр байх боловч үндсэн процесс нь адил. Энэ нь хэрэглэгчээс ирж буй лавлагаа, асуумжтай "Хүсэлт" (ихэвчлэн HHTP хүсэлт) ба хүсэлтийн статус, хариу мэдээллийг агуулсан "Хариулт"-аас бүрддэг.\
*HTTP хүсэлтийн* зарим бүрдэл хэсгүүд:

\- API -ын эцсийн цэгийн URL\
- "Аргачлал" (эсвэл "Үйл үг")\
- Толгой хэсэг\
- Бие хэсэг

HTTP хүсэлтийн "аргачлал" гэдэг нь таны үйлдэх гэж буй үйлдлийн нэр. Нийтлэг хэрэглэгддэг хоёр HTTP аргачлал бол `GET` болон `POST`. Бусад аргачлалд `PUT`,`DELETE`,`PATCH` зэрэг орно. R -луу дата импорт хийхэд ихэвчлэн `GET`-ийг хэрэглэдэг.

Хүсэлт гаргасны дараа таны компьютер хариуг хүлээж авна. Ирэх хариулт таны илгээсэн мэдээлэлтэй төстэй форматаар буцаж ирнэ. Үүнд URL, HTTP статус (Статусыг 200 байлгах нь чухал!), файлын төрөл, хэмжээ болон гол авахыш хүссэн мэдээлэл ордог. Та ирсэн мэдээллийг ялгаж, R --ын орчинруу хүснэгт хэлбэрээр оруулах шаардлагатай.

### Багцууд {.unnumbered}

R дээр HTTP хүсэлт гаргахад **httr** багцыг нийтлэг хэрэглэдэг. Энэ багцыг ашиглахад Веб API мэдлэг бага шаардагддаг ба компьютер программчлалын хэллэг сайн мэдэхгүй хүмүүс хэрэглэх боломжтой. Хэрэв HTTP хүсэлт .json хэл дээр бичигдсэн бол **jsonlite**--ашиглаж хариу мэдээллийг задалж болно.

```{r, eval=F}
# багцыг ачааллана
pacman::p_load(httr, jsonlite, tidyverse)
```

### Олон нийтэд нээлттэй дата {.unnumbered}

Дараах жишээнд HTTP хүсэлт гаргахыг харуулав. Жишээг [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs) линк дээрх хичээлээс хуулбарлав. Энэ нлинкэд API --ын хичээл, дасгалууд олон бий.

Жишээ хувилбар: Бид Их Британийн Траффорд хотын түргэн хоолны газруудын жагсаалтыг импортлох хэрэгтэй болов. Энэ датаг Их Британийн хоолны ариун цэврийн үнэлгээний мэдээг боловсруулдаг Хоолны Стандартын Агентлагийн API-д нэвтэрснээр авч болох юм. Бидний хүсэлт гаргах параметрууд:

-   HTTP үйл үг: GET\
-   API --ийн эцсийн цэг URL: <http://api.ratings.food.gov.uk/Establishments>\
-   Сонгосон параметрүүд: нэр, хаяг, уртраг, өргөрөг, бизнессийн төрлийн дугаар, үнэлгээний төрөл, зөвшөөрөл өгөгчийн дугаар\
-   Толгой: "x-api-version", 2\
-   Өгөгдлийн формат(s): JSON, XML\
-   Дүрэм: <http://api.ratings.food.gov.uk/help>

Кодыг дараах маягаар бичнэ:

```{r, eval=F, warning=F, message=F}
# Хүсэлтээ бэлд
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# server –т гарах алдааг хянах  ("200" байвал сайн!)
request$status_code

# хүсэлтийг илгээж, хариуг үнэлж, хүснэгт болгон хувирга
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

Ингээд мөр бүрт нэг түргэн хоолны газрын мэдээлэл агуулсан `response` дататай болох ба үүнийг та янзалж болохоор боллоо.

### Баталгаажуулалт шаардлагатай үед {.unnumbered}

Зарим API-руу нэвтрэхийн тулд та өөрийгөө мөн эсэхийг баталгаажуулах шаардлагатай байдаг. Ингэснээр хязгаарлалттай мэдээлэлд нэвтрэх эрх авна. Энэ үед эхлээд хэрэглэгчийн нэр, нууц үг, код зэргийг POST -аргаар явуулдаг. Ингэснээр нэвтрэх эрх (token) авч улмаар GET аргаар хүсэлт явуулж хүссэн датагаа авдаг.

Доорх жишээнд *Go.Data* хэмээх өвчний дэгдэлтийг судалдаг аппликэйшнээс лавлагааг хэрхэн татаж авах талаар харуулав. *Go.Data* веб front-end болон дата цуглуулах зориулаттай гар утасны аппликэйшн хоёрын бүх харилцан үйлдэлд API ашигладаг. *Go.Data*-г дэлхий даяар ашиглагддаг боловч өвчний дэгдэлтийн талаарх мэдээлэл нууцлалтай учраас өөрийгөө мөн эсэхийг баталгаажуулсны үндсэн дээр зөвхөн *өөрийн* дэгдэлтийн мэдээлэлд орох эрхтэй болдог.

Дараах жишээнд *Go.Data*--ын **httr** болон **jsonlite** -аар API-тай харьцаж дэгдэлтийн үеийн хавьтагсдын датаг импорт хийхийг харуулав.

```{r, eval=F}
# баталгаажуулалт
url <- "https://godatasampleURL.int/"           # Go.Data –н зөв url
username <- "username"                          # Go.Data -ийн хэрэглэгчийн нэр  
password <- "password"                          # Go.Data –ын нууц үг
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # Go.Data дахь дэгдэлтийн ID 

# Нэвтрэх эрх, тасалбар (token)
url_request <- paste0(url,"api/oauth/token?access_token=123") # үндсэн URL хүсэлтийг тодорхойл


# хүсэлтийг бэлд
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # дээр хадгалсан хэрэглэгчийн нэр, нууц үгээ ашиглан орох эрхийг баталгаажуулна                     
    password = password),                                       
    encode = "json")

# хүсэлтийг илгээж, ирсэн хариуг задал
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # сүлжилдсэн JSON-г нэгтгэ
  glimpse()

# Хариултад ирсэн нэвтрэх эрх (token)-ийг хадгал
access_token <- content$access_token    # нэвтрэх эрхийг хадгалснаар дараагийн API –ийн үйлдлүүд хийгдэх боломжтой болно

# Дэгдэлтийн хавьтлуудын өгөгдлийг импортлох
# нэвтрэх эрх (token)-ийг хэрэглэ
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET хүсэлт
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # текстийг JSON луу хувирга
contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # JSON –г tibble (хүснэгт) -руу хувирга
```

[***АНХААРУУЛГА:*** API --ийн зөвшөөрөл шаардлагатай вебсайтаас том хэмжээний дата татаж байх явцад сайт завсарлага авч үйлдэл зогсох магадлалтай. Үүнээс сэргийлж нэвтрэх эрхийг (access_token) API GET хүсэлт болгоны өмнө эргүүлж татах хэрэгтэй ба мөн асуумжыг хязгаарлах эсвэл шүүлтүүр ашиглаж болно.]{style="color: orange;"}

[***TIP:*** The `fromJSON()` function in the **jsonlite** package does not fully un-nest the first time it's executed, so you will likely still have list items in your resulting tibble. You will need to further un-nest for certain variables; depending on how nested your .json is. To view more info on this, view the documentation for the **jsonlite** package, such as the [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html).]{style="color: darkgreen;"}

Нэмэлт мэдээлэл, зааврыг [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), [Contact Tracing] хуудас эсвэл [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs) доторх API зөвлөгөөнөөс харна уу.

[here](https://httr.r-lib.org/articles/quickstart.html) линкээс **httr** багцын талаар уншна уу.

Мөн энэхүү хэсгийг бичихэд [this tutorial](https://www.dataquest.io/blog/r-api-tutorial/) болон [this tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1) линк дэх хичээлээс ашигласан.

<!-- ======================================================= -->

## Экспорт

### **rio** багцаар экспортлох {.unnumbered}

**rio** -ын `export()` функц `import()` тэй ижил хэрэглэгддэг. Эхлээд хадгалах гэж буй R обьектоо (`linelist` гэх мэт) бичээд, араас нь шинээр үүсгэж буй файлын нэрийг өргөтгөлтэй нь хамт хашилтанд оруулж бичнэ. Жишээ:

Доорх жишээгээр `linelist` гэсэн хүснэгтийг Excel хүснэгт болгож R-ийн үндсэн ажлын хавтаст хадгалахыг харуулав.

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # ажлын хавтаст хадгалагдна
```

Дээрх linelist хүснэгтийг csv файл болгож хадгалая гэвэл дээрх кодон дах өргөтгөлийг өөрчлөхөд л болно. Үүнийгээ мөн `here()` -аар файлын замыг нь зааж хадгална:

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```

### Clipboard-д экспорт хийх {.unnumbered}

Хүснэгтийг өөрийн компьютерийн "clipboard" --д экспорт хийхийн тулд (дараагаар нь Excel, Google spreadsheet -руу орууулах зориулалтаар) **clipr** -ын `write_clip()` -ыг ашиглана.

```{r, eval=F}
# linelist хүснэтгийг системийн clipboard -д экспортлох
clipr::write_clip(linelist)
```

## RDS файлууд {#import_rds}

Хүснэгтийг .csv, .xlsx зэрэг өртгөтгөлөөс гадна .rds өргөтгөлөөр экспортлож болно. Энэ нь зөвхөн R --т өвөрмөц ба тухайн датаг R дээр дахин хэрэглэх нь тодорхой бол энэ өргөтгөлөөр хадгалах нь тохиромжтой.

Багануудын дата төрөл хэвээр хадгалагдсан байдаг тул импорт хийхэд дахин янзалж, цэвэрлэх шаардлагагүй (Excel, CSV файлууд дээр энэ үйлдлийг хийх нь толгойны өвчин болдог!). Мөн файлын хэмжээ багасгадаг учир том хэмжээний дата импорт, экспорт хийхэд тохиромжтой.

Жишээ нь та тархвар судлалын багтай ажиллаж байлаа гэж бодъё. Тэдний ГИС (GIS)-ийн багт газрын зураг үүсгүүлэхээр файл явуулах бол .rds хэлбэрээр явуулбал оновчтой (тэд бас R хэрэглэдэг бол)! Учир нь багана тус бүрийн дата төрөл өөрчлөгддөггүй тул тэдний хийх ажлыг хөнгөвчилж өгдөг.

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```

<!-- ======================================================= -->

## Rdata файл ба list-үүд {#import_rdata}

`.Rdata` файлууд олон R обьектыг зэрэг хадгалдаг. Тухайлбал олон хүснэгт, математик загварын үр дүнгүүд, list-үүд зэрэг файлууд хадгалагддаг. Энэ нь аливаа төсөл дээр хамтран ажиллаж, хоорондоо олон файл солилцож өөрчлөх шаардлагатай тохиолдолд их хэрэгтэй байдаг.

Жишээнд "my_objects.Rdata" хэмээх файл дотор олон R обьектуудыг оруулан экспортолж буйг харуулав.

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Тэмдэглэл: list импорт хийх үед **rio** -ын `import_list()`--ыг ашигласнаар list-ийн бүтэц, агууламжийг яг хэвээр нь хадгалах боломжтой.

```{r, eval=F}
rio::import_list("my_list.Rdata")
```

<!-- ======================================================= -->

## График, зураг хадгалах

`ggplot()`-ээр бүтээсэн график хадгалах талаар [ggplot basics] хэсэгт дэлгэрэнгүй заасан буй.

Товчхондоо графикийг хэвлэсний дараа `ggsave("my_plot_filepath_and_name.png")` коммандаар хадгална. Хамгийн сүүлд хэвлэгдсэн графикийг хадгалахдаа үүсгэж буй файлын нэрийг (өргөтгөлтэй нь хамт ) бичиж болно, эсвэл өмнө нь хадгалагдсан байсан график дээр өөрчлөлт хийн хадгалж буй бол нэрийг нь `plot =` аргументэд шууд зааж болно. Графикийн өргөн, урт, нэгж, нарийвчлал зэргийг `width =`,`height =`,`units =`,`dpi =` аргументуудаар тохируулж болно.

Халдварын тархалт харуулдаг тор хэлбэрийн (network) график хадгалах талаар [Transmission chains] хуудаст оруулсан.

<!-- ======================================================= -->

## Эх сурвалж материал

[R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)\
[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)\
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)

Дараах хүснэгтийг **rio** -ын онлайн [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html) --ээс авсан. Энэхүү хүснэгтээр **rio** багцын импорт, экспорт хийхдээ файлын өргөтгөлтэй холбоотойгоор зэрэг ажиллуулдаг багцууд, эдгээр нь **rio**-ын default -д орсон эсэхийг харуулав. .

+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Формат                              | Өргөтгөл                | Импорт хийх багц     | Экспорт хийх багц | Default-аар суулгагддаг эсэх |
+=====================================+=========================+======================+===================+==============================+
| Comma-separated data                | .csv                    | data.table `fread()` | data.table        | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Pipe-separated data                 | .psv                    | data.table `fread()` | data.table        | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Tab-separated data                  | .tsv                    | data.table `fread()` | data.table        | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| SAS                                 | .sas7bdat               | haven                | haven             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| SPSS                                | .sav                    | haven                | haven             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Stata                               | .dta                    | haven                | haven             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| SAS                                 | XPORT                   | .xpt                 | haven             | haven                        |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| SPSS Portable                       | .por                    | haven                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Excel                               | .xls                    | readxl               |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Excel                               | .xlsx                   | readxl               | openxlsx          | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| R syntax                            | .R                      | base                 | base              | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Saved R objects                     | .RData, .rda            | base                 | base              | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Serialized R objects                | .rds                    | base                 | base              | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Epiinfo                             | .rec                    | Гадны                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Minitab                             | .mtp                    | Гадны                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Systat                              | .syd                    | Гадны                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| "XBASE"                             | database files          | .dbf                 | Гадны             | Гадны                        |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Weka Attribute-Relation File Format | .arff                   | foreign              | Гадны             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Data Interchange Format             | .dif                    | utils                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Fortran data                        | no recognized extension | utils                |                   | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Fixed-width format data             | .fwf                    | utils                | utils             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| gzip comma-separated data           | .csv.gz                 | utils                | utils             | Тийм                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| CSVY (CSV + YAML metadata header)   | .csvy                   | csvy                 | csvy              | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| EViews                              | .wf1                    | hexView              |                   | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Feather R/Python interchange format | .feather                | feather              | feather           | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Fast Storage                        | .fst                    | fst                  | fst               | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| JSON                                | .json                   | jsonlite             | jsonlite          | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Matlab                              | .mat                    | rmatio               | rmatio            | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| OpenDocument Spreadsheet            | .ods                    | readODS              | readODS           | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| HTML Tables                         | .html                   | xml2                 | xml2              | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Shallow XML documents               | .xml                    | xml2                 | xml2              | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| YAML                                | .yml                    | yaml                 | yaml              | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
| Clipboard default is tsv            |                         | clipr                | clipr             | Үгүй                         |
+-------------------------------------+-------------------------+----------------------+-------------------+------------------------------+
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/importing.Rmd-->

# Дата цэвэрлэгээ ба үндсэн функцууд

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Энэ бүлэгт датаг "цэвэрлэхэд" хэрэглэгддэг нийтлэг аргууд болон R-ын дата менежментийн үндсэн функцуудыг сурах болно.

Дата цэвэрлэгээ хийх алхам бүрийг "raw" (түүхий) дата (linelist) импортлохоос авахуулаад хийгдэх үйлдэл бүрийг нэг бүрчлэн тайлбарлах болно. R- дата цэвэрлэгээ "pipe" (хоолой) холбоосоор дамжин хийгддэг бөгөөд "pipe" `%>%` буюу холбогч оператор дамжуулах үйлдлийг гүйцэтгэдэг.

### Үндсэн функцууд {.unnumbered}

Энэхүү номонд [**tidyverse**](https://www.tidyverse.org/) -ын харъяа багцууд, тэдний функцуудыг голчлон тайлбарлна. Гол хэрэглэгдэх функцуудыг дор жагсаав.

**tidyverse** багцын нэг [**dplyr**](https://dplyr.tidyverse.org/) багцын дата засаж, янзалдаг "үйл үгэн" функцууд түлхүү орсон (**dplyr** багцын нэр "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)(хүснэгтийг%20засах)%22%20гэсэн%20утгатай) буюу "хүснэгт засагч" гэсэн утгатай).( **tidyverse** --ын бусад багцуудад **ggplot2**,**tidyr**,**stringr**,**tibble**,**purrr**,**magrittr**,**forcats** ордог).

+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| Function                                            | Utility                                                             | Package                       |
+=====================================================+=====================================================================+===============================+
| `%>%`                                               | "pipe" (хоолой) нь датаг нэг функцээс нөгөөд дамжуулна              |     | **magrittr**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `mutate()`                                          | Баганыг үүсгэж, хувиргаж, өөрчилдөг \| \*\*dp                       | lyr\*\*                       |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `select()`                                          | Баганыг үлдээж, арилгаж, шинээр нэр өгдөг                           | \| **dplyr**                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rename()`                                          | Баганыг шинээр нэрлэдэг                                             |       | **dplyr**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_names()`                                     | Баганын нэрсийг жигд болгодог \| \*\*janit                          | or\*\*                        |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | Баганадах дата төрлийг өөрчилнө. \| \| \*                           | \*base\*\* R                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `across()`                                          | Олон баганыг зэрэг хувиргана \| **dplyr**                           |                               |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| **tidyselect** functions                            | Баганыг сонгохдоо logic ашиглана \|                                 | \| **tidyselect**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `filter()`                                          | Тодорхой мөрүүдийг авч үлдэх                                        |          | **dplyr**          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `distinct()`                                        | Мөрүүдийг давхардалтыг арилгах                                      |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rowwise()`                                         | Мөр дагуу үйлдэл хийх \| \*\*dplyr                                  | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `add_row()`                                         | Мөрийг гараар нэмэх \| \|                                           | **tibble**                    |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `arrange()`                                         | Мөрийг эрэмбэлэх                                                    |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `recode()`                                          | Баганадах утгыг дахин өгөх \|                                       | **dplyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `case_when()`                                       | Баганад илүү нарийвчилсэн логик шалгуураар утга оруулна\| \*\*dplyr | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | Баганад утга өгөх тусгай функцууд                                   | **tidyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `age_categories()` and `cut()`                      | Тоон утгатай баганаас ангилал үүсгэ \| \* \| \*epikit               | **and** base\*\* R            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_variable_spelling()`                         | Датаны тайлбар толийг ашиглан баганын утгыг өөрчлөх, арилг          | ах \| **linelist**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `which()`                                           | Логик шалгуур ашиглах; Индексийг харуулах (return indices)          |                  | **base** R |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+

Эдгээр функцууд Stata болон SAS программ дээр хэрхэн бичигддэг талаар [Transition to R] -линкээс үзэж болно.

Датаг янзалж байхад R-ын **data.table** багцын операторууд болох `:=`,`[ ]` гарч ирж болно. **data.table** багцын хэрэглэгддэг синтакс, аргачлалыг [Data Table] хуудаст товч оруулсан.

### Нэр томьёо {.unnumbered}

Энэхүү номонд хувьсагч (variable) -ийг багана, ажиглалт (observations) -ийг мөр гэж нэрших болно. Тархвар судлалын ихэнх датаг гол бүрдүүлдэг зүйлс бол багана, мөр, доторх утга гэж ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) -д тайлбарласан байдаг.

*Variables* (Хувьсагч) нь ижил хэв шинжтэй утгуудыг агуулсан байдаг (насны бүлэг, өвчин эхэлсэн огноо, эмчилгээний үр дүн гэх мэт). *Observations* (Ажиглалт) гэж тухайн нэгжид хийгдсэн бүх хэмжилтүүдийг хэлнэ (хүн, газар, лабораторийн дээж материал). Эдгээр шинж талуудыг бодитоор, барьцтай илэрхийлэх нь бэрхшээлтэй.

"Tidy" (цэгцтэй) датанд багана болгон хувьсагч, мөр болгон ажиглалт, нэг нүд болгон нэг утгыг зааж байдаг. Цэгцтэй загварт хэлбэржээгүй дата зарим тохиолдол бий. Тухайлбал "wide"(өргөн) дата гэхэд хувьсагч нь хэд хэдэн баганад хуваагдан байрладаг. Үүний жишээг [Pivoting data]-т хэсэгт харуулсан. Ажиглалт ч гэсэн хэд хэдэн мөрөнд хуваагдан байрласан байх тохиолдол бий.

Энэ номонд бид датаг хэрхэн хувиргаж, янзлаж, менежмент хийд талаар харуулахыг илүү эрмэлзсэн. Тийм ч учраас хувьсагч, ажиглалт зэрэг хийсвэр ойлголт хэрэглэхийн оронд мөр, багана зэрэг бодитой бүтэц заасан нэршилийг хэрэглэхээр шийдсэн. Харин статистик дүн шинжилгээний талаар тайлбарласан хэсгүүдэд хувьсагч, ажиглалт гэсэн нэршил илүү хэрэглэгдсэн.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Цэвэрлэх холбоос

**Энэ хэсэгт дата цэвэрлэгээг үе шат тус бүрээр нь тайлбарласан. Цэвэрлэгээний явцыг "pipe" цэвэрлэх холбоост нэг бүрчлэн залгаж үзүүлсэн.**

Тархвар судлалд датаг янзлах, цэвэрлэх нь хоорондоо холбоотой дараалласан үйлдлүүдээс бүрддэг. R программ дээр цэвэрлэгээг хийхдээ мөн адил *датаг нэг цэвэрлэх шатнаас нөгөөд угсруулан үйлддэг.*

Ийм угсруулсан үйлдлүүдийг **dplyr** -ын "үйл үгт" функцуууд болон **magrittr**-ын pipe`%>%` холбогч оператор хамтран гүйцэтгэдэг. Цэвэрлэгээ түүхий датагаар ("linelist_raw.xlsx") эхлээд R -ын "цэвэрхэн" хүснэгт (`linelist`) болж гардаг. Үүнийг шууд ашиглаж, хадгалж, экспортлож болно.

Цэвэрлэгээ хийж байхад үйлдлийн дараалал чухал. Нийтлэг хийгддэг үйлдлийн дараалалд:

-   Датаг оруулж ирэх\
-   Баганын нэрсийг өөрчлөх, арилгах\
-   Давхардсан утгуудыг арилгах\
-   Багана нэмж, хувиргах (утгыг дахин кодлох, стандардчилах гэх мэт)\
-   Мөрүүдийг шүүж, хасаж, нэмэх

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багцуудыг ачааллах

Дараах кодыг уншуулж шаардлагатай багцуудыг ачааллана. Энэ номонд багцыг ачааллахад **pacman** -ны `p_load()`-ыг голчлон хэрэглэнэ. Учир нь энэ функц шаардлагатай багцыг автоматаар татаж авч, ачааллаад ажиллахад бэлэн болгодог. **base** R-ын багцыг `library()`-аар та өөрөө шууд (татаж авалгүйгээр ) ачааллаж бас болно. [R basics] хэсгээс энэ талаар нэмж үзнэ үү.

```{r, message = F}
pacman::p_load(
  rio,        # дата оруулах  
  here,       # файлын холбоотой замыг тогтоох 
  janitor,    # дата, хүснэгт цэвэрлэх
  lubridate,  # огноотой ажиллах
  epikit,     # age_categories() функц
  tidyverse   # дата менежмент ба график зураглал
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Датаг импортлох

### Импорт хийх {.unnumbered}

Түүхий дата агуулсан Excel файлыг **rio**-ын `import()` функцээр импортлоно. **rio** нь файлын олон янзын төрөлтэй ажиллаж чаддагаараа давуу (.xlsx, .csv, .tsv, .rds. гэх мэт). [Import and export] хэсгээс дэлгэрүүлж үзнэ үү.

Энэ бүлгийн дасгалыг хамт хийх бол датаг дараах линкээс татаж авна уу. <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>линк дээр дарж "түүхий" linelist -ыг татаж ав</a> ( .xlsx файл).

Хэмжээ том датасетийн хувьд импортлоход хугацаа их шаарддаг учраас импорт хийх коммандаа pipe залгааснаас салангид уншуулж, түүхий датагаа тусдаа файлаар хадгалах нь тохиромжтой. Ингэснээр мөн анхны болон цэвэрлэгдсэн дата хувилбаруудыг харьцуулахад хялбар болдог.

Дорх жишээнд бид Excel-ийн түүхий файлыг импортлоод `linelist_raw` гэсэн хүснэгт болгож хадгаллаа.Энэхүү файлыг та өөрийн ажлын хавтас эсвэл R төслийн үндсэн хавтастаа байрлуулна гэж тооцсон учир файлын замыг бичихэд дэд хавтсыг оруулсангүй.

```{r, echo=F, message=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# here()-ийг ашиглаж датаг ачааллана
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Үүссэн хүснэгтийн эхний 50 мөрийг дараахаас харж болно. Тэмдэглэл: **base** R"-ын `head(n)` функцээр эхний `n` мөрийг R console дээр шууд харж болдог.

```{r message=FALSE, echo=F}
# linelist датаг хүснэгт хэлбэрээр харуул
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Тоймлон үзэх {.unnumbered}

Дата хүснэгтийн талаарх ерөнхий тойм мэдээг авахдаа **skimr** -ын `skim()` функцыг хэрэглэж болно. ([Descriptive tables] хэсгээс нэмж харна уу). Баганууд numeric (тоон), character (үсгэн) зэргээр төрөл төрлөөрөө тоймлогддог. Тэмдэглэл: "POSIXct" гэдэг нь нэг төрлийн боловсруулагдаагүй огноо датаны төрөл ([Working with dates] хэсгээс харна уу).

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганын нэрс

Хүснэгт импортлоход хамгийн эхний, толгой мөрийг баганын *нэр* гэж R уншдаг. Синтакст мөн энэ нэр хэрэгдэгднэ.

SAS, STATA зэрэг бусад статистик программд баганын толгой дох товчилсон нэрнээс гадна *"labels" (дэлгэрэнгүй нэр)* гэж байдаг. R дээр багана тус бүрт label өгөх боломжтой ч өргөн хэрэглэдэггүй. График дээр баганын нэрийг хэвлэлд үзэмжтэй харагдахуйцаар болгоход график хэвлэх комманддаа дэлгэцийн тохируулгад нь зааж өгч болно (тэнхлэгийн (axis) нэрс, ялгах тэмдгийн (legends), нэрс, багана толгой гэх мэт. [scales section of the ggplot tips page](https://epirhandbook.com/ggplot-tips.html#ggplot_tips_scales) болон [Tables for presentation](https://epirhandbook.com/tables-for-presentation.html#tables-for-presentation) хуудсаас нэмж уншна уу). Баганад label өгөх талаар [here](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) болон [here](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) линкүүдээс үзэж болно.

Баганын нэрс R дээр байнга хэрэглэгдэх тул "цэвэр" синтакстай байх нь чухал. Дараах аргаар нэрлэвэл тохиромжтой:

-   Богино
-   Зай авахгүй, доогуур зураас \_ хэрэглэх
-   Өвөрмөц тэмдэглэгээ оруулахгүй (&, \#, \<, \>, ...)
-   Төстэй нэрлэх ( жишээ нь бүх огноотой баганыг **date\_**onset, **date\_**report, **date\_**death гэж нэрлэх)

**base** R --ын `names()` функцээр `linelist_raw`--дах баганын нэрсийг хэвлэж харахад:

-   Зарим нэрс зай авсан (жишээ нь `infection date`)\
-   Огноотой баганууд жигд бус нэрлэгдсэн (жишээ нь `date onset` багана `infection date` ээс өөр)\
-   .xlsx файл дээр нь сүүлийн хоёр баганын толгой нэгтгэгдсэн (merged) байсан нь харагдаж байна. Учир нь нэгтгэгдсэн баганын эхний баганын нэр R -т "merged_header" гэж импортлогдоод хоёр дах баганын нэр "...28" гэж импортлогдсон байна ( хоосон 28 -р багана байсан).

```{r}
names(linelist_raw)
```

[***ТЭМДЭГЛЭЛ:*** зай авсан баганы нэрийг хойшоо харсан дан хашилтад хийдэг. Жишээ нь: linelist\$`` ` '\x60infection date\x60'` ``. Ингэхдээ компьютерийн гаран дээрх хойшоо харсан дан хашилт (\`) бичгийн дан хашилтаас ( ' ) өөр гэдгйиг анхаарна уу.]{style="color: black;"}

### Автомат цэвэрлэгээ {.unnumbered}

**janitor** багцын `clean_names()` функц баганын нэрсийн өвөрмөц байдлыг алдуулалгүйгээр жигдрүүлдэг. Ингэхдээ:

-   Бүх баганыг зөвхөн доогуур зураас, тоо, үсгээс бүрдсэн нэртэй болгож хувиргана.\
-   Өргөгдсөн эгшгүүд ASCII хэлрүү галиглагдна (Герман хэлний ö --г "o"-руу, Испани хэлний "enye" -г "n" болгох гэх мэт)\
-   Үсгийн том жижгийг `case =` аргументэд зааж өгч болно ("snake" хэлбэр default сонголт, "sentence", "title", "small_camel" гэх мэт өөр сонголтууд буй)\
-   Нэр өөрчлөх, орлуулахдаа `replace =` аргументийг ашиглаж болно (ж: `replace = c(onset = "date_of_onset")`)\
-   Онлайн [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) --г эндээс харж болно

Цэвэрлэх процесс `clean_names()` -эд түүхий linelist --ийг оруулснаар эхэлнэ:

```{r clean_names}
# түүхий датагаа clean_names() –д холбоод, үр дүнг нь "linelist" -доноо
linelist <- linelist_raw %>% 
  janitor::clean_names()

# баганын шинэ нэрс
names(linelist)
```

[***ТЭМДЭГЛЭЛ:*** сүүлийн баганын нэр "...28" байснаа "x28" болж хувирсан".]{style="color: black;"}

### Баганын нэрийг гараар цэвэрлэх {.unnumbered}

Баганын нэрсийг дээрх байдлаар жигдрүүлсний дараа гараар цэвэрлэх хэрэг заавал гардаг. Дорх кодонд **dplyr** --ын `rename()` -ыг pipe холбоост залгаж зарим баганын нэрийг янзалсан. `rename()` функц `NEW = OLD`-- гэсэн дарааллаар аргументээ авдаг. Эхлээд шинэ, дараа нь хуучин нэрийг бичнэ.

Дараах цэвэрлэгээний процесст нэр өгөх комманд нэмэгдэж орсныг ажиглаарай. Уншихад амар болгож зарим газар зай авсан.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
    
```

Баганын нэрс өөрчлөгдсөн байна:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Баганын байрлалаар нь нэр өгөх {.unnumbered}

Баганыг нэрийг солихдоо нэрээр нь дуудахаас гадна байрлалыг нь дуудаж болдог. Жишээ нь:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()`болон `summarise()` ашиглан нэр өгөх {.unnumbered}

Нэр өгөхдөө **dplyr** -ын `select()`болон `summarise()` функцуудыг хавсран ашиглавал арай түргэн. `select()`--ээр ажиллах гэж буй багануудаа сонгож авахад хэрэглэдэг (дараагийн хэсгүүдэд дахин дурьдна).`summarise()`--ын талаар [Grouping data] болон [Descriptive tables] хэсгүүдэд тайлбарласан. Эдгээр функц мөн адил `new_name = old_name` гэсэн дарааллаар аргументээ авна. Жишээ:

```{r, eval=F}
linelist_raw %>% 
  select(# ШИНЭ нэр              # ХУУЧИН нэр
         date_infection       = `infection date`, # нэрийг солиод, ЗӨВХӨН тухайн багануудыг л авч үлднэ
         date_hospitalisation = `hosp date`)
```

### Бусад {.unnumbered}

#### Excel дээрх баганын нэр хоосон байх {.unnumbered}

R-т баганын нэргүй дата байх боломжгүй. Тухайлбал Excel --ийн хүснэгт хоосон толгойтой баганатай R --луу импортлогдвол баганын байрлалаас нь хамаарч R автоматаар "...1", "...2" гэх мэтээр нэр өгдөг (жишээ нь хүснэгтийн 4 дэх багана нэргүй хоосон орж ирсэн бол R тэр баганыг "...4" гэж нэрлэнэ).

Энэ автоматаар өгөгдсөн нэрсийг байрлалынх нь дугаараар (дээр дурьдсан жишээний дагуу), эсвэл оноосон нэрээр нь дуудаж гараар цэвэрлэх боломжтой (`linelist_raw$...1`.

#### Excel багана, нүднүүд нэтгэгдсэн (merged) байх {.unnumbered}

Заримдаа Excel --ийн файл ыг хүлээж аваад харахад хүснэгтийн нүднүүд нэтгэгдсэн (merged) байдаг. Нэгтгэгдсэн нүдтэй хүснэгт хүн уншихад амар боловч, "цэгцтэй дата/tidy data" хэлбэрт ороогүй учраас компьютерт сайн уншигддаггүй ([Transition to R] хэсэгт тайлбарласан). R --дээр нэгтгэгдсэн нүднүүд уншигдахгүй.

Дата оруулж буй хүмүүстээ **хүнд уншигддаг дата машинд уншигддаг дата хоёр өөр** гэдгийг сайн ойлгуулах хэрэгтэй. Цэгцтэй датаны [**tidy data**](https://r4ds.had.co.nz/tidy-data.html) зарчмыг ойлгуулахыг мөн эрмэлз. Болж өгвөл дата оруулах аргачлалд нь өөрчлөлт хийж аль болох цэгцэрсэн, ямар нэг нэгтгэсэн нүдгүй дата хүлээж авахаар зохицуулбал сайн.

-   Хувьсагч тус бүр баганатай байна.\
-   Ажиглалт тус бүр мөртэй байна\
-   Утга тус бүр өөрийн нүдэнд байна.

**rio-ын** `import()` -ээр дата импортлож байхад нэтгэгдсэн нүд датанд байх тохиолдолд тухайн нүд задарч, доторх утга эхний нүдэнд бичигдээд дараах нүднүүд нь хоосон орхигддог.

Нэтгэгдсэн нүдний асуудлыг **openxlsx** багцын `readWorkbook()`функцээр шийдвэрлэх боломжтой. Үүний `fillMergedCells =` аргументийг TRUE гэж тохируулбал нэтгэгдсэн нүднүүд задрахад доторх утга бүгдэд нь зэрэг хуваарилагдан ордог онцлогтой.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***АЮУЛТАЙ:*** `readWorkbook()` -өөр баганын нэрс нэгтгэгдсэн бол давхардсан нэртэй багануудтай болчихдог. Үүнийг гараар цэвэрлэх шаардлагатай. R давхардсан нэртэй ажиллахдаа муу! Давхар нэртэй багануудын нэрийг байршлаар нь дуудаж янзалж болно (баганын нэрийг гараар цэвэрлэх хэсэгт тайлбарласан)]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана сонгох болон эрэмбэлэх

**dplyr**-ын `select()` --д баганыг дуудаж оруулахдаа дэс дарааг нь зааж өгч болно.

[***БОЛГООМЖЛОЛ:*** `linelist`- датаг `select()` --ээр янзалсан байгааг жишээ болгож харуулсан боловч хадгалаагүй. Pipe холбоостоо `names()-ыг` залгаснаар баганы нэр хэрхэн өөрчлөгдсөнийг харж болно.]{style="color: orange;"}

Цэвэрлэх холбоосонд [linelist --ын БҮХ нэрс цэвэрлэгдсэн байх үеийг энд харуулав]{style="color: orange;"}:

```{r}
names(linelist)
```

### Баганыг үлдээх {.unnumbered}

**Зөвхөн үлдээх шаардлагатай багануудаа л сонго.**

Шаардлагатай багануудаа `select()`коммандад хашилтгүйгээр оруул. Таны оруулсан дарааллаар хүснэгтийн багана эрэмбэлэгднэ. Байхгүй баганыг `select()`--д бичвэл R алдаа заана. (алдаа заахгүйгээр үргэлжлүүлэх талаар `any_of()`--ын тайлбараас үзнэ үү).

```{r}
# linelist датаг select() коммандаар цэвэрлээд names() -ээр баганын нэрсийг хэвлэсэн
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # баганын нэрсийг хэвлэж харуулах
```

### "tidyselect" туслах функцууд {#clean_tidyselect .unnumbered}

Багана үлдээх, хасах, хувиргах үйлдэл хийхдээ туслах функц ашиглавал хялбар болдог. Эдгээр туслах функцууд **tidyverse**-ын харьяа **tidyselect** багцыннх ба **dplyr** -ын багана сонгох үйлдэлтэй хавсарч хийгддэг.

Жишээ нь `everything()` функцээр "бичигдсэнээс бусад баганыг" сонгодог бөгөөд ингэх нь баганын дарааллыг өөрчлөхөд их хэрэгтэй. Дараах код `date_onset` болон `date_hospitalisation` багануудыг хамгийн эхэнд (зүүн талд) авчраад, үлдсэн багануудыг ард нь хэвээр нь үлдээсэн. `everything()` комманд хоосон хаалттай байгааг анхаар:

```{r}
# date_onset болон date_hospitalisation -г хамгийн урд зөөж авчрах
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

**dplyr** багцын `select()`, `across()`, `summarise()` нартай хамтран хэрэглэддэг **tidyselect** -ын функцуудыг дор жагсаав :

-   `everything()` - бичсэнээс бусад бүх багануудыг сонгоно\

-   `last_col()` - сүүлийн багана\

-   `where()` - аливаа функцыг бүх баганад уншуулж үзээд, TRUE тохиодлуудыг сонгоно\

-   `contains()` - заасан үсэг, тэмдэгт (character) агуулсан баганыг сонгох

    -   жишээ: `select(contains("time"))`\

-   `starts_with()` - баганын нэрийн эхлэл хэсгийг тааруулж сонгох

    -   жишээ: `select(starts_with("date_"))`\

-   `ends_with()` - баганын нэрийн төгсгөл хэсгийг тааруулж сонгох

    -   жишээ: `select(ends_with("_post"))`\

-   `matches()` -заасан regular expression (regex) тэй таарсан баганыг сонгох

    -   жишээ: `select(matches("[pt]al"))`\

-   `num_range()` - x01, x02, x03 зэрэг тоо, дугаараар тааруулж сонгох\

-   `any_of()` - аль нэг багана байхгүй тохиолдолд алдаа заахгүйгээр үйлдлийг гүйцэтгэнэ.

    -   жишээ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Үүнээс гадна ердийн операторуудыг ашиглаж болно. Жишээ нь `c()`-аар хэд хэдэн баганыг жагсааж, `:` тэмдэгтээр дарааллаж байрласан багануудыг сонгож болно. `!` (эсрэг),`&` (БА), `|` (ЭСВЭЛ) зэрэг тэмдэгтүүдээр багана сонгохдоо туслуулж болно.

Баганыг логик шалгуураар сонгох бол `where()`-ийг хэрэглэ. Хэрэв `where()`-ийг функцын дотор бичихээр бол хаалтыг нь хоосон байлгаж болохгүй. Дорх жишээнд зөвхөн тоон утгатай баганууд сонгохыг харууллаа.

```{r}
# Тоон утгатай багануудыг сонгох
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Нэрэндээ зөвхөн заасан character -ыг агуулагсан багануудыг сонгох бол `contains()` -ыг хэрэглэ. Мөн`ends_with()` болон `starts_with()` strings -ын байрлалыг илүү тодорхой зааж өгч болно.

```{r}
# тодорхой үг, үсэг нэрэндээ агуулсан багануудыг сонгох
linelist %>% 
  select(contains("date")) %>% 
  names()
```

`matches()` функц `contains()` -тай төстэй үүрэгтэй боловч regular expression ашигладгаараа онцлог ([Characters and strings]) хэсгээс нэмж харна уу. Энэ функцыг хэрэглэхдээ олон strings -үүдээ (ЭСВЭЛ) хооронд нь босоо зураасаар тусгаарлаад хашилтанд хийнэ :

```{r}
# олон strings-ийг эрэг хайж, тааруулах
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***БОЛГООМЖИЛ:*** Датанд байхгүй баганын нэрийг эдгээр функцэд өгвөл код алдаа зааж үйлдэл тэр дороо зогсчихдог. Тиймээс заасан strings байхгүй байх магадлалтай тохиолдолд `any_of()` -ийг хэрэглэвэл тохиромжтой. Ялангуяа багана хасахад их хэрэг болдог.]{style="color: orange;"}

Дор жишээнд бичсэн багануудын нэг нь л датанд буй боловч дорх код алдаа заахгүйгүээр үргэлжилж, цэвэрлэх холбоосын йлдлүүд зогсолтгүйгээр гүйцэтгэлээ хийж байна.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Баганыг хасах {.unnumbered}

Хасах ("-") тэмдэг (ж:`select(-outcome)`) эсвэл баганын нэрс жагсаасан вектороор (дор жишээнд үзүүлсэн) **аль баганыг хасахаа зааж өг**. Бусад баганууд хэвээр үлдэх болно.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # date_onset багана, fever-ээс vomit хүртэлх багануудыг хасах
  names()
```

**base** R -ын синтакс `NULL`-ыг ашиглаж баганыг хасч бас болно. Жишээ нь:

```{r, eval=F}
linelist$date_onset <- NULL   # base R -ын синтаксаар date_onset баганыг хасах
```

### Дангаараа үйлдэх коммандууд {.unnumbered}

`select()` -ийг дангаар нь хэрэглэж болдог (pipe холбоостой залгаа биш). Энэ тохиолдолд эхний аргумент нь янзлах гэж буй хүснэгтийн нэр байна.

```{r}
#  id болон насыг харуулсан шинэ linelist үүсгэх
linelist_age <- select(linelist, case_id, contains("age"))

# үүсгэсэн linelist-ийн баганын нэрсийг харуул
names(linelist_age)
```

#### Pipe холбоосонд нэмж залгах {.unnumbered}

`linelist_raw`-хүснэгт дэх дараах баганууд бидэнд шаардлагагүй: `row_num`, `merged_header`, `x28`. Эдгээрийг хасахдаа `select()` коммандыг pipe холбоосонд залгаж хасдаг:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################

    # баганыг хас
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Давхардалтыг арилгах

Энэхүү номын [De-duplication] хэсгээс давхардалтыг арилгах нэмэлт аргатай танилцаж болно. Энэ хэсэгт бид зөвхөн мөрний энгийн давхардалтыг арилгахыг харуулна.

**dplyr** багц `distinct()` гэсэн функцтэй. Энэ функц датан дах бүх мөрний давхардалтыг шалгасны дараа датаг зөвхөн өвөрмөц мөртэй болгож хувиргадаг. Энэ үйлдлээр зөвхөн 100% адилхан мөрүүдийн давхардалт арилдаг.

Давхардсан мөрийг хайхдаа мөрүүдийг хэсэгчилэн шалгаж болно (default аар бүх мөрийг зэрэг шалгана). Хэдий хэмжээний мөрүүдэд хайгуул хийхээ өөрөө тохируулж болно (давхардалтыг арилгах хэсэгт мөн тайлбарласан). Энэ тохиолдолд зөвхөн тухайн хайлт хийсэн хэсэгт л өвөрмөц мөртэй болдог.

Жишээнд хоосон `distinct()` цэвэрлэх холбоосонд залгасан байна. Ингэснээр 100% ижилхэн мөрүүдийн давхардал датанаас цэвэрлэгдсэн гэсэн үг (бүх мөр зэрэг шалгагдсан).

Жишээнд `linelist` -ийн мөрний тоо `nrow(linelist)` -оор эхэлж байна.

```{r}
linelist <- linelist %>% 
  distinct()
```

Давхардалтыг арилгасны дараа үлдсэн мөрийн тоог `nrow(linelist)` -ээр уншуулж шалгана. Хэрэв мөрийн тоо багассан бол 100% ижил давхардсан мөрнүүд арилсан гэсэн үг.

Pipe холбоосондоо `distinct()` -ийг залгаж өгөв:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################
    
    # давхардлыг арилгах
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана үүсгэх ба хувиргах

**Шинэ багана нэмэх эсвэл багана хувиргахдаа dplyr-ын `mutate()` функцыг ашиглахыг зөвлөж байна.**

Дараах жишээнд `mutate()`-аар хэрхэн шинэ багана нэмэхийг харуулав. Синтакс нь: `mutate(new_column_name = value or transformation)`

R-ын `mutate()` Stata-ын `generate`коммандтай төстэй боловч хуучин баганыг хувиргадаж болдгоороо онцлог.

### Шинэ багана {.unnumbered}

`mutate()` -ээр шинэ багана үүсгэх энгийн жишээг дор харуулав. Бүх мөрөндөө 10 гэсэн утгатай `new_col` хэмээх багана нэмж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Өөр баганын утгыг оролцуулан тооцоолол хийж бас болно. Дор жишээнд `ht_cm`, `wt_kg` гэсэн хуучин хоёр баганы утгыг оролцуулан тооцоолол хийж `bmi` (Биеийн Жингийн Индекс-БЖИ) -гэсэн шинэ багана үүсгэв (БЖИ = кг/жин\^2) .

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Олон багана зэрэг шинээр үүсгэх бол багана тус бүрийг таслалаар тусгаарлаж шинэ мөрөнд бичнэ. Үүнийг дор жишээгээр харуулав. Хуучин баганыг нэтгэхдээ **stringr** -ын `str_glue()`-эийг бас ашиглаж болдог. ([Characters and strings] -аас харж болно.

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # шинэ багана = хуучин баганыг хувилах
    new_var_static = 7,                   # шинэ багана = бүх утга ижилхэн
    new_var_static = new_var_static + 5,  # хуучин багана дээр шинэ багана үүсгэж болох ба ингэхдээ өөр баганын утгыг оролцуулан тооцоолол хийж болно. 
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") #  бусад баганын утгыг хооронд нь нийлүүлж (paste) шинэ баганаү үсгэж болно.
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # жишээ үзүүлэх зорилгоор зөвхөн шинэ багануудыг харуулсан
```

Үүссэн шинэ багануудыг шалга. Жишээ болгож шинээр үүссэн багана, эдгээрий үүсгэхэд оролцсон хуучин багануудыг дор хэвлэлээ :

```{r message=FALSE, echo=F}
# linelist датаг хүснэгтээр харуулав
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ЗӨВЛӨГӨӨ:*** `mutate()` -ын өөр нэгэн хувилбар нь `transmute()` юм. Энэ функц `mutate()` шиг шинэ багана нэмэхээс гадна функц дотор бичигдээгүй бүх баганыг хасдаг.]{style="color: darkgreen;"}

```{r, eval=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# дээр үүсгэсэн баганыг хасна
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Багана дах дата төрлийг хувиргах {.unnumbered}

Огноо, тоо, логик (TRUE/FALSE) утгатай баганын дата төрлийг зөв тодорхойлж оруулбал цаашид ажиллахад хялбар байдаг. Жишээ нь хашилттай "2" character гэж уншигддаг бол хашилтгүй 2 -ыг тоо гэж уншина!

Импорт хийж байхдаа баганын дата төрлийг тохируулж болдог ч олон үйлдэлтэй. [R Basics] хэсэгт обьектийн дата төрөл, үүнийг хэрхэн хувиргах талаар дэлгэрүүлж уншиж болно.

Дараах кодоор багануудын төрөл зөв танигдсан эсэхийг шалгана. Мөн `skim()` -ээр багана дах дата төрлийг харж болно.

Энд харуулснаар `age` баганын дата төрөл character байна. Энэ багананд математик тооцоолол хийхийн тулд дата төрөл нь тоо байх шаардлагатай!

```{r}
class(linelist$age)
```

`date_onset` баганын төрөл нь мөн character байна! Анализ хийхийн тулд эдгээр багана огноо гэж танигдсан байх шаардлагатай!

```{r}
class(linelist$date_onset)
```

Эдгээр тохиолдолд `mutate()`-аар баганыг дахин тодорхойлж зөв төрөлд нь хувиргаж болно. Ингэхэд багана дах утга өөрчлөгдөхгүй зөвхөн дата төрөл өөрчлөгддөг. Дорх жишээнд `age` баганын дата төрлийг тоо болгож хувиргаж байна:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Мөн `as.character()`, `as.logical()` функцуудыг дээрхийн адил хэрэглэж болно. Factor төрөлрүү хувиргахдаа **base** R -ын `factor()` эсвэл **forcats**-ын `as_factor()`-г хэрэглэдэг. Энэ талаар [Factors] хэсгээс нэмж уншна уу.

Огноог болгоомжтой хувиргах шаардлагатай. [Working with dates] хэсэгт хэд хэдэн аргуудыг дурьдсан. Түүхий дата дах огноонууд бүгд ижилхэн форматтай байвал цаашид Date төрөлд хувиргахад хялбар ( "MM/DD/YYYY", эсвэл "DD MM YYYY" гэх мэт). Огноог Date төрөлд хувиргасны дараа зөв хувирсан эсэхийг заавал шалгаж бай.

### Бүлэглэсэн дата {.unnumbered}

`mutate()` функц *бүлэглэгдсэн* датанд ( [Grouping data] хэсгийг хар) арай өөр байдлаар хэрэглэдэг. Ихэнх статистикийн `mean()`, `median()`, `max()` зэрэг тооцооллыг нийт датанд биш бүлэглэсэн хэсгүүдэд тооцоолдог.

```{r, eval=F}
# насыг бүх мөрний дунджаар хуваах
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# насыг эмнэлэгт хэвтсэн бүлгийн дунджаар хуваах
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Бүлэглэсэн хүснэгтэд `mutate ()` -г хэрхэн хэрэглэх талаар [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) хэсгээс нэмж уншна уу.

### Олон баганыг хувиргах {#clean_across .unnumbered}

Кодыг богино болгох үүднээс багануудыг зэрэг хувиргах шаардлага гардаг. Үүнийг **dplyr** -ын ( **tidyverse** багцуудын нэг) `across()`-оор хийж болно. **dplyr** -ын фүх функцийг `across()` -тай хавсарч хэрэглэх боломжтой ч `select()`, `mutate()`, `filter()`, `summarise()` зэрэгтэй илүү хамт хэрэглэдэг.[Descriptive tables] хэсгээс `summarise()` -тай хэрхэн хавсарч хэрэглэж болох талаар харна уу.

`across()`-ын`.cols =` аргументэд сонгосон багануудаа оруулаад, `.fns =` аргументэд гүйцэтгэх функцээ зааж өгнө. `.fns` -д заагдсан функц өөрийн аргументтэй бол таслал аваад `across()` хаалт дотроо нэмж оруулна.

#### `across()` багана сонгох {.unnumbered}

Хувиргах багануудаа `.cols =` -д зааж өг. Баганыг нэг бүрчлэн нэрлэж оруул. Эсвэл "tidyselect" -ын туслах функцээс ашиглаж болно. Сонгосон функцээ `.fns =`-д зааж өг. Оруулсан функц **хаалтгүйгээр** бичигдсэн байгааг дор жишээнээс харна уу.

`Дор жишээнд across()` дотор бичигдсэн багануудад `as.character()` хувиргалт зэрэг хийгдэж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Багана сонгох үйлдлийг "tidyselect" -ын туслах функцууд ашиглаж хялбарчилдаг. Энэ функцуудын талаар Багана сонгох болон эрэмбэлэх хэсэгт дэлгэрүүлж тайлбарласан. Эдгээр туслах функцэд : `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` `any_of()` орно.

Энд **бүх баганыг** хэрхэн зэрэг character төрөлд хувиргахыг харуулав:

```{r, eval=F}
#бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Дор зөвхөн нэрэндээ "date" гэсэн үг агуулсан багануудыг character -руу хувиргаж байна (таслал, хаалтны байрлалыг ажигла):

```{r, eval=F}
#"date" -гэсэн үг нэрэнд нь бичигдсэн бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Дор POSIXct хэлбэрт (цаг хугацааг харуулсан түүхий датаны хэлбэр) байсан багануудыг хэрхэн хувиргахыг харуулав. Ингэхдээ `is.POSIXct()` функцээр багануудыг шалгаад `TRUE` хариу өгсөн багана болгоныг `as.Date()`-руу хувиргаснаар зөв Date хэлбэрт оруулах болно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Дээр бичсэнээр `across()` доторх `where()` функцээр `is.POSIXct` функц үнэн (TRUE), худал (FALSE) эсэхийг шалгаж байна.\
-   Энэхүү `is.POSIXct()` нь **lubridate** багцын функц. Бусад төстэй "is"-ээр эхэлдэг функцууд `is.character()`, `is.numeric()`, `is.logical()` нар **base R** багцын функцууд.

#### `across()` функцууд {.unnumbered}

`?across()` коммандаар зааврыг гаргаж ирж танилцаж `across` -коммандад функц хэрхэн оруулах талаар дэлгэрэнгүйтэй танилцаж болно . Функц гэдэг ойлголтод хэд хэдэн тодорхойлолт байдаг ба таны зохиосон функц ч бас үүнд ордог.

-   Функцын нэрийг дангаар нь өгч болно (ж:`mean` эсвэл `as.character`)\

-   Функцыг **purrr**-багцын форматаар уншуулж (ж:`~ mean(.x, na.rm = TRUE)`) ( [this page][Iteration, loops, and lists]-ээс хар)\

-   Олон функцуудыг list -д жагсааж оруулж болно (ж: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Олон функц зэрэг оруулж буй үед , multiple transformed columns will be returned per input column, with unique names in the format `col_fn`. Шинээр үүсэх багануудын нэрийг **glue** -ын `.names =` аргументээр тохируулж болно ( [Characters and strings]-ээс нэмж хар) `{.col}` болон `{.fn}` are shorthand for the input column and function.

`across()`-ын талаарх нэмэлт онлайн эх сурвалжууд: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### `coalesce()` {.unnumbered}

Энэхүү **dplyr** багцын функц хамгийн эхний дутуу биш утгыг байрлал бүрт олж тогтоодог. Ингэснээр хамгийн эхний боломжит дутуу биш утгыг дутуу утгатай газар таны заавраар "нөхдөг".

Үүнийг дараах байдлаар тайлбарлая: Таньд хоёр вектор дата байна гэж бодъё. Нэг нь өвчтөний оношлогдсон тосгонууд, нөгөө нь өвчтөний амьдардаг хотууд. Үүний эхний дутуу биш утгыг coalesce-г ашиглаж индекс бүрт олж болно:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # хэвлэ
```

Хүснэгтэд мөн адил хэрэглэгднэ: таны заасан багана дах эхний дутуу биш утгыг мөрийн дагуу өөр баганад оноож өгнө (таны заасан дарааллын дагуу ).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Энэ жишээнд "мөр - дагуух" гүйцэтгэлийг харуулав. Энэ үйлдлийг хэрхэн хийх талаар Мөр-дагуу тооцоолол хэсгээс харна уу.

### Cumulative математик {.unnumbered}

Мөрний утгыг өмнөх мөрний утгатай нэгтгэж sum/mean/min/max зэрэг функцуудээр бодолт хийж үр дүнг cumulative байдлаар харуулах бол дараах функцыг хэрэглэнэ:

`cumsum()` -аар cumulative нийлбэрийг олно:

```{r}
sum(c(2,4,15,10))     # нийлбэр нэг утга бодогдно
cumsum(c(2,4,15,10))  # энэхүү векторын утга тус бүрт cumulative нийлбэр бодогдно
```

Хүснэгтийн хувьд мөн адилхан. Дэгдэлтийн үеийн тохиолдлын сumulative нийлбэрийг дараах кодоор бодно.

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # linelist-ээс эхэл
  count(date_onset) %>%                 # Огноог тоолох ('n')   
  mutate(cumulative_cases = cumsum(n))  # Мөр бүрт cumulative нийлбэртэй шинэ багана үүсгэ
```

Дээрх коммандаар хийсэн хүснэгтийн эхний 10 мөрийг харах:

```{r}
head(cumulative_case_counts, 10)
```

Cumulative тохиолдлын тоогоор график хийх тухай [Epidemic curves] хэсгээс уншина уу.

Мөн дараах функцуудын талаар харна уу:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### **base** R -г ашиглах {.unnumbered}

**base** R-аар шинэ багана үүсгэх (эсвэл хуучин баганыг өөрчлөх) бол хүснэгтийн нэрийн ард `$` тэмдэгт тавьж *шинэ* үүсгэх (эсвэл өөрчлөх) баганын нэрийг шууд ардаас нь залгаж бичдэг. Шинэ баганад утга оруулахдаа оноох оператор `<-` ашиглана. **base** R -т хүснэгтийн нэрийг баганын нэрний өмнө бичдэг болохыг анхаарна уу (ж: `dataframe$column`). Дараах жишээнд `bmi` баганыг **base** R ашиглаж үүсгэж буйг харуулав:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Pipe холбоосонд залгах {.unnumbered}

**Дараах кодны төгсгөлд шинэ мөр үүсгэх болон зарим багануудын төрөл хувиргах үйлдлүүдийг pipe холбоосонд залгаж үзүүлэв.**

```{r }
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    ###################################################
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Утга өөрчлөх

Дараах тохиолдлуудад датаны утгыг өөрчлөх шаардлага гардаг:

-   аливаа нэг утгыг янзлах (ж: аль нэг огнооны жил буруу эсвэл буруу форматтай орсон байх)
-   янз бүрээр галиглагдаж бичигдсэн утгуудыг жигд болгох
-   categorical утгатай шинэ багана үүсгэх
-   numerical утгыг бүлэглэж шинэ багана нэмэх (ж: насны бүлэглэл)

### Өвөрмөц утгууд {.unnumbered}

Утгыг гараар өөрчлөхийн тулд `mutate()` дотор `recode()` -ыг оруулдаг.

Жишээ нь буруу бичигдсэн огноо өөрчлөхдөө (ж: "2014-14-15") шууд эх дата дээрээ (боловсруулалт хийхийн өмнө) гараар янзалж болно. Эсвэл `mutate()`, `recode()`-функцуудыг pipe холбоост залгаж огноог өөрчилж болно. Сүүлийн аргыг хэрэглэх нь бусдад нээлттэй (transparent), дахин боловсруулалт хийх боломж олгодгоороо ач холбогдолтой.

```{r, eval=F}
# алдаатай утгыг засах                   # хуучин утга  # шинэ утга
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Дээр бичигдсэн `mutate()` үйлдлийг дараах байдлаар уншина: "`date_onset` баганыг шинэчлэгдсэн `date_onset` тай тэнцүүлж бичих ба ингэснээр ХУУЧИН УТГА нь ШИНЭ УТГА-аар солигдно". `recode()` функцын энэ дараалал (ХУУЧИН = ШИНЭ) R -ын ихэнх функцэд эсрэгээрээ байдаг (шинэ = хуучин). R хөгжлийн нийгэмлэг үүнийг сайжруулахаар ажиллаж байна.

**Нэг баганад олон утгыг зэрэг өөрчлөх жишээг дор харуулав.**

`linelist` -ын "hospital" баганыг цэвэрлэх шаардлагатай боллоо. Учир нь хэд хэдэн газар алдаатай бичигдэж, дутуу утгууд болж уншигдсан байна.

```{r}
table(linelist$hospital, useNA = "always")  # бүх өвөрмөц утгыг (дутуу утгатайгаар) хэвлэ  
```

Энэ жишээнд "hospital" багана хэвээр боловч `recode()` комманд ашиглаж зарим утгад өөрчлөлт оруулж байна. Тус бүр ардаа таслалтай байгааг анхаар!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # лавлагаа: ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Одоо `hospital` баганын галиглал хэрхэн засагдсаныг харья:

```{r}
table(linelist$hospital, useNA = "always")
```

[***ЗӨВЛӨГӨӨ:*** тэнцүүгийн тэмдгийн ард, урд авах зайн урт чухал биш. Бичсэн кодоо уншихад хялбар байлгах үүднээс = тэмдгийг мөр болгонд тэгшхэн тааруулж бичсэн. Мөн хүмүүст ойлгомжтой болгохын тулд "хэш" (\#) тэмдэгтээр аль нь хуучин, шинэ утгаболохыг зааж өгсөн.]{style="color: darkgreen;"}

[***ЗӨВЛӨГӨӨ:*** заримдаа *хоосон* утга датанд орж ирсэн байдаг ( R-ын дутуу утга (`NA)` болж танигдааuшй). Хоосон утгыг тодорхойлохдоо дундаа зайгүй давхар хашилтан бичдэг ("").]{style="color: darkgreen;"}

### Логик үйлдлүүд {.unnumbered}

Энэ хэсэгт логик болон нөхцөл (conditions) ашиглаж баганын утгыг хэрхэн өөрчилдгийг харуулав:

-   `replace()`, `ifelse()`, `if_else()` функцыг энгийн логик үйлдэлд хэрэглэнэ.
-   `case_when()` функцыг нарийн логик үйлдэлд хэрэглэнэ.

### Энгийн логик үйлдэл {.unnumbered}

#### `replace()` {.unnumbered}

Энгийн логик шалгуурыг үүгэхдээ `mutate()` дотор **base** R-ын `replace()` функцыг оруулаад үүн дотор шаардлагатай логик нөхцөлөө оруулж өгнө. Синтаксын ерөнхий формат:

`mutate(col_to_change = replace(col_to_change, мөрний шалгуур үзүүлэлт, шинэ утга))`.

Мөн датан дах **аль нэг утгыг өвөрмөц дугаараар нь дуудаж өөрчлөх** үйлдэлд `replace()` -ийг их хэрэглэдэг. Дорх кодоор `case_id` баганад 2195 гэсэн утга байвал үүнтэй харалдаа орших мөрний gender баганын утгыг "Female" болгож өөрчлөх комманд өгсөн.

```{r, eval=F}
# Жишээ: заасан ганц ажиглалтыг "Female" болгож өөрчлөх
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

**base** R -т дээрхитэй ижил үйлдлийг индекслэх тэмдэг буюу дөрвөлжин хаалт `[ ]` гүйцэтгэдэг (дор жишээнд харуулав). Дор кодыг дараах байдлаар уншина: "`linelist` хүснэгтийн `gender` баганыг (`case_id` баганадаа '2195' гэсэн утгатай тохиолдолд) 'Female' болго ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` болон `if_else()` {.unnumbered}

Энгийн логик үйлдэл хийдэг `ifelse()`, `if_else()` хэмээх функцууд байдаг ч оронд нь `case_when()` функцыг хэрэглэвэл илүү ойлгомжтой (дэлгэрэнгүйг доор бичсэн). Эдгээр "if else" коммандууд нь `if` болон `else` программчлалын хялбаршуулсан хэлбэр. Синтаксын ерөнхий формат:\
`ifelse(нөхцөл, хэрэв нөхцөл TRUE бол дуудах утга, нөхцөл FALSE бол дуудах утга)`

Дор `source_known` баганыг тодорхойлсон байна. Энэхүү кодоор `source` баганын мөр бүрт үзлэг хийж дутуу утга *байхгүй* бол харалдаа мөрний `source_known` баганын утгыг "known" болгоод, харин `source` мөрөнд дутуу утга *байвал* харалдаа мөрний `source_known` баганын утгыг "unknown" болгох болно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

**dplyr** багцын `if_else()` -ээр огноо их янзалдаг. Үүнийг хэрэглэж байхад FALSE нөхцөлд таарсан утгыг `NA` гэлгүй `NA_real_` гэж оруулдаг. Учир нь `TRUE` огноо бол `FALSE` бас огноо байх болно.

```{r, eval=F}
# Нас баралтын огноотой багана үүсгэ. Өвчтөн нас бараагүй бол `NA`-аар бич.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**Олон зэрэг ifelse -ийг бичихэээс зайлсхий. Оронд нь `case_when()` -ийг хэрэглэ!** Ингэснээр хялбар уншигдаж, алдаа бага гаргадаг.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Outside of the context of a data frame, if you want to have an object used in your code switch its value, consider using [`switch()`](https://rdrr.io/r/base/switch.html) from **base** R {style="color: red;"}

### Комплекс логик үйлдлүүд {#clean_case_when .unnumbered}

Бүлэг үүсгэсэн утгуудад өөрчлөлт оруулах эсвэл комплекс логик үйлдэл хийх бол **dplyr** -ын `case_when()` -ийг хэрэглэвал оновчтой. Энэхүү функц хүснэгтийн мөр болгоныг шалгаад, шалгуурт нийцсэн утгыг заасны дагуу өөрчилдөг.

`case_when()` комманд нь Баруун-Тал/Right-Hand Side (RHS) болон Зүүн-Тал/Left-Hand Side (LHS) -ын зарчмаар бичигдэж "тилда" `~` тэмдэгээр хуваагддаг. Логик шалгуур нь зүүн талдаа, харин нийцүүлэх утга нь баруун талдаа бичигдэж, тус бүр таслалаар зааглагдна.

Энэ жишээнд `age` болон `age_unit` баганыг ашиглаж `age_years` баганыг үүсгэсэн:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # хэрэв age жилээр бичигдсэн бол
            age_unit == "months" ~ age/12,    # хэрэв age сараар бичигдсэн бол
            is.na(age_unit)      ~ age,       # хэрэв age_unit-д дутуу утга байвал (age жилээр)
            TRUE                 ~ NA_real_)) # бусад бүх тохиолдолд дутуу утгаар оруул
```

As each row in the data is evaluated, the criteria are applied/evaluated in the order the `case_when()` statements are written - from top-to-bottom. If the top criteria evaluates to `TRUE` for a given row, the RHS value is assigned, and the remaining criteria are not even tested for that row. Thus, it is best to write the most specific criteria first, and the most general last.

Along those lines, in your final statement, place `TRUE` on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like "check me!" or missing.

[***DANGER:*** **Vvalues on the right-side must all be the same class** - either numeric, character, date, logical, etc. To assign missing (`NA`), you may need to use special variations of `NA` such as `NA_character_`, `NA_real_` (for numeric or POSIX), and `as.Date(NA)`. Read more in [Working with dates].]{style="color: red;"}

### Дутуу утга {.unnumbered}

Дата цэвэрлэгээний үед дутуу утгыг янзалдаг функцуудыг энд тайлбарлав.

Дутуу утгыг олж, янзлах талаар [Missing data] хэсгээс нэмж үзэж болно. Тухайлбал логик шалгуураар дутуу утгыг олдог функцыг `is.na()` гэдэг.

**`replace_na()`**

`NA` дутуу утгыг өөрөөр тэмдэглэсэн дутуу утгаар (жишээ нь "Missing") солихдоо **dplyr** -ын `replace_na()` функцыг `mutate()` дотор оруулж бичнэ. `recode` функцын адил баганын нэрийг `replace_na()` -ын дотор оруулж бичихийг анхаар.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

Энэ **forcats** багцын функц. **forcats** багц factor төрлийн датаг янзалхад зориулагдсан. Factor утга нь *дараалалтай* ( жишээ нь `c("First", "Second", "Third")` ) утга болон аливаа шатлал заагдсэн ( жишээ нь: эмнэлэгүүд) утгын R хэлэнд хөрвүүлсэн хэлбэр. [Factors] хэсгээс нэмж харна уу.

Factor датаны `NA` -г "Missing" болгож өөрчлөхөөр `replace_na()` комманд өгвөл `invalid factor level, NA generated` гэсэн алдаа гарч ирдэг. You have tried to add "Missing" as a value, when it was not defined as a possible level of the factor, and it was rejected.

Ийм тохиолдолд **forcats** багцад байдаг `fct_explicit_na()` функцыг ашиглах нь тохиромжтой ба энэ функц баганыг factor болгож, `NA` -г character "(Missing)" хэлбэрт хувиргадаг.

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Өөр нэгэн хувилбар бол `fct_expand()` функцээр factor -ын шатлалыг нэмж оруулсны дараа дутуу утгаруу өөрчлөх юм.

**`na_if()`**

*Тодорхой нэг утгыг* `NA`- болгохын тулд **dplyr**'s-ын `na_if()` -г хэрэглэдэг. Доорх комманд нь `replace_na()-`ын эсрэг үйлдэл хийгднэ. Дараах жишээнд `hospital` багана дах "Missing" утга болгон `NA` болж хувирсан байна.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Тэмдэглэл `na_if()` **-г логик шалгуурт хэрэглэх боломжгүй** (жишээ нь "бүх утга \> 99"). Оронд нь `replace()` эсвэл `case_when()` -ыг хэрэглэ:

```{r, eval=F}
# 40 -өөс дээш градусыг NA  болго
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# 1 Jan 2000 -аас өмнөх огноог дутуу утга болго
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Цэвэрлэгээний толь бичиг {.unnumbered}

**linelist** болон түүний `clean_variable_spelling()` функцээр цэвэрэлэгээний тольтой (cleaning dictionary) хүснэгтийг янзалдаг. **linelist** багцыг R Epidemics Consortium [RECON](https://github.com/reconhub/linelist) боловсруулж гаргасан.

1)  Цэвэрлэгээний толийг дараах гурван баганатайгаар байгуул:

    -   алдаатай утгуудыг заасан багана\
    -   зөв утгуудыг заасан багана\
    -   өөрчлөлт оруулах баганууд (жишээ нь ".global" гэвэл бүх баганыг өөрчлөх)

Тэмдэглэл: аль нэг баганад зориулсан өвөрмөц өөрчлөлтийг .global өөрчлөлт давамгайлж гүйцэтгэгддэг.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Цэвэрлэгээний толь бичсэн хүснэгтээ R луу импортло. Энэ жишээг [Download handbook and data] хуудсанд заасны дагуу татаж авч болно.

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Түүхий linelist -ийг `clean_variable_spelling()` функцэд оруулаад `wordlists =` аргументэд цэвэрлэгээний тольтой хүснэгтээ зааж өгнө. Энэ хүснэгтийн өөрчлөх гэж буй баганын нэрстэй баганыг `spelling_vars =` аргументэд зааж өгнө ( default)-аар гуравдах багана) . Хэрэв factor болон character бүх баганыг хамруулья гэвэл `spelling_vars =` аргументийг `NULL` гэж заана. Энэ функц удаан уншигдаж болохыг анхаар.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # өөрчлөх баганын нэрстэй багана. default-аар гуравдах багана
  )
```

Одоо (баруун тийш нь гүйлгээд) датанд хэрхэн өөрчлөлт орсныг харж болно. Энд `gender` багана жижгээс том үсэгрүү, шинж тэмдэг агуулсан бүх багана yes/no -өөс 1/0 болж хувирсан байна.

```{r message=FALSE, echo=F}
#  linelist -ийг хүснэгтээр харуул
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Цэвэрлэгээний тольтой хүснэгтийн баганын нэрс таны одоо бичиж буй коммандны скрипттэй яг таарч байх шаардлагатайг анхаарна уу. Энэ талаар [online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) -ээс харна уу.

#### Цэвэрлэх pipe холбоосонд залгах {.unnumbered}

**Доорхи pipe холбоосонд багана нэмэх, баганын хувиргах үйлдлүүд залгагдсан.**

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) |> 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ###################################################

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Тоог ангилах {#num_cats}

Энэ хэсэгт numeric баганаас хэрхэн categorical (ангилсан) утгатай багана үүсгэх талаар үзнэ. Тоон (numeric) ангилалын жишээнд насны ангилал, шинжилгээний үзүүлэлтийн ангилал зэрэг орно. Гол хэрэглэгдэх функцууд:

-   **epikit** багцын `age_categories()`\
-   **base R -ын** `cut()`\
-   `case_when()`\
-   `quantile()`, `ntile()`зэрэг кванталууд

### Тархалтыг шалгах  {.unnumbered}

Жишээнд `age_years` баганыг ашиглаж `age_cat` баганыг үүсгэх болно.

```{r}
# linelist -хүснэгт дэх нас заасан баганын дата төрлийг тогтоох
class(linelist$age_years)
```

Эхлээд датаны тархалтын дүрсийг шалгаж хуваах цэгүүдээ (cut-points) тогтооно. [ggplot basics] хэсгээс дэлгэрүүлж харна уу.

```{r, out.height='50%'}
# тархалтын дүрсийг шалга
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***АНХААРУУЛГА*** Заримдаа тоон хувьсагч нар "character" хэлбэрээр импортлогдох тохиолдол байдаг. Энэ нь тухайн хувьсагчын аль нэг утганд тоон биш тэмдэгт агуулагдсан байснаас болдог. Жишээ нь нас заасан баганад "2 сар" (2 months) гэж бичигдэх, бутархай тоонд цэг биш таслал тавигдах тохиолдлууд байдаг ("4,5" -аар дөрөв аравны тав гэсэн санаа илэрхийлсэн байх).]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

Тоон баганын утгад ангилалал үүсгэх бол **epikit** багцын `age_categories()` -ыг хэрэглэвэл хялбар (тэмдэглэл: энэхүү функцыг тоон биш хувьсагчид хэрэглэж бас болдог ). Ингэснээр үүссэн багана нь автоматаар эрэмбэлэгдсэн (ordered) factor болдог ач холбогдолтой.

Шаардлагатай оролтууд:

-   Тоон вектор (багана)\
-   `breakers =` аргумент - шинэ үүсэх ангиллын хуваагдах цэгүүдийг заасан тоон векторуудыг оруулна.

Эхлээд энгийн жишээ авч үзье:

```{r}
# Энгийн жишээ
################
pacman::p_load(epikit)                    # багцыг ачаалла

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # багана үүсгэ
      age_years,                            # шинэ багана үүсгэхэд ашиглах numeric багана
      breakers = c(0, 5, 10, 15, 20,        # хуваагдах цэгүүд
                   30, 40, 50, 60, 70)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

The break values you specify are by default the lower bounds - that is, they are included in the "higher" group / the groups are "open" on the lower/left side. As shown below, you can add 1 to each break value to achieve groups that are open at the top/right.

```{r}
# дээд хязгаарыг ижилхэн ангилалд оруулж байна
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Ангиллын нэрсийг `separator =` аргументээр тохируулж болно. Default тэмдэг нь "-".

Тоон утгын дээд хязгаарыг хэрхэхийг `ceiling =`аргументээр тохируулна. Дээд хязгаар тогтоох бол `ceiling = TRUE`гэж өгнө. Ингэснээр хамгийн дээд тогтоосон тоогоор ангилал дуусч "XX+" гэсэн ангилал үүсэхгүй. Энэхүү зааж өгсөн дээд хязгаараас их (эсвэл `upper =` -т зааж өгсөн) ямар ч тоо `NA` ангилалд орно. Доор жишээнд `ceiling = TRUE` гэж өгсөн тул XX+ ангилал үүсэхгүй, 70 -аас дээш (зааж өгсөн хамгийн дээд хязгаар) тоо `NA` болж хувирсан.

```{r}
# ceiling аргументийг TRUE дээр тохируулсан
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 бол дээд хязгаар ба үүнээс дээш тоо NA болно

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Мөн `breakers =` аргументийн оронд та өөрөө `lower =`, `upper =`, `by =` гэсэн аргументуудэд хуваах цэгүүдтэы тоон дарааллыг оруулж өгч болно:

-   `lower =` таны зааж өгсөн хамгийн бага тоо - default нь 0\
-   `upper =` таны зааж өгсөн хамгийн их тоо\
-   `by =` ангилал хоорондын интервал

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

энэ функцын Help хуудаснаас нэмэлт мэдээллийг үзэж болно (R console-д `?age_categories` гэсэн коммандаар гаргана).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()` бол **base** R -д багтдаг `age_categories()` -тай адил үйлдэлтэй функц. Гэвч `age_categories()` дээр ажиллахад илүү хялбар. `age_categories()` -аас гол ялгаатай шинжүүд:

-   Өөр багц суулгаж/уншуулах шаардлагагүй.\
-   Ангилал баруун/зүүн талруугаа нээлттэй/хаалттай эсэхийг зааж өгч болно.\
-   Ангиллын нэрсийг та өөрөө оруулж өгнө.\
-   Хамгийн бага ангилалдаа 0-г оруулах бол өөрөө зааж өгөх шаардлагатай.

`cut()` дотор эхлээд ангилах гэж буй numeric баганаа (`age_years`) оруулаад, хуваах цэгүүдээ `breaks=`аргументэд тоон вектор хэлбэрээр `c()` -д оруулна. `cut()` -аар үүсгэгдсэн багана эрэмбэлэгдсэн factor төрөл болдог.

Default-аар баруун/дээд тал "нээлттэй" (зүүн/доод тал нь "хаалттай" ) байдаг. Энэ нь `age_categories()` функцэд эсрэгээрээ хийгддэг. Default тэмдэглэгээ нь "(A, B]" бөгөөд энэ нь A ороогүй B орсон гэсэн утгатай. **Үүний эсрэг хийх бол `right = TRUE` гэж зааж өгнө.**

Үүнээс болоод хамгийн бага тоотой ангилалд default -аар "0" ордоггүй ба "0" утга `NA` болж хувирдаг. Гэтэл зарим тохиолдолд тухайлбал нярай хүүхдүүдийн нас 0 гэж кодлогддог зэргийг анхаарч байх шаардлагатай. Үүнийг өөрчлөхийн тулд `include.lowest = TRUE` гэсэн аргументийг нэмснээр "0" утга хамгийн бага тоотой ангилалд багтдаг. Автоматаар үүссэн ангиллын нэр хамгийн бага ангилалд "[A],B]" болдог. Note that if you include the `include.lowest = TRUE` argument **and** `right = TRUE`, the extreme inclusion will now apply to the *highest* break point value and category, not the lowest.

Үүсгэсэн ангилалд нэр өгөхдөө `labels =` аргументэд оруулна. Гараар бичигдэх тул алдаа гаргахаас сэргийлээрэй! Cross-tabulation (солбисон хүснэгт) ашиглаж алдаагаа шалгаарай

`cut()` ашиглаж `age_years` баганаас `age_cat` гэсэн шинэ багана үүсгэх жишээг дор харуулав:

```{r}
# Тоон age хувьсагчийг хувааж, ангилагдсан багана үүсгэ
# Ангиллын доод хязгаар нь битүү харин дээд хязгаар нь нээллттэй байна.
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # 0 -г доод ангиолд багтаа
      ))

# ангилал тус бүр дэх ажиглалтын тоог жагсааж хар
table(linelist$age_cat, useNA = "always")
```

**Хийсэн ажлаа шалга!!!** Насны тоон үзүүлэлтүүд зөв ангилалдаа орсон эсэхийг тоон болон ангилагдсан багануудыг солбиж харуулсан хүснэгтээр шалга. Ялангуяа захын утгуудыг шалгаарай (жишээ нь 15- ын тоо 10-15, 16-20 гэсэн ангилалуудын ойролцоо байгаа эсэх).

```{r}
# Тоон болон ангилагдсан баганыг солбиж харуулсан хүснэгт
table("Numeric Values" = linelist$age_years,   # ойлгомжтой болгох үүднээс багануудад нэр өгсөн
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # NA утгуудыг шалгахаа бүү мартаарай
```

**`NA` утгуудад дахин нэр өгөх**

`NA` -утгуудыг "Missing" гэсэн нэртэй ангилалд оруулж болно. Шинээр үүсэх багана factor учир (хязгаарлагдмал утгууд) шууд `replace_na()` аар хувиргалт хийх боломжгүй. [Factors] хэсэгт тайлбарсанчлан **forcats** багцын `fct_explicit_na()` функцыг хэрэглээрэй.

```{r}
linelist <- linelist %>% 
  
  # cut() -аар age_cat-ыг үүсгэнэ. Factor төрлийн багана үүснэ.     
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # Дутуу утгыг тодорхой болго
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # нэрийг өөрөө өгч болно
  )    

# ангилал тус бүр дэх ажиглалтын тоог харуулсан хүснэгт
table(linelist$age_cat, useNA = "always")
```

**Хуваах, нэрлэх үйлдлийг хялбарчлах**

Аливаа векторыг түргэн хугацаанд хувааж, нэр өгөх жишээг дор харуулав. [R basics] хэсгийн `seq()`, `rep()` -ийн тайлбараас нэмж үзэж болно.

```{r, eval=F}
#  0 -ээс 90 хүртэлх тоог 5 аар хуваасан цэгүүд үүсгэ. 
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Дээрх үүссэн ангиллуудад нэр өг (cut() default тохируулгатай)
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# ажиглалтын тоо хоёр векторт адилхан байна
length(age_seq) == length(age_labels)
```

`?cut` коммандыг R console -д өгч `cut()` функцын Help хуудаснаас нэмж тодруулж болно.

### Квантил хуваагдлууд {.unnumbered}

In common understanding, "quantiles" or "percentiles" typically refer to a value below which a proportion of values fall. Жишээ нь, `linelist` -ийн нас заасан баганын 95 дах персентил гэдэг нь нас заасан бүх утгын 95% нь орж буй утгуудыг хэлнэ.

Ердийн хэллэгт "квантил", "децил" гэдэг нь аливаа датаг 4 эсвэл 10 тэнцүү хуваахыг хэлдэг (хуваасан тооноос нэг илүү ангилал үүсэхийг анхаараарай).

Квантилаар хуваахдаа **base** R-ын **stats** багц дах `quantile()` функцыг ашигладаг. Та тоон вектор болон 0-оос 1 хүртэлх магадлал оноогдсон векторыг (ж: нэг баганадах тоо) оруулж өгнө. Эдгээр нь тоон векторууд юм. Энэ функцын статистикийн аргачлалын талаар `?quantile`комманд өгч уншна уу.

-   хэрэв таны оруулсан тоон вектор дутуу утгатай бол `na.rm = TRUE` гэж тохируулах хэрэгтэй.\
-   `names = FALSE` гэж тохируулснаар нэрлэгдээгүй тоон векторыг гаргаж ирнэ.

```{r}
quantile(linelist$age_years,               # ажиллах гэж буй тоон вектороо зааж өгнө
  probs = c(0, .25, .50, .75, .90, .95),   # персентилээ зааж өгнө
  na.rm = TRUE)                            # дутуу утгыг үл тоох 
```

`quantile()` -аар бодогдсон хуваагдах цэгүүдээ `age_categories()`, `cut()` функцын оролтод оруулж болно. Дор жишээнд `age_years` багана дах утгыг `quantiles()` -д өгч хуваагдах цэгүүдийг бодож гарган `cut()` коммандад өгснөөр `deciles` баганыг үүсгэж буй жишээг харуулав. Гарсан үр дүнгийн хувийг **janitor** багцын `tabyl()` функцийг ашиглаж харуулав ( [Descriptive tables] хуудсаас харна уу). Ангилалууд яг тэнцүү 10% -аар хуваагдаагүйг ажиглаарай.

```{r}
linelist %>%                                # linelist-ээс эхэл
  mutate(deciles = cut(age_years,           # cut()-аар age_years баганасс decile баганыг үүсгэ
    breaks = quantile(                      # quantile()-аар хуваагдах цэгүүдийг тодорхойл
      age_years,                               # age_years дээр хэрэгжүүл
      probs = seq(0, 1, by = 0.1),             # 0.0 -ээс 1.0 -ыг 0.1 -ээр хуваа
      na.rm = TRUE),                           # дутуу утгуудыг үл тоох
    include.lowest = TRUE)) %>%             # cut() -д  0 насыг оролцуул
  janitor::tabyl(deciles)                   # хүснэгт болгож харуулах
```

### Тэнцүү хэмжээтэй бүлгүүд үүсгэх {.unnumbered}

Тооноос бүлэг үүсгэх өөр нэгэн функц бол **dplyr** багцын `ntile()` юм. Энэ функц таны датаг яг тэнцүү бүлгүүдэд хуваахыг оролддог. `quantile()` -аас ялгаатай тал нь *нэг тоо хоёр өөр бүлэгт орж болдог тул анхаарах хэрэгтэй.* Хуваагдах тоон вектор болон үүсгэх бүлгүүдийн тоог оруулж өгөх хэрэгэтй. `cut()` функцээр үүсгэгдсэн баганын утга тухайн бүлгийн нэр байдаг бол `ntile()`-ээр үүссэн багана дах утга зөвхөн бүлгийн дугаарууд болохыг анхаарна.

```{r}
# ntile()-аар бүлэг үүсгэ
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# бүлэг тус бүрт ноогдох ажиглалтын тоо пропорцыг харуулах
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# зах хязгаарыг харуулах үүднээс min/max -г мөн нэмж харуул
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# нэгтгэж, хэвлэ - зарим утга олон бүлэгт зэрэг орж болохыг анхаар
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

**dplyr** -ын `case_when()` -ыг ашиглаж тоон баганаас ангилал үүсгэж бас болно. Гэхдээ шууд автоматаар эрэмбэлэгдсэн factor төрлийн багана үүсдэг тул **epikit** -ын `age_categories()` эсвэл `cut()` -ыг хэрэглэх нь илүү хялбар байдаг.

Хэрэв `case_when()` -г хэрэглэх бол Re-code values хэсгээс хэрхэн зөв хэрэглэх талаар үзнэ үү. Мөн энэ үед бүх баруун гар талын утгууд ижил төрөл байх хэрэгтэй. Хэрэв `NA` -г баруун гар талд бичих бол "Missing" эсвэл `NA` -г төлөөлсөн тусгай `NA_character_` хэрэглэх шаардлагатай.

### Цэвэрлэх холбоост залгах {.unnumbered}

Жишээгээр хоёр ангилагдсан баганыг цэвэрлэх pipe холбоостоо залгаж өгч харууллаа.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) |> 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) |> 
  
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Мөр нэмэх

### нэг нэгээр нэмэх {.unnumbered}

Мөрийг **dplyr**-ын `add_row()` -аар оруулах нь гар ажиллагаа ихтэй байдаг. Энэ үед багана тус бүр нэг төрлийн дата агуулсан байх шаардлагатайг санаарай (character, numeric, logical гэх мэт). Тиймээс нэмэх мөрийн дата төрлийг тааруулах шаардлагатай.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

`.before` болон `.after.` аргументээр нэмэх мөрийн байрлалыг зааж өгдөг. Жишээ нь`.before = 3` гэвэл шинэ мөрийг одоогийн 3 дугаар мөрний өмнө нэм гэсэн үг. Default -аар мөрийг баганын төгсгөлд нэмдэг. Тодорхойлгоогүй багануудыг дутуу утгаар (`NA`) -авах болно.

Шинэ үүссэн *мөрийн дугаар* хачин харагдаж болох ба ("...23") but the row numbers in the pre-existing rows *have* changed. So if using the command twice, examine/test the insertion carefully.

Хэрэв зааж өгсөн дата төрөл нь таарахгүй бол дараахийн адил алдаа гарч ирнэ:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(огноо төрлийн мөр нэмэхдээ огноогоо `as.Date()` функцэд оруулж өгөөрэй ( `as.Date("2020-10-10")`).

### Мөрүүдийг холбох {.unnumbered}

Нэг хүснэгтийн мөрийг өөр нэг хүснэгтийн доороос залгах бол **dplyr** -ын `bind_rows()`- ыг хэрэглэдэг. Энэ талаар [Joining data] хэсэгт илүү тайлбарласан.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөрийг шүүх

Багануудыг цэвэрлээд, шинэ утгуудыг оруулсны дараа нийтлэг хийгддэг алхам бол **dplyr** -ын `filter()` -ээр мөрөнд шүүлт хийх юм.

`TRUE` байх ёстой логикийг `filter()` дотор зааж өгнө. Дараах хэсгүүдэд энгийн болон комплекс логик шалгуураар хэрхэн мөрийг шүүдгийг харуулав.

<!-- ======================================================= -->

### Энгийн шүүлт хийх {.unnumbered}

Логик шалгуурт нийцсэн мөрүүдийг `linelist` хүснэгтэд шүүж гаргаж ирэх жишээг харуулав. **Зөвхөн хаалтан доторх логик шалгуурт `TRUE` нөхцлүүд л үлддэг.**

Энэ жишээний логик шалгуур нь `gender == "f"`. Үүнийг үгчилбэл gender багана дах утгууд "f" (үсгийн том жижиг хамааатай) -тэй тэнцүү байна уу гэсэн үг.

Шүүлтүүр уншигдахын өмнө `linelist` дэх мөрийн тоо `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # gender баганад "f" гэсэн мөрүүдийг л авч үлднэ
```

Шүүж ялгасны дараа `linelist` хүснэгтэд `linelist %>% filter(gender == "f") %>% nrow()` мөр үлдсэн.

### Дутуу утгуудыг ялгах {.unnumbered}

Нийтлэг хийдэг үйлдлүүдийн нэг бол дутуу утгатай мөрүүдийг ялгах юм. Ингэхдээ шууд `filter(!is.na(column) & !is.na(column))` коммандыг өгөхийн оронд **tydir** багцын яг энэ үйлдэлд зориулсан `drop_na()` функцыг хэрэглэвэл оновчтой. Энэ функцын хаалтыг хоосон орхивол дутуу утга агуулсан мөр болгоныг арилгах болно. Баганын нэрийг зааж өгч болно эсвэл "tidyselect" функцын тусламжтай ([above](#clean_tidyselect)) багануудыг сонгож дутуу утгыг шүүж болно.

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # case_id, age_years багануудад дутуу утгатай  мөрийг арилгах
```

[Missing data] хэсгээс дутуу утгыг янзлах төрөл бүрийн аргатай танилцаж болно.

### Мөрийн дугаараар шүүлт хийх {.unnumbered}

Хүснэгт болон tibble-ийн эхний баганын зүүн талд мөрийн дугаар харагддаг (R Viewer цонхоор харахад). Энэ дугаарууд бие даасан багана биш боловч `filter()` хийхэд хэрэглэгддэг.

Дугаараар нь шүүлт хийхдээ **логик шалгуурын нөхцлийн нэг хэсэгт dplyr** -ын `row_number()` функцыг нээлттэй хааллтайгаар оруулдаг. Логик нөхцөлд `%in%` оператор болон жагсаасан тоо шаардлагатай (дор үзүүлсний дагуу). Эхний N мөрийг харахаын тулд **dplyr** функцын `head()` функцыг хэрэглэнэ үү.

```{r, eval=F}
# Эхний 100 мөр
linelist %>% head(100)     # tail() -аар сүүлийн мөрүүдийг харж болно

# Эхний 5 мөр
linelist %>% filter(row_number() == 5)

# Заасан гурван баганын 2-20 дах мөрийг харуул
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

You can also convert the row numbers to a true column by piping your data frame to the **tibble** function `rownames_to_column()` (do not put anything in the parentheses).

<!-- ======================================================= -->

### Комплекс шүүлт хийх {.unnumbered}

Илүү комплекс логик шүүлт хийхдээ хаалт `( )`, ЭСВЭЛ `|`, үгүйсгэх `!`, `%in%`, БОЛОН `&` операторуудыг ашигладаг.

Тэмдэглэл: `!` операторыг үгүйсгэх логик шалгуурын өмнө тавьдаг. Жишээ нь `!is.na(column)` комманд өгөхөд тухайн баганад *дутуу утга байхгүй* бол `TRUE` гэж гарна. Үүний адил `!column %in% c("a", "b", "c")` комманд өгөхөд баганын утга вектор биш бол `TRUE` гэж гарна.

#### Датаг шалга {.unnumbered}

Доорх коммандаар өвчний эхлэлийг харуулсан гистограмм хийгднэ. Зургаас харахад 2012-2013 оны хооронд гарсан жижиг дэгдэлтийн дата түүхий датаны нэг хэсэг болж орсон байна. **Бидний анализдаа энэхүү өмнөх дэгдэлтийн датаг арилгах шаардлагатай.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### Тоон болон огноон датаны дутуу утгад шүүлт хийх {.unnumbered}

2013 оны 6 сараас хойшхи мөрүүдийг `date_onset` баганад шууд шүүлт хийснээр ялгах боломжтой уу? **Анхааруулга! `filter(date_onset > as.Date("2013-06-01")))` комманд өгвөл дараагийн дэгдэлт дэх дутуу утгатай бүх мөрийг утгагдах болохыг анхаар!**

[***АЮУЛТАЙ:*** Тоон болон огноонд их (\>) багын (\<) тэмдэг хэрэглэхээр дутуу утгатай (`NA`) бүх мөр арилчихдаг! Учир нь `NA` нь хязгааргүй их эсвэл бага утга гэж уншигддаг.]{style="color: red;"}

*(Огноо болон **lubridate** багцтай ажиллах талаар [Working with dates] хэсгээс үзээрэй)*

#### Шүүлтүүрийн загвар гаргах {.unnumbered}

Солбисон хүснэгтээр зөв мөрүүд хамрагдсан эсэхийг шалга:

```{r}
table(Hospital  = linelist$hospital,                     # эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчний эхэлсэн (date_onset) жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Энэхүү датанаас эхний дэгдэлтийн (2012 болон 2013 онуудын) хэсгийг шүүхийн тулд ямар шалгуур нэмж болох вэ? Үүнээс харахад:

-   2012 болон 2013 онд болсон эхний дэгдэлтүүд A , B эмнэлэгт гарч Port эмнэлэгт ердөө 10 тохиолдол бүртгэгдсэн байна.\
-   Хоёрдах дэгдэлтийн үед A болон B эмнэлэгүүдэд дэгдэлт гараагүй. Port эмнэлэгт дэгдэлт гарсан байна.

Дараах хэсгийг хасах хэрэгтэй:

-   А, B, Port эмнэлэгүүдийн тохиолдлуудын өвчин эхэлсэн өдөр нь 2012, 2013 онд тэмдэглэгдсэн мөрүүд `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))`:

    -   2012 болон 2013 онд тэмдэглэгдсэн өвчний эхлэлтэй мөрүүдийг хасах `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))`
    -   A болон B эмнэлэгийн огноо нь дутуу мөрүүдийг хасах `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`\
    -   Огноо нь дутуу утгатай бусад мөрийг **хасахгүй** байх `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`.

Эхлээд linelist -ийн мөрийн тоо nrow(linelist)\` байсан. Шүүлт хийх нөхцөл:

```{r}
linelist <- linelist %>% 
  # Өвчний эхлэл нь 2013  оны 6 сарын 1 нээс хойш ЭСВЭЛ өвчин эхэлсэн огноо нь дутуу бичигдсн , B эмнэлэгээс эмнэлэгийн бус тохиолдол
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Солбицох хүснэгт дахин хийж үзвэл A болон B эмнэлэгүүдийн дата бүтнээрээ, Port эмнэлэгт 2012, 2013 онд гарсан 10 тохиолдлын мөрүүд хасагдаж бусад утгууд хэвэндээ байна (яг бидний зорьсны дагуу).

```{r}
table(Hospital  = linelist$hospital,                     # Эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчин эхэлсэн (date_onset) жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Шүүлт хийх ганц коммандаар олон нөхцөл зэрэг оруулж (таслалаар тугаарлан) оруулж болно. Эсвэл ойлгомжтой болгох үүднээс нөхцөл тус бүрт filter() -т оруулж pipe -аар залгаж болно.

*Тэмдэглэл: зарим уншигчид шууд `date_hospitalisation` шүүлтүүрийг ашиглах нь хялбар болохыг анзаарсан байх. Энэ нь дутуу утга байхгүй 100% бүрэн. бүртгэл юм. Таны зөв. Дээрх жишээний хувьд бол комплекс шүүлт хэрхэн хийхийг үзүүлэх үүднээс `date_onset`-г сонгосон гэдгийг анхаарна уу.*

### Бие даасан үйлдэл {.unnumbered}

Шүүлт хийх үйлдлийг дангаар нь бас гүйцэтгэж болно (pipe холбоосонд залгалгүйгээр). Энэ тохиолдолд **dplyr** -ын бусад функцын адил эхний аргумент нь дата хүснэгт өөрөө байх болно.

```{r, eval=F}
# dataframe <- filter(хүснэгт, мөрийг үлдээх нөхцлүүд )

linelist <- filter(linelist, !is.na(case_id))
```

**base** R -ын дөрвөлжин `[ ]` хаалтыг (сонгосон багана, мөрийг заадаг) ашиглан хүссэн хэсгээ салгаж үзэж болно.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Мөрүүдийг түргэн шалгах {.unnumbered}

Дата янзалж байх явцад зарим мөрийг яаралтай шалгах шаардлага цөөнгүй гардаг. RStudio дээр дата хүснэгттийг хэвлэж үзэхэд **base** R -ын функц `View()`-ийг хэрэглэдэг.

linelist-ийг RStudio-д харах код:

```{r, eval=F}
View(linelist)
```

Доор тодорхой нэг нүдийг шалгаж харах хоёр аргыг харуулав (тодорхий мөр, тодорхой багана):

**dplyr -ын `filter()` болон `select()` функцууд:**

Авч үлдэх мөрүүдээ `filter()` -т, багануудаа `select()` -д оруулэ pipe -аар холбож `View()` дотор бичнэ. Жишээ нь дараах 3 тохиолдлын өвчин эхэлсэн болон эмнэлэгт хэвтсэн огноог харахын тулд доорхи коммандыг өгнө:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

**base** R -ын `[ ]` хаалтыг ашиглан хүссэн хэсгээ салгаж үзэж, дээрхитэй ижил үр дүнг гаргаж бас болно.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Pipe холбоост залгах {.unnumbered}

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) |> 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) |> 
  
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) |> 
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    
    filter(
          # case_id баганад дутуу утгагүй мөрүүдийг л үлдээ
          !is.na(case_id),  
          
          # зөвхөн хоёрдах дэгдэлтийн датаг үлдээ
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөр дагуу тооцоолол

Хэрэв мөр дагуу уртаашаа тооцоолол хийх бол **dplyr**-ын `rowwise()` функцыг хэрэглэ. Онлайн винньетийг [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html)- ээс нэмж үзнэ үү .\

Дор жишээнд linelist датанд `rowwise()` функц мөр болгоныг уртааш нь шалгаж үзээд "yes" гэсэн утгатай нүднүүдийн нийлбэртэй шинэ багана нэмсэн. Шалгагдах багануудыг `sum()` функцэд нэрээр нь вектороор `c()` уагсааж оруулна. `rowwise()` функц нь `group_by()` функцын нэг төрөл тул үйлдлээ хийж дуусаад эргүүлээд `ungroup()` коммандаар задлах шаардлагатай ([Grouping data] хэсэг).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # үзүүлэх зорилготой
```

Шалгах багануудыг сонгохдоо "tidyselect" туслах функцуудыг ( `select()` хэсэгт тайлбарласны дагуу) хэрэглэж болно. Зөвхөн тохируулгыг нь солиход л болно (**dplyr** -ын `select()`, `summarise()` зэрэг функц биш учраас).

**dplyr** -ын `c_across()` дотор нөхцлөө оруулж өгнө. Учир нь `c_across` ([documentation](https://dplyr.tidyverse.org/reference/c_across.html)) функц `rowwise()` -аар ажилладаг. Жишээ нь дараах код ажиллах дараалал нь:

-   эхлээд `rowwise()` гүйцэтгэгдэх ба ингэснээр үүний дараа хийгдэх үйлдэл (`sum()`) мөр болгонд хийгднэ (багануудын нийлбэр биш).
-   `num_NA_dates` хэмээх шинэ баганыг нэмж, defined for each row as the number of columns (with name containing "date") for which `is.na()` evaluated to TRUE (they are missing data).\
-   `ungroup()` хийснээр дараагийн хийгдэх үйлдлүүдэд `rowwise()` нөлөөлөхгүй байх болно.

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # үзүүлэх зорилготой
```

Нэмж `max()` гэх мэт бусад функцыг хэрэглэж болно. `max()`-аар мөр болгон дах хамгийн шинэ огноог харуулдаг:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # үзүүлэх зорилготой
```

## Эрэмбэлэн ялгах

Мөрийг баганын утгаар эрэмбэлэх бол **dplyr** функцын `arrange()` -ыг хэрэглэнэ.

Багануудыг эрэмбэлэх дарааллын дагуу жагсааж бичнэ. Хэрэв эрэмбэлэлтийг аль нэг баганын ангиллын дагуу хийх бол `.by_group = TRUE` гэж аргументийг тохируулна ([Grouping data] хэсгээс харна уу).

Default-аар бол баганын утга "ихсэх" дарааллаар эрэмбэлэгддэг (тоо болон үсгэн утга). Баганын нэрийг `desc()` -д оруулсанаар "буурах" дараалалд оруулж болно.

Ялангуяа тайлан, илтгэлд зориулсан хүснэгт ([Tables for presentation]) дээр ажиллахад `arrange()` -ыг ашиглавал оновчтой. `slice()` -аар ангилал тус бүрийн "оройн" мөрүүдийг харуулж болно. Мөн factor-ын шатлалыг харагдах байдлаар нь эрэмбэлж тохируулж болдог.

Жишээ нь, linelist датаг `hospital` баганын дагуу эрэмбэлээд, дараа нь `date_onset` -ээр буурах дарааллаар эрэмбэлэе гэвэл дараах байдлаар кодыг бичнэ:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# ХАРАГДАХГҮЙ
#
# хуучин дэгдэлтийн нэг мөрийг NA болго
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# БАГАНУУДЫГ ЭКСПОРТЛОХОД БЭЛДЭЖ ЭРЭМБЭЛ
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# ЦЭВЭРЛЭГДСЭНLINELIST ФАЙЛЫГ "DATA" ХАВТАСТ ЭКСПОРТЛОХ
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"), overwrite = TRUE)
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cleaning.Rmd-->

# Огноотой ажиллах нь

```{r, out.width=c('50%'), fig.align='center', echo=F, message=F}
knitr::include_graphics(here::here("images", "Dates_500x500.png"))
```

R дээр огноог ашиглах нь бусад объектын төрлүүдтэй ажиллахаас илүү анхаарал шаарддаг. Доор бид энэ үйл явцыг арай хялбар болгохын тулд зарим хэрэгсэл, жишээг санал болгож байна. Аз болоход **lubridate** гэх мэт багцуудын тусламжтайгаар, практик дадлагын үр дүнд огноог хялбархан янзалж чаддаг болно.

Боловсруулаагүй өгөгдлийг R руу импортлох үед огноог ихэвчлэн тэмдэгт (character) обьект хэмээн таньж оруулдаг бөгөөд энэ обьектыг цагийн цуврал хийх, хугацааны интервалыг тооцоолох гэх мэт огнооны ерөнхий үйлдлүүдэд ашиглах боломжгүй байдаг. Дээрээс нь огноог форматлах олон арга байдаг тул та огнооны аль хэсэг нь юу болохыг (сар, өдөр, цаг гэх мэт) танихад нь R-д туслах шаардлагатай болдог нь огноотой ажиллах процессыг улам төвөгтэй болгодог.

R дахь огноо нь өөрсдийн гэсэн объектын ангитай буюу `Date` анги юм. Энд огноо, цаг хоёуланг нь агуулсан объектуудыг хадгалдаг тусгай анги бас байдаг гэдгийг тэмдэглэх нь зүйтэй. Огноо, цагийн объектуудыг албан ёсоор `POSIXt`, `POSIXct` ба/эсвэл `POSIXlt` анги гэж нэрлэдэг (ялгаа нь чухал биш). Эдгээр объектыг албан бусаар *datetime* ангид оруулдаг.

-   Багана нь огноог агуулсан бол R-д тухайн баганыг огноо гэдгийг таниулах нь чухал.

-   Огноо бол объектын ангилал бөгөөд түүнтэй ажиллахад төвөгтэй байдаг.

-   Энд бид огноо агуулсан багануудыг `Date` анги руу хөрвүүлэх хэд хэдэн аргыг танилцуулж байна.

    <!-- ======================================================= -->

## Бэлтгэл

### Багцуудыг ачаалах {.unnumbered}

Доорх кодын хэсэг нь энэ хуудсанд шаардлагатай багцуудын ачааллыг харуулж байна. Энэхүү гарын авлагад бид **pacman** багцаас `p_load()` функцыг онцлон ашиглаж буй бөгөөд энэ функц нь шаардлагатай бол тухайн багцыг шууд суулгаж, ашиглахаар ачаалдаг. Мөн та аль хэдийн суулгасан багцуудыг **base** R-ын `library()` функц ашиглан ачаалж болно. R багцуудын талаар дэлгэрэнгүй мэдээллийг \[R суурь ойлголтууд\] хуудаснаас үзнэ үү.

```{r dates_packages, warning=F, message=F}
# Багц суулгасан эсэхийг шалгаж, шаардлагатай бол суулгаж, одоогийн сесс рүү багцыг ачаална

pacman::p_load(
  lubridate,  # огноог зохицуулах, хөрвүүлэх ерөнхий багц
  linelist,   # замбараагүй огноог "таах" функцтэй 
  aweek,      # огноог долоо хоног, долоо хоногийг огноо болгон хөрвүүлэх өөр сонголт
  zoo,        # нэмэлт огноо/цаг функцүүд
  tidyverse,  # дата менежмент болон дүрслэл
  rio)        # дата импорт/экспорт
```

### Дата импортлох {.unnumbered}

Бид Эбола тахлын зохиомол тохиолдлын датасетийг импортолж байна. Хэрэв та датаг татаж аван алхам алхмаар дагахыг хүсвэл \[Гарын авлага, дата татаж авах\] хуудасны зааврыг харна уу. Бид энэ файлыг ажлын директор дотор байгаа гэж үзэж байгаа тул энэ файлын замд дэд хавтас заагаагүй болно.

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")

```

<!-- ======================================================= -->

## Одоогийн огноо

Та **base** R дээр дараах зүйлийг хийснээр таны компьютерийн одоогийн "систем" огноо эсвэл системийн огнооцагийг авах боломжтой.

```{r}
# системийн огноог авах - энэ бол DATE анги юм
Sys.Date()

# системийн цагийг авах - энэ бол DATETIME анги юм 
Sys.time()
```

**lubridate** багцын тусламжтайгаар эдгээрийг `today()` болон `now()` функцүүдээр тус тус авах боломжтой. `date()` функц нь өдөр, сарын нэрийн хамт одоогийн огноо, цагийг харуулна.

<!-- ======================================================= -->

## Огноо руу хөрвүүлэх

Датасетийг R руу импортлосны дараа огнооны баганын утгууд "1989/12/30", "05/06/2014", эсвэл "2020 оны 1-р сарын 13" гэх мэтээр харагдаж болно. Эдгээр тохиолдолд R нь эдгээр утгуудыг тэмдэгт утга гэж оруулсан байх магадлалтай. Эдгээр утгууд нь огноо мөн... бөгөөд огнооны формат ямар байхыг R-д *хэлж өгөх* шаардлагатай (аль хэсэг нь Өдөр, аль нь Сар, аль нь Жил гэх мэт).

Ингээд хэлээд өгөхөд R эдгээр утгыг `Date` анги руу хөрвүүлдэг. Харин хөшигний цаана R огноог тоогоор хадгална (1970 оны 1-р сарын 1-ний "эх" өдрөөс хойшхи өдрийн тоо). Та огнооны энэхүү тоотой бараг харьцахгүй боловч R огноог ингэж хадгалснаар огноог үргэлжилсэн (continuous) хувьсагч гэж үзэн огноо хоорондын зайг тооцоолох зэрэг тусгай үйлдлүүдийг хийх боломжийг олгодог.

Өгөгдмөлөөр, R дахь `Date` ангийн утгууд нь YYYY-MM-DD хэлбэрээр харагдана. Энэ бүлэгт бид огнооны утгын харагдах байдлыг хэрхэн өөрчлөх талаар харуулах болно.

Доор бид баганыг тэмдэгтийн утгаас `Date` анги руу хөрвүүлэх хоёр аргыг танилцуулж байна.

[***ЗӨВЛӨМЖ:*** Та баганын одоогийн ангийг `class(linelist$date_onset)` зэргээр **base** R-ын `class()`функц ашиглан шалгаж болно. ]{style="color: darkgreen;"}

### **base** R {.unnumbered}

`as.Date()` нь объект эсвэл баганыг `Date` анги руу хөрвүүлдэг стандарт, **base** R функц юм ("D"-н том үсгийг анхаарна уу).

`as.Date()`-г ашиглахад дараахь зүйлийг шаарддаг:

-   Хэрэв та огноог тоогоор оруулж буй бол эх огноог эсвэл огноог *тэмдэгт хэлбэрээр оруулж буй бол **одоо байгаа** форматыг зааж өгнө* (Excel огнооны хэсгийг үзнэ үү)

-   Хэрэв тэмдэгтийн баганад ашигласан бол бүх огнооны утгууд яг ижил форматтай байх ёстой (хэрэв тийм биш бол **linelist** багцын `guess_dates()` функцыг ашиглаж үзнэ үү)

**Эхлээд** баганыхаа ангийг **base** R-ын `class()` функцээр шалгана уу. Хэрэв та датаныхаа ангийн талаар эргэлзэж байвал (жишээ нь "POSIXct" зэрэг анги гараад ирэх үед) эхлээд тухайн баганыг `as.character()` функц ашиглан тэмдэгт анги руу хөрвүүлээд дараа нь Date анги руу хөрвүүлэх нь хамгийн хялбар арга юм.

**Хоёрдугаарт**, `as.Date()` функц дотор `format =` аргументыг ашиглан R-д тэмдэгтийн огнооны бүрэлдэхүүн хэсгүүдийн *одоогийн* форматыг хэлж болно - аль тэмдэгтүүд нь сар, өдөр, жилийг зааж буй болон, тэдгээрийг хэрхэн тусгаарласан зэргийг. Хэрэв таны утгууд аль хэдийн R-ын стандарт огнооны форматын аль нэгэнд байгаа бол ("YYYY-MM-DD" эсвэл "YYYY/MM/DD") `format =` аргумент шаардлагагүй.

Форматлахын (`format =`) тулд доорх тусгай "strptime" товчлолуудыг ашиглан *одоогийн* огнооны форматыг илэрхийлэх тэмдэгтийн стрингийг (ишлэл дотор) оруулна. Жишээлбэл, хэрэв таны тэмдэгтийн огноо "24/04/1968" гэх мэт "DD/MM/YYYY" форматтай байгаа бол `format = "%d/%m/%Y"` ашиглан утгуудыг огноо руу хөрвүүлнэ. **Форматыг ишлэл дотор оруулах шаардлагатай. Мөн ташуу зураас, зураасыг бүү мартаарай!**

```{r eval=F}
# Date анги руу хөрвүүлэх
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

Ихэнх strptime товчиллуудыг доор жагсаав. Та `?strptime` командыг ажиллуулан бүрэн жагсаалтыг харах боломжтой.

%d = Сарын өдрийн дугаар (5, 17, 28 гэх мэт)\
%j = Жилийн өдрийн дугаар (Жулиан өдөр 001-366)\
%a = Товчилсон ажлын өдөр (Mon, Tue, Wed гэх мэт)\
%A = Бүтэн ажлын өдөр (Monday, Tuesday гэх мэт)

%w = Ажлын өдрийн дугаар (0-6, Ням гараг 0)\
%u = Ажлын өдрийн дугаар (1-7, Даваа гараг 1)\
%W = Долоо хоногийн дугаар (00-53, Даваа гараг долоо хоногийн эхлэл)\
%U = Долоо хоногийн дугаар (01-53, Ням гараг долоо хоногийн эхлэл)\
%m = Сарын дугаар (жишээ нь 01, 02, 03, 04)\
%b = Товчилсон сар (Jan, Feb гэх мэт)\
%B = Бүтэн сар (January, February гэх мэт)\
%y = 2-оронтой жил (жишээ нь 89)\
%Y = 4-оронтой жил (жишээ нь 1989)\
%h = цаг (24 цагийн цаг)\
%m = минут\
%s = секунд

%z = GMT-ээс офсет\
%Z = Цагийн бүс (тэмдэгт)

[***ЗӨВЛӨМЖ:*** `as.Date()`-ын `format =` аргумент нь таны хүсэж буй огнооны форматыг R-д хэлж буй биш бөгөөд харин командыг ажиллуулахын *өмнө* огнооны ямар хэсгүүд байгааг R-д зааж өгч буйг хэлж байгаа юм.]{style="color: darkgreen;"}

[***ЗӨВЛӨМЖ:*** `format =` аргументад таны оруулж буй огноонд байгаа *огнооны-хэсэг тусгаарлагчийг* (жишээ нь, /, -, эсвэл зай) ашиглахаа мартаж болохгүй. ]{style="color: darkgreen;"}

Утгууд нь Date ангид орсны дараа R нь тэдгээрийг стандарт формат болох YYYY-MM-DD байдлаар харуулах болно.

### **lubridate** {.unnumbered}

**lubridate** багцыг ашигласнаар тэмдэгтийн объектуудыг огноо руу хөрвүүлэх нь илүү хялбар болно. Энэ багц нь огноо, цагтай ажиллах явцыг **base** R-аас илүү энгийн бөгөөд тогтвортой болгоход зориулагдсан **tidyverse**-ийн багц юм. Эдгээр шалтгааны улмаас **lubridate**-г ихэвчлэн огноо, цагийн хувьд алтан стандартын багц гэж үздэг бөгөөд тэдэнтэй ажиллах бүрт хэрэглэхийг зөвлөдөг.

**lubridate** багц тэмдэгтийн объектуудыг огноо руу хөрвүүлэхэд зориулсан хэд хэдэн туслах функцээр хангадаг бөгөөд эдгээр нь `as.Date()`-д форматыг зааж өгөхөөс илүү хялбар бөгөөд ойлгомжтой байдаг. Эдгээр функцууд нь огнооны форматуудын товчлолын нэрээр нэрлэгдсэн бөгөөд тэдгээр нь тухайн огнооны форматтай тусгай холбоотой боловч төрөл бүрийн ялгагч, огнооны синоним (жишээ нь, 01 vs Jan vs January гэх мэт) ашиглах боломж олгодог.

```{r, }
# lubridate суулгах/ачаалах
pacman::p_load(lubridate)
```

`ymd()` функц нь огнооны утгыг **жил, сар, өдөр** гэсэн дараалалтай болгон хувиргадаг.

```{r}
# огноог жил-сар-өдөр хэлбэрээр унших
ymd("2020-10-11")
ymd("20201011")
```

`mdy()` функц нь **сар, өдөр, жил** гэсэн дарааллаар өгсөн огнооны утгыг уян хатан байдлаар хөрвүүлдэг.

```{r}
# огноог сар-өдөр-жил форматаар унших
mdy("10/11/2020")
mdy("Oct 11 20")
```

`dmy()` функц нь **өдөр, сар, жил** гэсэн дарааллаар өгсөн огнооны утгыг уян хатан байдлаар хөрвүүлдэг.

```{r}
# огноог өдөр-сар-жил форматаар унших
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- The `as.character()` and `as.Date()` commands can optionally be combined as:   -->

<!-- ```{r eval=F} -->

<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->

<!-- ``` -->

Хэрэв пайп ашиглаж байгаа бол тэмдэгтийн баганыг **lubridate** ашиглан огноо руу хөрвүүлэх нь дараах байдалтай байж болно:

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

Дууссаны дараа та баганын ангийг шалгахын тулд `class()` ажиллуулж болно.

```{r, eval=F}
# Баганын ангийг шалгах
class(linelist$date_onset)  
```

Утгууд нь Date ангид орсны дараа R нь тэдгээрийг стандарт формат болох YYYY-MM-DD байдлаар харуулах болно.

Дээрх функцууд 4 оронтой жил бүхий форматтай хамгийн сайн ажилладаг гэдгийг анхаарна уу. 2 оронтой жил ашиглахад **lubridate** зууныг нь таах гэж оролддог тул төсөөлөөгүй үр дүнд хүргэж болзошгүй.

2 оронтой жилийг 4 оронтой жил (нэг зууны) болгон хөрвүүлэхийн тулд та эхлээд тэмдэгт анги руу хөрвүүлж, дараа нь **stringr** багцын `str_glue()` функц ашиглан одоо байгаа цифрүүдийн өмнө pre-fix нэмэн нэгтгэж болно (\[Тэмдэгтүүд болон стрингүүд бүлгийг харна уу\]). Үүний дараа нь огноо руу хөрвүүлнэ.

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```

### Багануудыг нэгтгэх {.unnumbered}

Та олон тоон багануудыг нэг огнооны баганад нэгтгэхийн тулд **lubridate** багцын `make_date()` болон `make_datetime()` функцуудыг ашиглаж болно. Жишээлбэл, хэрэв таны `linelist` датафрэймд `onset_day`, `onset_month`, `onset_year` гэсэн тоон баганууд байгаа бол:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```

<!-- ======================================================= -->

## Excel огноо

Ихэнх программ хангамжууд огноог тоогоор хадгалдаг. R нь 1970 оны 1-р сарын 1-нийг эх өдөр болгон түүнээс хойш тоолон огноог хадгалдаг. Тиймээс хэрэв та `as.numeric(as.Date("1970-01-01))` гэж ажиллуулбал `0` гарах болно.

Microsoft Excel нь таны үйлдлийн системээс хамааран 1899 оны 12-р сарын 30 (Windows) эсвэл 1904 оны 1-р сарын 1-нээр (Mac) эх болгон огноог хадгалдаг. Дэлгэрэнгүй мэдээллийг энэхүү [Microsoft-ын заавраас](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system) үзнэ үү.

Excel-ийн огноо нь ихэвчлэн R руу орохдоо тэмдэгтийн оронд эдгээр тоон утгууд байдлаар импортлогддог. Хэрэв таны Excel-ээс импортолсон датасетийн огноог "41369" гэх мэт тоо эсвэл тэмдэгтээр харуулсан бол хөрвүүлэхийн тулд `as.Date()` (эсвэл **lubridate**-ийн `as_date()` функцийг) ашиглана уу. Гэхдээ **дээрх шиг "формат" өгөхийн оронд `origin =` аргументэд Excel-ийн эх огноог өгнө**.

Хэрэв Excel-ийн огноог R-д тэмдэгтийн хэлбэрээр хадгалсан бол энэ нь ажиллахгүй тул огнооны тоо нь Тоон анги эсэхийг шалгаарай!

[***ТЭМДЭГЛЭЛ:*** Та R-ийн анхдагч огнооны форматаар ("YYYY-MM-DD") эх огноог оруулах шаардлагатай.]{style="color: black;"}

```{r, eval = FALSE}
# Excel-ийн тоон огноог хөрвүүлэхдээ Excel-ийн "эх огноо"-г өгөх жишээ
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # тоон ангитай байхыг бататгах
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # Excel эх огноо ашиглан огноо руу хөрвүүлэх
```

<!-- ======================================================= -->

## Эмх цэгцгүй огноо

**linelist** багцын `guess_dates()` функц нь олон янзын форматтай огноог агуулсан "замбараагүй" огнооны баганыг уншиж, огноог стандарт формат руу хөрвүүлэхийг оролддог. Та [онлайнаар `guess_dates()`-ын талаар илүү ихийг уншиж](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html) болно. Хэрэв `guess_dates()` функцын R 4.0.2-д зориулсан хувилбар CRAN дээр байхгүй бол `pacman::p_load_gh("reconhub/linelist")` командаар суулгаж ашиглана уу.

Жишээлбэл, `guess_dates` нь "2018 оны 1-р сарын 03", "07/03/1982", "08/20/85" гэсэн тэмдэгтийн огнооны векторыг хараад дараах Огноо ангилал руу хөрвүүлнэ: `2018-01-03`, `1982-03-07`, `1985-08-20`.

```{r, }
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

Таны `guess_dates()` функцэд оруулж болох нэмэлт аргументууд:

-   `error_tolerance` - Огноог тодорхойлох боломжгүй оруулгуудын эзлэх хувийн зөвшөөрөгдөх хэмжээ (өгөгдмөл нь 0.1 эсвэл 10%)

-   `last_date` - сүүлчийн хүчинтэй огноо (өгөгдмөл нь одоогийн огноо)

-   `first_date` - эхний хүчинтэй огноо. Өгөгдмөл нь `last_date`-ээс тавин жилийн өмнөх огноо.

```{r eval = FALSE}
# guess_dates-г date_onset багана дээр ашигласан жишээ
linelist <- linelist %>%                 # linelist датасет
  mutate(
    date_onset = linelist::guess_dates(  # "linelist" багцын guess_dates() функц
      date_onset,
      error_tolerance = 0.1,
      first_date = "2016-01-01"
    )
```

<!-- ======================================================= -->

## date-time ангитай ажиллах

Өмнө дурьдсанчлан, R нь огноо болон цагийн мэдээллийг агуулсан `datetime` ангийг дэмждэг. Date ангийн нэгэн адил эдгээрийг ихэвчлэн тэмдэгтийн объектоос `datetime` объект руу хөрвүүлэх шаардлагатай болдог.

### Цаг агуулсан огноог хөрвүүлэх {.unnumbered}

Стандарт `datetime` объект нь эхлээд огноогоор форматлагдсан бөгөөд дараа нь цагийн бүрэлдэхүүн хэсэг орно - жишээлбэл *2020 оны 1-р сарын 01, 16:30*. Огнооны нэгэн адил үүнийг форматлах олон арга байдаг бөгөөд мөн олон түвшний нарийвчлал (цаг, минут, секунд) байдаг.

Аз болоход эдгээр стрингүүдийг `datetime` объект руу хөрвүүлэх **lubridate**-ийн туслах функцууд бас байдаг. Эдгээр функцууд нь төгсгөлд нь `_h` (зөвхөн цаг), `_hm` (цаг, минут) эсвэл `_hms` (цаг, минут, секунд) нэмж хавсаргасан огнооны туслах функцүүдийн өргөтгөлүүд юм (жишээ нь, `dmy_hms()`). Эдгээрийг дараах байдлаар ашиглаж болно:

Зөвхөн цаг агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

Цаг, минут агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
dmy_hm("01 January 2020 16:20")
```

Цаг, минут, секунд агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
mdy_hms("01 January 2020, 16:20:40")
```

Та цагийн бүсийг өгч болно, гэхдээ үүнийг ашигладаггүй. Цагийн бүсийн талаар энэ бүлгийн сүүл хэсгийг үзнэ үү.

```{r}
mdy_hms("01 January 2020, 16:20:40 PST")

```

Датафрэймтэй ажиллахдаа **stringr** багцын `str_glue()` функц ба тохирох **lubridate** функцийг ашиглан цаг, огнооны баганыг нэгтгэн datetime багана үүсгэж болно. **stringr** багцын талаарх дэлгэрэнгүй мэдээллийг \[Тэмдэгтүүд болон стрингүүд\] хуудаснаас үзнэ үү.

Энэ жишээнд `linelist` датафрэйм нь "цаг:минут" формат бүхий баганатай байна. Үүнийг datetime болгон хөрвүүлэхийн тулд бид хэд хэдэн алхмуудыг дагана:

Тухайн баганын голч утга ашиглан хоосон утгыг дүүргэсэн эмнэлэгт хэвтэлтийн "цэвэр" цагийн багана үүсгэнэ. **lubridate** багц хоосон утгууд дээр ажиллахгүй тул бид үүнийг хийж буй юм. Үүнийг `date_hospitalisation` баганатай нэгтгээд `ymd_hm()` функцийг ашиглан хөрвүүлнэ.

```{r, eval = FALSE}
# багцууд
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission багана нь цаг:минут бүхий форматтай
linelist <- linelist %>%
  
  # эмнэлэгт хэвтэлтийн цаг байхгүй тохиолдолд хэвтэлтийн голч хугацааг онооно
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # цаг хоосон байгаа үед
      median(time_admission),        # голч утгыг онооно
      time_admission                 # хоосон биш байвал хэвээр үлдээнэ
  ) %>%
  
    # str_glue() ашиглан огноо, цагийн багануудыг нэгтгэж нэг тэмдэгт багана үүсгэнэ 
    # дараа нь ymd_hm()-г ашиглан datetime руу хөрвүүлнэ
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```

### Зөвхөн цагийг хөрвүүлэх {.unnumbered}

Хэрэв таны датанд зөвхөн хугацаа (цаг, минут) тэмдэгт байдлаар агуулагдаж байвал та **base** R-ын `strptime()`-г ашиглан тэдгээрийг цаг болгон хувиргаж, өөрчлөх боломжтой. Жишээлбэл, эдгээр хоёр цагийн зөрүүг олж авахын тулд:

```{r}
# тэмдэгт ангийн цагууд
time1 <- "13:45" 
time2 <- "15:20"

# Цагуудыг datetime анги руу хөрвүүлнэ
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# Ялгаа нь "difftime" анги бөгөөд энд тоон цаг руу хөрвүүлж байна 
as.numeric(time2_clean - time1_clean)   # цагийн зөрүү

```

Гэхдээ огнооны утгыг заагаагүй бол огноог өнөөдөр гэж тооцдог гэдгийг анхаарна уу. **stringr** багцыг ашиглан стринг огноо болон стринг цагийг хэрхэн нэгтгэх талаар дээрх хэсгээс харна уу. `strptime()`-ийн талаар [эндээс](https://rdrr.io/r/base/strptime.html) уншина уу.

Нэг оронтой тоог хоёр оронтой тоонд хөрвүүлэхийн тулд (жишээ нь, 2 оронтой болохын тулд цаг эсвэл минутын урд тэг оруулж дэвсэх) ["Тэмдэгтүүд болон стрингүүд" хуудасны "Дэвсэх урт" хэсгийг](#str_pad) үзнэ үү.

### Цагийг гаргаж авах {.unnumbered}

Та **lubridate** багцын `hour()`, `minute()`, `second()` функцүүдийг ашиглан цагийн элементүүдийг гаргаж авч болно.

Цагийг гаргаж аваад өдрийн нэг хэсгээр нь ангилах жишээ энд байна. Бид "HH:MM" форматтай Тэмдэгт ангийн `time_admission` баганаас эхэлнэ. Нэгдүгээрт, тэмдэгтүүдийг datetime анги руу хөрвүүлэхийн тулд дээр дурдсанчлан `strptime()` ашигладаг. Дараа нь цагийг `hour()` функцээр гаргаж авахад 0-24 хүртэлх тооны аль нэг гарч ирнэ. Эцэст нь, эмнэлэгт хэвтсэн цагийг логик мэдэгдлүүд ашиглан `case_when()` функцын тусламжтайгаар Өглөө/Үдээс/Орой/Шөнө гэж ангилсан `time_period` хэмээх шинэ багана үүсгэж байна.

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

`case_when()` функцын талаар илүү ихийг мэдэхийг хүсвэл \[Дата цэвэрлэх болон үндсэн функцууд\] хуудаснаас үзнэ үү.

<!-- ======================================================= -->

## Огноотой ажиллах

**lubridate** багцыг **date/datetime** **багануудын хэсгийг гаргаж авах, огноон дээр арифметик хийх, огнооны интервалыг тооцоолох** зэрэг олон төрлийн функцэд ашиглаж болно.

Энд бид жишээнүүдэд ашиглах огноог тодорхойллоо:

```{r, }
# Date ангийн объект үүсгэх
example_date <- ymd("2020-03-01")
```

### Огнооны бүрэлдэхүүн хэсгүүдийг гаргаж авах {.unnumbered}

Та сар, өдөр, ажлын өдөр гэх мэт нийтлэг талуудыг гаргаж авч болно:

```{r}
month(example_date)  # сарын дугаар
day(example_date)    # сарын өдөр (дугаар)
wday(example_date)   # долоо хоногийн өдрийн дугаар (1-7)
```

Та мөн `datetime` объект эсвэл баганаас цагийн бүрэлдэхүүн хэсгүүдийг гаргаж авах боломжтой. Хэрэв та эмнэлэгт хэвтсэн цагийн тархалтыг харахыг хүсвэл энэ нь хэрэг болно.

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # цаг гаргаж авах
minute(example_datetime)   # минут гаргаж авах
second(example_datetime)   # секунд гаргаж авах
```

Долоо хоногуудыг харах хэд хэдэн сонголт байдаг. Доорх Эпидемиологийн долоо хоногийн хэсгийг үзнэ үү.

Хэрэв та огноог тодорхой байдлаар *харуулахыг* хүсч байгаа бол (жишээ нь "2020 оны 1-р сар" эсвэл "3-р сары 20-ны Пүрэв гараг" эсвэл "1977 оны 20-р долоо хоног") үүнийг Огноо харуулах хэсэгт тайлбарласны дагуу илүү уян хатан байдлаар хийж болно.

### Огнооны математик {.unnumbered}

Та **lubridate** багцаас тус тусын функцийг ашиглан тодорхой тооны өдөр, долоо хоног нэмж болно.

```{r}
# энэхүү огноо руу 3 өдөр нэмэх
example_date + days(3)
  
# энэ огноо дээр 7 долоо хоног нэмж, хоёр өдрийг хас
example_date + weeks(7) - days(2)
```

### Огнооны интервал {.unnumbered}

Огноо хоорондын зөрүүг дараах байдлаар тооцоолж болно:

1.  Хоёр огноо нь хоёулаа `date` анги мөн эсэхийг шалгана

2.  Хоёр огнооны хоорондох "difftime" зөрүүг гаргахын тулд хасаж болно

3.  Шаардлагатай бол дараагийн математик тооцооллыг хийхийн тулд гарсан үр дүнг тоон анги руу хөрвүүлнэ

Доор хоёр огнооны хоорондох интервалыг тооцон харуулж байна. Огноо ангийн утгууд дээр "хасах" тэмдгийг ашиглан интервалыг олох боломжтой. Гэсэн хэдий ч буцаасан утгын анги нь доор үзүүлсэн шиг "difftime" бөгөөд тоон хэлбэрт хөрвүүлэх ёстой гэдгийг анхаарна уу.

```{r}
# Жишээ огнооноос 2020 оны 2-р сарын 20-ны хоорондох зайг ол 
output <- example_date - ymd("2020-02-20")
output    # хэвлэ
class(output)
```

"Dfftime" дээр дараагийн үйлдлүүдийг хийхийн тулд үүнийг `as.numeric()` ашиглан тоон хэлбэрт хөрвүүлнэ.

Дата ажиллах үед энэ бүгдийг нэгтгэж болно - жишээлбэл:

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # багцууд ачааллах

linelist <- linelist %>%
  
  # dmy форматыг зааж өгснөөр шинж тэмдэг эхэлсэн огноог тэмдэгтээс огноо болгон хувиргана 
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # Гуравдугаар сард шинж тэмдэг нь эхлээгүй бүх тохиолдлыг шүүж хасна
  filter(month(date_onset) == 3) %>%
    
  # шинж тэмдэг эхэлсэн ба эмнэлэгт хэвтсэн өдрүүдийн хоорондох зөрүүг ол
  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)
```

Датафрэймтэй ажиллах үед тодорхой мөр дээр дээрх огнооны аль нэг нь байхгүй бол тухайн мөрийн хувьд энэхүү үйл ажиллагаа амжилтгүй болно. Үүний үр дүнд тоон утгын оронд `NA` гарч ирнэ. Тиймээс энэ баганыг тооцоололд ашиглахдаа `na.rm =` аргументыг `TRUE` гэж тохируулахаа мартуузай. Жишээлбэл:

```{r, eval = FALSE}
# Дата байгаа бүх тохиолдлын хувьд эмнэлэгт хэвтэх хоногийн голч утгыг тооцоол
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```

<!-- ======================================================= -->

## Огноо харуулах

Огноог зөв ангид хөрвүүлсний дараа та тэдгээрийг зарим тохиолдолд өөрөөр жишээлбэл "2018-01-05"-ны оронд "1-р сарын 05-ны Даваа" гэж харуулахыг хүсдэг. Та мөн харагдаж буй огнооны элементүүдээр мөрүүдийг бүлэглэхийн тулд харагдах байдлыг өөрчлөх хэрэгтэй болж магадгүй - жишээлбэл сар жилээр бүлэглэх.

### `format()` {.unnumbered}

**base** R-ын `format()` функцээр огнооны харагдах байдлыг тохируулж болно. Энэ функц нь "%" strptime товчлол (`as.Date()`-д ашигласантай ижил синтакс) бүхий хүсэж буй форматыг зааж өгсөн тэмдэгтийн стрингийг (ишлэлд) хүлээн авдаг. Хамгийн түгээмэл товчлолуудыг доор харуулав.

Тэмдэглэл: `format()`-ыг ашигласнаар утгуудыг Тэмдэгт анги руу хөрвүүлэх тул үүнийг ерөнхийдөө дүн шинжилгээний төгсгөлд эсвэл зөвхөн харуулах зорилгоор ашигладаг! Та `?strptime`-г ажиллуулснаар бүрэн жагсаалтыг харах боломжтой.

%d = Сарын өдрийн дугаар (5, 17, 28 гэх мэт)\
%j = Жилийн өдрийн дугаар (Жулиан өдөр 001-366)\
%a = Товчилсон ажлын өдөр (Mon, Tue, Wed гэх мэт)\
%A = Бүтэн ажлын өдөр (Monday, Tuesday гэх мэт)

%w = Ажлын өдрийн дугаар (0-6, Ням гараг 0)\
%u = Ажлын өдрийн дугаар (1-7, Даваа гараг 1)\
%W = Долоо хоногийн дугаар (00-53, Даваа гараг долоо хоногийн эхлэл)\
%U = Долоо хоногийн дугаар (01-53, Ням гараг долоо хоногийн эхлэл)\
%m = Сарын дугаар (жишээ нь 01, 02, 03, 04)\
%b = Товчилсон сар (Jan, Feb гэх мэт)\
%B = Бүтэн сар (January, February гэх мэт)\
%y = 2-оронтой жил (жишээ нь 89)\
%Y = 4-оронтой жил (жишээ нь 1989)\
%h = цаг (24 цагийн цаг)\
%m = минут\
%s = секунд

%z = GMT-ээс офсет\
%Z = Цагийн бүс (тэмдэгт)

Өнөөдрийн огноог форматлах жишээ:

```{r}
# форматтай өнөөдрийн огноо
format(Sys.Date(), format = "%d %B %Y")

# огноо, цагийг бүрэн авах хялбар арга (өгөгдмөл формат)
date()

# str_glue() функцийг ашиглан форматласан нэгтгэсэн огноо, цаг, цагийн бүс
str_glue("{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}")

# Долоо хоногуудыг харуулах форматыг ашиглах
format(Sys.Date(), "%Y Week %W")
```

Хэрэв `str_glue()` ашиглаж байгаа бол давхар ишлэл " дотор зөвхөн ганц ишлэл ' (дээрх шиг) ашиглах ёстойг анхаарна уу.

### Сар-жил {.unnumbered}

Огноо баганыг Сар-жил формат руу хөрвүүлэхийн тулд **zoo** багцаас `as.yearmon()` функцийг ашиглахыг зөвлөж байна. Энэ нь огноог "yearmon" анги руу хувиргаж, зохих дарааллыг хадгална. Үүнтэй харьцуулахад, `format(column, "%Y %B")` ашиглавал Тэмдэгт анги руу хөрвүүлэх ба утгуудыг цагаан толгойн дарааллаар (буруу) дараалуулна.

Доор, `date_onset` баганаас `as.yearmon()` функцийг ашиглан `yearmonth` шинэ багана үүсгэсэн байна. Үр дүнгийн утгуудын анхдагч (зөв) дарааллыг хүснэгтэд үзүүлэв.

```{r}
# шинэ багана үүсгэх
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# хүснэгт хэвлэх
table(test_zoo$yearmon)
```

Үүнтэй харьцуулахад, та зөвхөн `format()`-ыг ашигласнаар хэрхэн хүссэн харагдах байдлын форматтай болж буй боловч зөв дараалалгүй болохыг харж болно.

```{r}
# шинэ багана үүсгэх
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# хүснэгт хэвлэх
table(test_format$yearmon)
```

Тэмдэглэл: Хэрэв та `ggplot()` дээр ажиллаж байгаа бөгөөд зөвхөн огноог хэрхэн харуулахыг тохируулахыг хүсвэл `scale_x_date()` функцийн `date_labels =` аргументад strptime формат оруулахад хангалттай. Жишээ нь та `"%b %Y"` эсвэл `"%Y %b"` ашиглаж болно. \[ggplot зөвлөмж\] хуудсыг үзнэ үү.

**zoo** нь мөн `as.yearqtr()` функцийг санал болгодог бөгөөд та `ggplot()` ашиглахдаа `scale_x_yearmon()`-г ашиглаж болно.

<!-- ======================================================= -->

## Эпидемиологийн долоо хоног {#dates_epi_wks}

### **lubridate** {.unnumbered}

Датаг огноогоор нь бүлэглэх илүү өргөн хүрээний жишээнүүдийг \[Дата бүлэглэх\] хуудаснаас үзнэ үү. Доор бид өгөгдлийг долоо хоногоор бүлэглэх талаар товч тайлбарлав.

Бид ерөнхийдөө `lubridate`-ын `floor_date()` функцийг `unit = "week"` аргументын хамт ашиглахыг зөвлөж байна. Энэ нь `week_start =` аргументаар тодорхойлогдсоны дагуу огноог долоо хоногийн "эхлэл" хүртэл доош нь бүхэлддэг. Долоо хоногийн өгөгдмөл эхлэл нь 1 (Даваа гаригт) гэхдээ та долоо хоногийн аль ч өдрийг эхлэл гэж зааж өгч болно (жишээ нь, Ням гарагт 7). `floor_date()` нь олон талтай бөгөөд `unit =` аргументыг "second", "minute", "hour", "day", "month" эсвэл "year" болгон тохируулснаар төрөл бүрийн хугацааны нэгж рүү бүхэлдэхэд ашиглаж болно.

Буцаасан утга нь Date анги бүхий долоо хоногийн эхлэх огноо юм. Date анги нь `ggplot()`-д амархан танигдаж, зөв ​​эрэмбэлэгддэг тул дата зураглахад тун хэрэгтэй байдаг.

Хэрэв та зөвхөн график дотор огноог долоо хоногоор *харуулахыг* сонирхож байгаа бол энэ хуудасны Огноо харуулах хэсгийг үзнэ үү. Жишээлбэл, тархварзүйн муруйг зурахдаа та хүссэн strptime "%" товчлолоо өгснөөр огнооны харагдах байдлыг форматлаж болно. Жишээ нь, "%Y-%W" эсвэл "%Y-%U"-г ашиглан жил, долоо хоногийн дугаарыг буцаана (Даваа эсвэл Ням гарагийн долоо хоногийн эхлэлүүд тус бүрт).

### Долоо хоног тутмын тоо {.unnumbered}

`count()`, `group_by()` болон `summarise()` ашиглан дата бүлэглэх талаар дэлгэрэнгүй тайлбарыг \[Дата бүлэглэх\] хуудаснаас үзнэ үү. Товч жишээг доор харуулав.

1.  Шинэ "week" баганыг `floor_date()`-ыг `unit = "week"` аргументын хамт `mutate()` ашиглан үүсгэнэ.

2.  `count()` функцээр долоо хоног тутмын мөрийн (тохиолдлын) тоог авна; хоосон огноотой тохиолдлуудыг шүүн хасна

3.  *Бүх* долоо хоногууд мөр/тохиолдолгүй байсан ч гэсэн датанд гарч ирэхийг баталгаажуулахын тулд **tidyr** багцын `complete()` функцийг ашиглан дуусгана. Анхдагч байдлаар аливаа "шинэ" мөрүүдийн тоон утгууд нь `NA` байна, гэхдээ та тэдгээрийг нэрлэсэн лист хүлээж авдаг `fill =` аргументын тусламжтайгаар 0 болгож болно (доор, `n` нь тооны баганын нэр).

```{r}
# Долоо хоног тутмын тохиолдлын тооны нэгдсэн датасет үүсгэх
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # хоосон шинж тэмдэг эхэлсэн огноо бүхий тохиолдлуудыг хасах
  mutate(weekly_cases = floor_date(   #  шинж тэмдэг эхэлсэн долоо хоног хэмээх шинэ багана үүсгэх
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # датаг долоо хоногоор бүлэглэж, бүлэг бүрт мөр тоолох ('n' багана үүсгэх) 
  tidyr::complete(                  # тохиолдол бүртгэгдээгүй байсан ч гэсэн бүх долоо хоногууд байгааг хангах
    weekly_cases = seq.Date(          # "weekly_cases" баганыг бүрэн дараалал болгон дахин тодорхойлох
      from = min(weekly_cases),       # хамгийн бага огнооноос
      to = max(weekly_cases),         # хамгийн дээд огноо хүртэл
      by = "week"),                   # 7 хоногоор
    fill = list(n = 0))             # n тооны баганад NA-г 0-ээр бөглөх
```

Энд шинээр үүссэн датафрэймийн эхний мөрүүд байна:

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Epiweek хувилбарууд {.unnumbered}

**lubridate** нь мөн `week()`, `epiweek()`, `isoweek()` гэсэн тус бүр нь бага зэрэг өөр эхлэх огноо болон бусад нюансууд бүхий функцуудтай болно. Гэхдээ ихэнх тохиолдолд `floor_date()` нь танд хэрэг болох ганц функц байдаг. Эдгээр функцүүдийн дэлгэрэнгүйг консол руу `?week` гэж оруулснаар эсвэл [эндээс](https://www.rdocumentation.org/packages/lubridate/versions/1.7.4/topics/week) баримт бичгийг уншина уу.

Та эпидемиологийн долоо хоногийг тогтоохын тулд **aweek** багцыг мөн ашиглаж болно. Та энэ талаар [RECON вэбсайтаас](https://www.repidemicsconsortium.org/aweek/) илүү ихийг уншиж болно. Энэ нь `date2week()` болон `week2date()` функцтэй бөгөөд долоо хоногийн эхлэх өдрийг `week_start = "Monday"` аргументээр тохируулах боломжтой. Хэрэв та "долоо хоног" маягийн гаралтыг (жишээ нь "2020-W12") авахыг хүсвэл энэ багц хамгийн хялбар юм. **aweek** багцын өөр нэг давуу тал нь `date2week()`-г огнооны баганад хэрэглэх үед буцаасан багана (долоо хоногийн формат) автоматаар Фактор анги болон тухайн хугацааны бүх долоо хоногийн түвшнийг багтаадаг (ингэснээр дээр үзүүлсэн `complete()` функцын нэмэлт алхамаас зайлсхийдэг). Гэсэн хэдий ч **aweek** багцад огноог сар, жил гэх мэт бусад цагийн нэгж рүү бүхэлдэх функц байхгүй.

"Долоо хоног" форматыг ("2020 W12") харуулахад тохиромжтой цаг хугацааны цувралын өөр нэг хувилбар бол \[Цагийн цуваа ба дэгдэлт илрүүлэх\] хуудсанд үзүүлсэн шиг **tsibble** багцын `yearweek()` функц юм.

<!-- ======================================================= -->

## Огноо/цагийн бүсийг хөрвүүлэх

Өөр өөр цагийн бүсийн дата байгаа үед энэ датаг нэгдсэн цагийн бүсэд оруулан стандартчилах нь ихэвчлэн чухал байдаг. Ихэнх тохиолдолд датаны цагийн бүсийн бүрэлдэхүүн хэсгийг гараар кодлох шаардлагатай байдаг тул энэ нь нэмэлт бэрхшээл учруулдаг.

R-д *datetime* объект бүр цагийн бүсийн бүрэлдэхүүнтэй байна. Бүх огнооны объектууд нь өгөгдмөл байдлаар ашиглаж буй компьютерийн орон нутгийн цагийн бүсийг агуулдаг бөгөөд цагийн бүсүүд ихэвчлэн зуны цагаар өөрчлөгддөг тул энэ нь ерөнхийдөө нэрлэсэн цагийн бүсээс илүү *тухайн байршилд* зориулагдсан байдаг. Огнооны баганыг харуулсан үйл явдлыг тодорхой цаг хугацаанд хамааруулах боломжгүй тул огнооны цагийн бүрэлдэхүүн хэсэггүйгээр цагийн бүсийг үнэн зөвөөр нөхөх боломжгүй бөгөөд тийм учир цагаар хэмжигдэх хугацааны шилжилтийг үндэслэлтэй тооцож чаддаггүй.

Цагийн бүстэй харьцахын тулд **lubridate**-д хэд хэдэн туслах функцууд байдаг бөгөөд эдгээрийг огнооны объектын цагийн бүсийг орон нутгийн цагийн бүсээс өөр цагийн бүс болгон өөрчлөхөд ашиглаж болно. Datetime объектод tz өгөгдлийн сангийн хүчинтэй цагийн бүсийг өгөх замаар цагийн бүсийг тохируулдаг. Эдгээрийн жагсаалтыг доорх линкээс олж болно - хэрэв таны ашиглаж байгаа байршил энэ жагсаалтад байхгүй бол цагийн бүсийн ойролцоох томоохон хотуудын цагийн бүсийг ашиглаж болно.

<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>

```{r}
# баганад одоогийн цагийг оноох
time_now <- Sys.time()
time_now

# with_tz()-г ашиглан цагийг ӨӨРЧЛӨХИЙН зэрэгцээ баганад шинэ цагийн бүс оноох
time_london_real <- with_tz(time_now, "Europe/London")

# force_tz()-г ашиглан цагийг хэвээр ХАДГАЛАХЫН зэрэгцээ баганад шинэ цагийн бүс оноох
time_london_local <- force_tz(time_now, "Europe/London")


# Энэ кодыг ажиллуулахад ашигласан компьютерийг Лондонгийн цагаар тохируулаагүй тохиолдолд цагийн зөрүү (компьютерийн цагийн бүсээс Лондон хүртэлх цагийн зөрүү) байх болно гэдгийг анхаарна уу.
time_london_real - time_london_local

```

Энэ нь хийсвэр мэт санагдаж болох бөгөөд хэрэв хэрэглэгч өөр цагийн бүстэй датан дээр ажиллахгүй тохиолдолд ихэвчлэн шаардлагагүй байдаг.

<!-- ======================================================= -->

## Хоцрох болон түрүүлэх тооцоолол

`lead()` болон `lag()` нь **dplyr** багцын функцууд бөгөөд ихэвчлэн тоон эсвэл огнооны векторын өмнөх (хоцорсон) эсвэл дараагийн (түрүүлсэн) утгуудыг олоход тусалдаг. Энэ нь цаг хугацааны нэгж хоорондын өөрчлөлт/ялгааг тооцоолоход хэрэг болно.

```{r, echo=F}
counts <- import(here("data", "example", "district_weekly_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm=T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"), fill = list(cases_wk = 0))
```

Та одоогийн болон өмнөх долоо хоногийн тохиолдлын зөрүүг тооцоолохыг хүсч байна гэж бодъё. Датаг доор үзүүлсэн шиг долоо хоног бүрийн тоогоор эхний байдлаар өгсөн байна.

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**`lag()` эсвэл `lead()`-ийг ашиглах үед датафрэймийн мөрүүдийн дараалал нь маш чухал юм! - Таны огноо/тоо өсөх эсвэл буурах дараалалтай эсэхийг анхаарч үзээрэй**

Эхлээд өмнөх (хоцорсон) долоо хоногийн утгыг агуулсан шинэ багана үүсгэ.

-   `n =` (сөрөг бус бүхэл тоо байх ёстой) аргумент ашиглан ухрах/урагшлах нэгжийн тоог тохируулна

-   Байхгүй мөрүүдэд (жишээ нь, хоцорсон утга байх боломжгүй эхний мөр) байршуулсан утгыг тодорхойлохын тулд `default =` аргументыг ашиглана уу. Анхдагч байдлаар энэ нь `NA` байна.

-   Хэрэв датаны мөрүүд таны лавлах баганаар эрэмбэлэгдээгүй бол `order_by = TRUE` аргументыг ашиглана.

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Дараа нь хоёр тохиолдлын баганын ялгаа болох шинэ багана үүсгэ:

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Та `lead()` болон `lag()`-ын талаар [эндээс](https://dplyr.tidyverse.org/reference/lead-lag.html) эсвэл консол дээрээ `?lag` гэж оруулснаар дэлгэрэнгүй уншиж болно.

<!-- ======================================================= -->

## Нэмэлт материалууд

lubridate багцын [tidyverse хуудас](https://lubridate.tidyverse.org/)

lubridate багцын RStudio [cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)

R for Data Science номын [огноо, цагийн тухай хэсэг](https://r4ds.had.co.nz/dates-and-times.html)

[Онлайн хичээл](https://www.statmethods.net/input/dates.html) [Огнооны форматууд](https://www.r-bloggers.com/2013/08/date-formats-in-r/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/dates.Rmd-->

# Карактер ба стрингс

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```

Энэхүү хэсэгт карактер болон стрингс утгыг (залгаа карактерүүд) **stringr** багц ашиглаж шалгаж, янзлах талаар үзэх болно ("strings").

1.  Нэгтгэх, эрэмбэлэх,хуваах, дараалал солих - `str_c()`, `str_glue()`, `str_order()`, `str_split()`\

2.  Цэвэрлэх болон жигдрүүлэх

    -   Уртыг тохируул - `str_pad()`, `str_trunc()`, `str_wrap()`\
    -   Үсэгний том жижигийг өөрчлөх - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`\

3.  Байрлалыг тогтоож, орлуулах - `str_length()`, `str_sub()`, `word()`\

4.  Бүтэц, хэв маяг

    -   Илрүүлж, байрлалыг олох - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`\
    -   Хувиргаж, солих - `str_sub()`, `str_replace_all()`\

5.  Regular expressions ("regex")

Тайлбарлахад хялбар болгохын тулд ихэнх жишээг карактерийн богино векторууд дээр харуулсан. Гэсэн хэдий ч эдгээр жишээг хүснэгт, баганад дээр хэрэгжүүлэх боломжтой юм.

Энэхүү хэсгийг боловсруулахад [stringr vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) дэх материалаас их ашигласан.

<!-- ======================================================= -->

## Бэлтгэл

### Багцыг ачааллах {.unnumbered}

**stringr** болон бусад **tidyverse** багцыг татаж авч, ачааллана.

```{r}
# Багцыг татаж ав/ачаалла
pacman::p_load(
  stringr,    # стрингс дээр ажиллах функцуудын иж бүрдэл
  tidyverse,  # дата янзлахад хэрэгтэй
  tools)      # гарчигийг хувиргахад хэрэглэнэ

```

### Дата импортлох {.unnumbered}

Энэ хэсгийн дасгалд Эболагийн дэгдэлтийг загварчилсан дата `linelist` -ын цэвэрлэгдсэн хэлбэрийг ашиглах болно. Дасгалуудыг дагаж хийхийг хүсвэл <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линк дээр дарж, "clean" гэсэн linelist дээр дарж татаж авна уу</a> (.rds файл хэлбэрээр буй). Датаг импортлохдоо **rio** багцын `import()` функцыг хэрэглэ ( .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг - [Import and export] хэсгээс нэмж уншна уу).

```{r, echo=F}
# linelist -ийг R - луу оруул
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# case linelist -ийг импортло
linelist <- import("linelist_cleaned.rds")
```

linelist -ийн эхний 50 мөрийг дор харуулав.

```{r, message=FALSE, echo=F}
# linelist -ийг хүснэгт хэлбэрээр харуул
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Нэгтгэх, хуваах, эрэмбэлэх

Энэхүү хэсгийн агуулга:

-   `str_c()`, `str_glue()`, `unite()` -аар стрингсийг нэгтгэх\
-   `str_order()` стрингсийг эрэмбэлэн байрлуулах\
-   `str_split()`, `separate()` стрингсийг хуваах

<!-- ======================================================= -->

### Стрингсийг нэгтгэх {.unnumbered}

Олон стрингсийг нэгтгэж, залгахдаа **stringr** -ийн `str_c` -ийг ашиглахыг зөвлөж байна. Хэрэв таны нэтгэх гэж буй карактерууд салангид утгууд бол тусдаа аргументууд болгон оруулж таслалаар зааглаж өгнө.

```{r}
str_c("String1", "String2", "String3")
```

Оруулж буй аргументуудын дунд зааглах тэмдэгтийг `sep =` ээр тохиуруулж болно (таслал, зай, шинэ мөр `"\n"` гэх мэт)

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

`str_c()` -д олон *вектор* аргумент оруулах үед `collapse =` аргумент хэрэг болнд. Ингэснээр үүсэх векторууд хоорондоо зааглагдсан нэг урт элемент болно.

Доорхи жишээ хоёр векторыг (овог, нэр) хэрхэн нэг болгож нэгтгэхийг харуулсан. Мөн нутаг дэвсгэрийн нэр болон тохиолдлын тоог энэ мэтээр нэгтгэж бас болно. Жишээнд:

-   `sep =` тэмдэгт нэр, овог болгоны дунд гарч ирнэ\
-   `collapse =` тэмдэгт хүн тус бүрийн дунд гарч ирнэ

```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# оруулсан аргумент болгоны дунд sep -ийн тэмдэг гарч ирж, элементү болгоны дунд collapse -ын тэмдэгт гарч ирж байна
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Тэмдэглэл: Хэрэв дээрхи шиг стрингсүүд хавсарч, шинэ мөр үүсгэн харуулах бол өгүүлбэрээ бүтнээр нь `cat()` хийснээр зөв хэвлэгдэж харагдна.

```{r}
# шинэ мөрөнд зөв хэвлэхийн тулд өгүүлбэрээ бүтнээр нь cat()-д хийнэ үү
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```

<!-- ======================================================= -->

### Динамик стрингс {.unnumbered}

Стрингст динамик R код оруулах тохиолдолд `str_glue()` -ийг хэрэглэдэг. Графикт динамик тайлбар хийхэд энэ функцыг ашиглах нь их тохиромжтой. Үүнийг дор харуулав:

-   Доторх бүх агуулга нь давхар хашилтад бичигднэ `str_glue("")`\
-   Аливаа динамик код эсвэл урьдчилан тодорхойлсон утгуудыг `{}` хээтэй хаалтын доторх давхар хашилтын дотор байрлуулна. Нэг `str_glue()` коммандад олон хээтэй хаалт `{}` хийж болно.\
-   Хашилт '' -ыг тэмдэгтэн утганд оруулж харуулахын тулд *дан* хашилтыг давхар хашилтанд дотор оруулж бичнэ (жишээ болгож огноог хэрхэн бичихийг дор харуулсан)\
-   Зөвлөгөө: `\n` шинэ мөр эхлүүлдэг болно\
-   Зөвлөгөө: огнооны харагдах байдлыг `format()` -аар тохируулж, `Sys.Date()` -аар одоогийн огноог харуулдаг.

Графикт динамик тайлбар хийх жишээ:

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Мөн `str_glue()` -дотор стрингс дундаа хээтэй хаалтан дотор орлуулагч оруулаад, кодыг нь тусдаа `str_glue()` аргумент байдлаар араас нь бичиж болно (доор жишээнд харуулсан). Ингэж бичих нь урт текстийг уншихад ойлгомжтой болгож өгдөг.

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```

**Дата хүснэгтээс гаргаж авах**

Заримдаа хүснэгт доторх датаг гаргаад дарааллуулан өрж тавих шаардлага гардаг. Нутаг дэвсгэр, шинэ тохиолдол, нийт тохиолдлын талаарх мэдэгдллийг хүснэгтээс хэрхэн гаргаж авах талаар жишээг дор харуулав.

```{r}
# тохиолдолдтой хүснэгт үүсгэ
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Хүснэгтийн мөрөнд буй датаг `str_glue_data()` -аар гаргаж авдаг.

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```

**Стрингсийг мөр дагуулж нэгтгэх**

Хүснэгтийн багана дах утгыг "хуйлах" буюу олон мөрүүдийг нэгтгэж нэг мөрд багтаагаад доторх утгыг нь тусгаарлагчаар тусгаарлах шаардлагатай бол ["rolling-up" values](#str_rollup) хуудасны [De-duplication] хэсгийг уншна уу.

**Хүснэгтийг нэг шугаманд багтаах**

Үүсгэсэн текстээ `str_c()` -ээр нэг шугаманд багтаахдаа (хүснэгт, баганын нэрсийг зааж өгнө) `sep =` болон `collapse =` аргументийг нэмж тохируулна.

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

pre-fix -ээр "Шинэ Тохиролдол:" гэсэн үгийг текстийнхээ өмнө автоматаар гардаг болгож болно. Ингэхдээ `str_c()` функц дотор оруулж бичнэ ("Шинэ Тохиолдол:" анхны `str_c()` дотор оруулчихвад олон дахин бичигдчихдэг.

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```

### Баганыг нэтгэх {#str_unite .unnumbered}

Багануудын карактер утгыг **tidyr**-ын `unite()` функцээр нэгтгэдэг. Энэ нь `separate()` функцын эсрэг үйлдэл.

Шинээр үүсгэх баганын нэрийг оруулаад, нэтгэх багануудын нэрийг оруулна.

-   Нэтгэсэн багана дах утгын default тусгаарлагч нь доогуур зураас `_`. Үүнийг `sep =` аргументэд тохируулга өгснөөр өөрчилж болно.\
-   `remove =` Хүснэгтээс нэгтгэлд оруулсан багануудыг хасна (default -аар TRUE)\
-   `na.rm =` нэтгэж байх явцдаа дутуу утгыг хасна (default -аар FALSE)

Эдгээрийг богино жишээгээр тайлбарлав:

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # 1-р өвчтөн
                "chills, aches, pains",        # 2-р өвчтөн
                "fever",                       # 3-р өвчтөн
                "vomiting, diarrhoea",         # 4-р өвчтөн
                "bleeding from gums, fever",   # 5-р өвчтөн
                "rapid pulse, headache"),      # 6-р өвчтөн
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```

```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Жишээ хүснэгт:

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Доор жишээнд шинж тэмдэг бичсэн гурван баганыг нэгтгэв:

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # Шинээр нэгтгэж үүсгэх баганын нэр
    c("sym_1", "sym_2", "sym_3"), # Нэтгэх баганууд
    sep = ", ",                   # Нэтгэсэн баганад хэрэглэх тусгаарлагч
    remove = TRUE,                # TRUE гэж өгснөөр нэгтгэлд оруулсан багануудыг хүснэгтээс хасах
    na.rm = TRUE                  # TRUE гэж өгснөөр нэтгэх явцад дутуу утгууд хасагдна
  )
```

<!-- ======================================================= -->

### Хуваах {.unnumbered}

Ямар нэг хэв шинжид үндэслэн стрингсийг хуваах бол `str_split()`-ийг хэрэглэдэг. Энэ функц стрингсийг заасны дагуу шалгаж, хуваагаад шинээр хуваагдсан утгуудаас бүрдсэн карактер вектортой `list` -ийг үүсгэдэг.

Доорхи энгийн жишээгээр нэг стрингсийг хэрхэн гурав хуваахыг харуулав. Хуваагдсан дата `list` хэлбэртэй үүсдэг ба анх өгөгдсөн стрингс тус бүрт нэг элэмент (карактер вектор) үүсгэсэн байдаг. Хэрэв `simplify = TRUE` гэж өгвөл карактер матрикс үүсгэдэг.

Энэхүү жишээнд нэг стрингсийг `str_split()`-д өгөгдхөд нэг элементтэй list үүсч байна. Энэ элэмент гурван карактер утгаас бүртдсэн вектор байна.

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Үүссэн обьектийг хадгалчихвал цаашид дөрвөлжин хаалтыг ашиглан хүссэн n-дэх утгаа сугалж гаргах боломжтой болно. Ийм синтаксыг дараахь байдлаар бичдэг: `the_returned_object[[1]][2]` комманд эхний элементийн стрингс утгуудын хоёрдах утгыг гаргаж ирнэ ("fever"). [R basics] -ээс элэментэд орох гэсэн хэсгийг нэмж уншна уу.

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # list-ийн эхний элэментийн 2 дах утгыг гаргаж ирэх 
```

`str_split()` -д стрингсийг олноор нь өгч буй тохиолдолд үүсэх листний элэментийн тоо мөн олон болдог.

```{r}
symptoms <- c("jaundice, fever, chills",     # 1-р өвчтөн 
              "chills, aches, pains",        # 2-р өвчтөн
              "fever",                       # 3-р өвчтөн
              "vomiting, diarrhoea",         # 4-р өвчтөн
              "bleeding from gums, fever",   # 5-р өвчтөн
              "rapid pulse, headache")       # 6-р өвчтөн

str_split(symptoms, ",")                     # өвчтөн болгоны шинж тэмдгийг хуваах
```

"Карактер матрикс" үүсгэх шаардалгатай бол `simplify = TRUE` гэж тохируулна. Матрикс байгуулах нь цаашид багана бий болгоход хэрэгтэй байдаг.

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Мөн `n =` аргументээр хэдэн хэсэг болгож хуваахаа зааж өгч болно. Доорхи жишээнд хуваагдах тоог 2-оор хязгаарласан байна. Энэ заасан тооноос хойшхи таслалууд хоёр дах утганд хамрах болно.

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Тэмдэглэл -дээрхитэй ижил үр дүнг `str_split_fixed()` функцээр үйлдэж болно. Энэ функцэд `simplify` аргументийг өгөх шаардлагагүй харин баганын тоог заавал зааж өгөх шаардлагатай (`n`).*

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```

### Баганыг хуваах {.unnumbered}

Хүснэгтийн баганыг **dplyr**-ын `separate()`-ээр хуваавал илүү хялбар. Энэ функц карактер баганыг олон багана болгож хэсэглэн хуваадаг.

Жишээ нь энгийн нэгэн хүснэгт `df` байна гэж бодьё ( [unite section](#str_unite) хэсэгт нэгтгэгдсэн). Үүнд `case_ID`, болон өвчний шинж тэмдэг (`symptoms`) болон эмчилгээний үр дүн тус тус бичсэн баганууд байв. Бид `symptoms` баганын утгыг задалж нэг шинж тэмдэг нэг багана болж задарсан олон баганууд үүсгэх хэрэгтэй болов.

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

`separate()`хэрвээ pipe холбоосонд залгаатай бол эхлээд хуваагдах баганыг зааж өгнө. Үүний дөраа `into =` аргументнд *шинээр* үүсгэх баганын нэрсийг вектор хэлбэрээр `c( )` дотор оруулж бичнэ. Доор үзүүлсэн жишээнд харуулсан.

-   `sep =` зааглагч, тэмдэгт эсвэл тоо байж болно (interpreted as the character position to split at)

-   `remove =` default нь FALSE, ашиглагдаж орсон баганыг устгана\

-   `convert =` default нь FALSE, карактер хэлбэрт буй "NA"-г `NA` -руу хувиргана\

-   `extra =` шинээр багана үүсгэсний дараа багана болж ороогүй утга илүү гарвал дараахь нөхцлүүдээр тохируулдаг.

    -   `extra = "warn"` анхааруулга гарч ирэх боловч илүү утгууд устгагдна (**default**)\
    -   `extra = "drop"` анхааруулга гарч ирэхгүйгээр илүү утгууд устгагдна\
    -   **`extra = "merge"into`-д зааж өгсөн баганын тоонд хуваах болно - *гэхдээ бүх датаг хадгалж үлднэ***

Доорхи жишээнд `extra = "merge"` -ийг хэрэглэхэд ямар ч дата устгагдаагүй байна. Хоёр шинэ багана үүссэн ба үүнээс илүү гарсан хэсэг нь хоёр дах баганадаа үлдсэн байна:

```{r}
# гурав дах шинж тэмдэг хоёр дах утганд нэгтгэгдсэн
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

When the default `extra = "drop"` is used below, a warning is given but the third symptoms are lost:

```{r}
# гуравдах шинж тэмдэг алдагдсан байна
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```

[***АНХААРУУЛГА:*** Хэрэв `into` -д хангалттай тоог оруулахгүй бол дата тайрагдаж болохыг анхаар.]{style="color: orange;"}

<!-- ======================================================= -->

### Цагаан толгойн дарааллаар эрэмбэлэх {.unnumbered}

Олон стрингсүүдийг цагаан толгойн дарааллаар эрэмбэлж болно. `str_order()` функц дарааллын дугаарыг үүсгэж, `str_sort()` дарааллаар нь эрэмбэлж байрлуулдаг.

```{r}
# стрингс
health_zones <- c("Alba", "Takota", "Delta")

# цагаан толгойгоор дарааллаар дугаарлана
str_order(health_zones)

# цагаан толгойн дарааллаар эрэмбэлэн байрлуулна
str_sort(health_zones)
```

Өөр хэлний цагаан толгой хэрэглэх бол `locale =` аргументээр тохируулдаг. `locale =`-д орох жагсаалтыг R console-д `stringi::stri_locale_list()` гэж бичиж гаргаж ирнэ.

<!-- ======================================================= -->

### base R -ын функцууд {.unnumbered}

Векторуудыг бүхэлд нь карактерлуу хувиргаад, нэгтгэдэг `paste()`, `paste0()` гэсэн функцууд **base** R-т бий. Эдгээр нь `str_c()`-тэй төстэй боловч бичигдэх синтаксаараа арай өөр - хаалтан дотор, хэсэг тус бүрийн дунд таслал оруулах хэрэгтэй болдог. Эдгээр хэсгүүд нэг бол карактер текст (хашилтанд бичигдна) эсвэл тодорхой кодын обьектууд байна (хашилтгүй бичигднэ). Жишээ нь:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep =` болон `collapse =` аргументыг тохируулж болно. `paste()` бол `sep = " "` гэсэн аргументтэй `paste0()` (зай авахгүй) гэсэн үг .

## Цэвэрлэх болон жигдрүүлэх

<!-- ======================================================= -->

### Үсгийн том жижигийг өөрчлөх {.unnumbered}

Стрингс дата янзалж байхад үсгийн том жижигийг тохируулах шаадрдлага их гардаг. Ийм стрингсүүдийн жишээнд нутаг дэвсгэрийн нэрс ордог. Үүнд **stringr**-ын `str_to_upper()`, `str_to_lower()`, `str_to_title()` нарыг дор жишээнд харуулсан шиг хэрэглэнэ.

```{r}
str_to_upper("California")

str_to_lower("California")
```

Мөн \*base\*\* R-ын `toupper()`, `tolower()`-аар адил үр дүнд хүрч болно.

**Гарчигны үсгийн том жижиг**

Бүх үгсийн эхний үсгийг томоор бичих бол `str_to_title()`-ийг хэрэглэнэ:

```{r}
str_to_title("go to the US state of california ")
```

**tools** багцын `toTitleCase()` -ыг хэрэглэвэл дээрх үйлдлийг арай боловсронгуй гүйцэтгэдэг ("to", "the", "of" зэрэг зарим туслах үгс том болж хувирахгүй).

```{r}
tools::toTitleCase("This is the US state of california")
```

`str_to_sentence()` -ээр стрингийн зөвхөн эхний үсгийг том болгоход хэрэглэнэ.

```{r}
str_to_sentence("the patient must be transported")
```

### Уртыг тааруулах {#str_pad .unnumbered}

Стрингст доод уртын хэмжээг хэд байхыг зааж өгч болох ба үүнийг `str_pad()` -аар гүйцэтгэнэ. Уртыг заасан хэмжээнд хүргэхийн тулд нэмдэг default тэмдэгт нь хоосон зай (space) боловч `pad =` аргументэд үүнийг сольж өгч болно.

```{r}
# өөр өөр урттай ICD  кодын стрингсүүд
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD кодын баруун талд 7 карактер нэмж стрингсүүдийн уртыг тэнцүүлнэ
str_pad(ICD_codes, 7, "right")

# зай авахын оронд цэг нэм
str_pad(ICD_codes, 7, "right", pad = ".")
```

Доорхи жишээнд 0 -оор эхэлдэг (минут цаг гэх мэт) тоон утгуудыг дор хаяж 2 оронтой байлгахын тулд урд талдаа `pad = "0"` -гэж тохируулсан.

```{r}
# 2 орон болтол нь урд нь 0-ыг нэмнэ (цаг/минут)
str_pad("4", 2, pad = "0") 

# "цаг" гэсэн тоон багана нэм
# hours <- str_pad(hours, 2, pad = "0")
```

### Огтлох {.unnumbered}

`str_trunc()` -ээр стрингсийн дээд уртыг зааж өгнө. Хэрэв стрингс энэнээс урт бол огтлогддог (богиносно). Гэхдээ анхны утга урт байсныг сануулж эллипсис буюу гурван цэг (...) ард нь нэмж өгдөг. Гурван цэг нь өөрөө уртад тоологдох болохыг анхаар. Гурван цэгийн оронд өөр тэмдэг оруулахдаа `ellipsis =` аргументийг ашиглана. `side =` аргументээр гурван цэг огтлогдсон стрингсийн аль талд байрлахыг зааж өгнө ("зүүн", "баруун", "төв").

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```

### Уртыг жигдрүүлэх {.unnumbered}

Уртын дээд хэмжээг `str_trunc()` -аар зааж өгдөг бол хэт богино стрингсийг `str_pad()`-аар заасан цэг хүртэл сунгаж болдог. Доорх жишээнд уртын дээд хэмжээг 6 гэж заасан (ингэснээр нэг утга огтлогдсон). Үүний дараа их богино хэмжээтэй нэг стрингс байгааг 6 болгож уртасгасан.

```{r}
# Өөр урттай бичигдсэн ICD код
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# уртын дээд хязгаарыг 6 болгох
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# доод хязгаарыг 6 болгож уртасга
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```

### Илүү гарсан хоосон зайг арилгах {.unnumbered}

Стрингc утганд нэмэлт хоосон зай, шинэ мөр (`\n`), таб (`\t`) зэрэг илүүдлээр орсон бол эдгээрийг `str_trim()` - ээр тайрч болно. Тайрах талын байрлалыг `"right"` `"left"`, `"both"` гэж зааж өгч болно ( жишээ нь `str_trim(x, "right")`.

```{r}
# ID дугааруудын баруун талд илүү зай байна
IDs <- c("provA_1852  ", # 2 орон илүү зай
         "provA_2345",   # илүү зай байхгүй
         "provA_9460 ")  # 1 орон илүү зай 

# ID дугаартай стрингсийн зөвхөн баруун талын илүү зайг тайрах
str_trim(IDs)
```

### Давтагдсан хоосон зайг арилгах {.unnumbered}

Стрингсийн *завсар* хоосон зай давтагдсан бол `str_squish()`-ээр үүнийг янзалж болно. Давхар хоосон зай нэг хоосон зай болдог. Стрингсийн хажуугийн хоосон зай, шинэ мөр, таб -ыг `str_trim()` -ээр янзалж болно.

```{r}
# Эх текстийн завсарт хэт их зай авсагдсан байна
str_squish("  Pt requires   IV saline\n") 
```

Эдгээр функцын талаарх нэмэлт мэдээллийг R console -д `?str_trim`, `?str_pad` гэсэн комманд уншуулж авна уу.

### Параграф болгож нэгтгэх {.unnumbered}

Ямар ч бүтэц, хэвгүй үргэлжилсэн текстийг нэтгэж, бүтэцжүүлж, мөрийн уртыг зааж өгөн параграф хэвлбэрт оруулах бол `str_wrap()` -ыг хэрэглэ. Мөрний хэр урт байхыг зааж өгснөөр текст дундуур мөрүүд алгоритмын дагуу бий болж параграф хэлбэрт орно (жишээ дор харуулсан).

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

Дээрх коммандын үр дүнг хэвлэх бол **base** -ын `cat()` -д функц дотор коммандаа уншуулна уу.

```{r}
cat(str_wrap(pt_course, 40))
```

<!-- ======================================================= -->

## Байрлалаар нь янзлах

### Карактерийг байрлалаар гаргаж ирэх {.unnumbered}

Стрингсийг хэсэглэж гаргаж авах шаардлагтай үед `str_sub()` -ийг хэрэглэдэг. Энэхүү функц гурван үндсэн аргумент авдаг:

1)  карактер вектор(-ууд)\
2)  эхлэх байрлал\
3)  дуусах байрлал

Байрлалын дугаарлах талаар:

-   Хэрэв байрлал эерэг бол стрингсийн зүүн үзүүрээс эхэлж тоологдсон гэсэн үг\
-   Хэрэв байрлал сөрөг бол стрингсийн баруун үзүүрээс эхэлж тоологдсон гэсэн үг\
-   Байрлалын дугаар нь нээлттэй (inclusive)\
-   Стрингсээс гадуур байрлал огтлогддог (устгагдна).

Дор "pneumonia" гэсэн стрингсийг жишээ болгож үзүүлэв:

```{r}
# зүүн талын үзүүрээс тоолж гуравдах орноос эхэлж гурав дах орон дээр дуусна (зүүн талаас гурав дах үсэг)
str_sub("pneumonia", 3, 3)

# 0 гэсэн байрлал байхгүй 
str_sub("pneumonia", 0, 0)

# зүүн талаас 6 даха орноос баруун талаас 1 дэх хүртэл
str_sub("pneumonia", 6, -1)

# баруун талаас 5 дахаас орноос баруун талаас 2 дах хүртэл 
str_sub("pneumonia", -5, -2)

# зүүн талаасаа 4 дэх орноос стрингсийн гадна давж гартал
str_sub("pneumonia", 4, 15)
```

### Үгийн байрлалаар гаргаж ирэх {.unnumbered}

Стрингсээс n-дүгээр 'үгийг' гаргаж авахдаа мөн **stringr**-ийн `word()`функцыг хэрэглэдэг. Эхлээд шүүлт хийх стрингсээ оруулна. Үүнээс тасалж авах хэсгийн эхлэх үгийн байрлал, төгсгөл үгийн байрлалыг зааж өгнө.

Үүссэн стрингст үг хоорондын завсар орох default тэмдэгт нь хоосон зай боловч `sep =` -д үүнийг сольж болно (жишээ нь `sep = "_"` доогуур зураасыг оруулахаар зааж өгч болно).

```{r}
# Шүүлт хийх стрингс
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# Стрингс тус бүрийн 1 дэхээс 3д ах үгийг гаргаж ирэх
word(chief_complaints, start = 1, end = 3, sep = " ")
```

### Карактерийн байрлалаар орлуулах {.unnumbered}

Стрингсийн нэг хэсэгт өөрчлөлт оруулах шаардлагтай бол `str_sub()` болон (`<-`) оноогч операторыг хамтарч хэрэглэнэ.

```{r}
word <- "pneumonia"

# 3,4 дүгээр карактерийг X -ээр орлуул
str_sub(word, 3, 4) <- "XX"

# Хэвлэ
word
```

Дээрхи жишээг стрингсийн векторт хэрэглэж үзье (эсвэл багана). "HIV"-ийн хэмжээ уртасч байгааг анзаарна уу.

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# 3,4 дүгээр карактерийг X -ээр орлуул
str_sub(words, 3, 4) <- "XX"

words
```

### Уртыг шалга {.unnumbered}

```{r}
str_length("abc")
```

**base** R-ын `nchar()` -ыг бас хэрэглэж болно.

<!-- ======================================================= -->

## Хэв маяг

Аливаа *хэв маягт* тааруулан илрүүлэх, байрлуулах, гаргаж авах, тааруулах, орлуулах, хуваах үйлдлйиг хийдэг функцууд **stringr** багцад буй .

<!-- ======================================================= -->

### Хэв маягийг илрүүлэх {.unnumbered}

Стрингс доторх аливаа хэв маягийг `str_detect()` -ээр хайж, илрүүлдэг. Эхлээд шүүлт явуулах стрингс эсвэл вектороо оруулаад (`string =`), дараа нь хайж буй хэв маягийг зааж өгнө (`pattern =`). Default -аар *үсгийн том жижиг хамаатай* !

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

Хэрэв `negate =` аргументийг нэмж `TRUE` гэж тохируулбал тухайн заасан хэв маяг БАЙХГҮЙ эсэхийг шалгадаг.

```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

Хэрэв үсгийн том жижигийг хамаарахгүй болгохын тулд хайлт хийх хэв маягаа `regex()` функцэд оруулаад `regex()` *дотор* `ignore_case = TRUE` гэсэн тохиргоо хийдэг (эсвэл `T` гэж товчилж болно).

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

Карактер вектор эсвэл хүснэгтийн баганад `str_detect()` функцыг уншуулбал TRUE эсвэл FALSE гэсэн логик утгатай вектор үүснэ.

```{r}
# мэргэжил бүртгэсэн вектор/хүснэгтийн багана
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# стрингс тус бүрт "teach" гэсэн хэв маяг/үг байгаа эсэхийг шалгаж үр дүнг TRUE/FALSE-оор харуулна
str_detect(occupations, "teach")
```

Үүнийг `sum()` -ын дотор оруулж нийт хэдэн `TRUE`- байгааг тоолж болно.

```{r}
sum(str_detect(occupations, "teach"))
```

Олон янзын хэв маяг хайх бол тэдгээгийг жагсаан ЭСВЭЛ (`|`) тэмдэгтээр тусгаарлаж бичээд `pattern =` аргументэд дор харуулсан шиг бичнэ:

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

Хайлт хийх хэв маягийн жагсаалт их урт тохиолдолд эхлээд `str_c()` болон `sep = |`-ийг хавсарч хэрэглээд, карактер гэдгийг нь зааж өгвөл цаашид хайлтаа арай товч болгож болно. Доорх жишээнд эрүүл мэндийн ажилтнуудын тэргүүн шугаманд ажилладаг мэргэжлийн нэрсээр хайлт хийж байна.

```{r}
# олон янзын хэв маягийг хайх
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

Дараах коммандыг уншуулснаар occupations бүртгэлд дээрх жагсаалттай (`occupation_med_frontline`) тохирсон мэргэжлүүд хэд байгааг харуулна:

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```

**Base R -ын стрингс хайх функцууд**

**base** -ын функц болох `grepl()` нь `str_detect()` -тэй төстэй үйлдэлтэй. Энэ функц таарсан бүтцийг хайж логик вектор үүсгэдэг. Үндсэн синтакс нь `grepl(бүтэц, хайх_стрингс, ignore.case = FALSE, ...)`. Давуу тал нь `ignore.case` аргументийг бичихэд хялбар ( `regex()` функцтэй хавсарч хэрэглэх шаардлагагүй).

Мөн **base** -ын функц болох `sub()`, `gsub()` нар нь `str_replace()`-тэй төстэй үйлдэлтэй. Үндсэн синтакс нь: `gsub(бүтэц, орлуулалт, хайх_стрингс, ignore.case = FALSE)`. `sub()` функц уншуулахад өгөгдсөн хэв маягт таарсан эхний тохиолдлыг орлуулдаг бол `gsub()` функцыг уншуулахад өгөгдсөн бүтэцтэй таарсан бүх тохиолдлуудыг орлуулна.

#### Таслалыг цэгээр солих {.unnumbered}

Тоон векторуудад буй таслалуудыг `gsub()` ашиглаж цэгээр хэрхэн солихыг харуулав. Ингэж цэгээр солих үйлдлйиг АНУ, Их Британийн бус гаралтай датанд их хийдэг.

Доорх жишээнд эхлээд дотор талд буй `gsub()` нь `lengths` баганыг уншиж, үүнд агуулагдаж бүх цэгийг "" (зайгүй хоосон) болгож хувиргаж байна. Ингэхдээ "." гэсэн тэмдэгтийг алгасахын тулд хоёр ташуу зураас оруулж өгнө. Учир нь regex -т "." нь "бүх тэмдэгт" ( "any character")-ийг илэрхийлдэг. Үүссэн (зөвхөн таслалтай) үр дүн гаднах `gsub()` -д уншигдах ба ингэснээр бүх таслалууд цэг болж хувирна.

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # бүх таслалыг  
                replacement = ".",            # цэгээр солих
                x = gsub("\\.", "", lengths)  # цэг агуулсан бусад векторуудыг арилгах (цэг ())
                )
           )                                  # үр дүнг тоон утга болго
```

### Бүгдийг зэрэг солих {.unnumbered}

`str_replace_all()` -ыг "олоод ёоль" гэсэн үйлдэл хийхэд ашигладаг. Эхлээд шүүлт хийх стрингсээ `string =`-нд, хайлт хийх бүтцээ `pattern =`-нд, сольж тавих утгаа `replacement =`-нд тус тус зааж өгнө. Доорхи жишээгээр бүх "dead" гэсэн утгыг "deceased" болгож солих болно. Үсгийн том жижиг хамаатай болохыг анхаарна уу.

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Тэмдэглэл:

-   Аливаа хэв маягийг `NA`-аар солиход `str_replace_na()` функцыг хэрэглэдэг.\
-   `str_replace()` функц шалгагдаж буй стрингс тус бүрийн зөвхөн эхний тохиолдлыг л сольдог.

<!-- ======================================================= -->

### Логик дотор илрүүлэх {.unnumbered}

**`case_when()` дотор**

`str_detect()` -ийг (**dplyr**-ын) `case_when()`-ын дотор хэрэглэх нь их. Жишээнд linelist -д `occupations` хэмээх баганыг авч үзье. Энэхүү баганад логик нөхцлийг `case_when()` -ээр оруулж, үүнийгээ `mutate()` дотор оруулсгнаар `is_educator` гэсэн шинэ багана үүсгэж байна. `case_when()`-ийн талаар дата цэвэрлэгээг тайлбарласан хэсгээс лавшруулж уншиж болно.

```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # occupation дотор хийгдэж буй хайлтад үсгийн жижиг том хамаагүй
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # бусад бүх
    TRUE                                               ~ "Not an educator"))
```

Оруулахгүй хэв маягийг логик нөхцөлд зааж өгч болно (`negate = F`):

```{r, eval=F}
df <- df %>% 
  # шинээр үүсгэсэн is_educator багана дах утгыг логик нөхцлөөр үүсгэсэн 
  mutate(is_educator = case_when(
    
    # occupation баганын утга хоёр шалгуурт нийцэж байж "Educator" баганын утга болж чадна:
    # it must have a search term AND NOT any exclusion term
    
    # Хайлт хийх хэв маягууд
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # AND must NOT have an exclusion term
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # Дээрх шалгуурт нийцэхгүй бусад бүх нөхцлүүд
    TRUE                                            ~ "Not an educator"))
```

<!-- ======================================================= -->

### Хэв маягийн байрлалыг тогтоох {.unnumbered}

Хайлт хийж буй хэв маягийн эхний байрлалыг тогтоохын тулд `str_locate()`-ыг хэрэглэ. Эхлэл болон төгсгөл хэсгээр нь хайдаг.

```{r}
str_locate("I wish", "sh")
```

Бусад `str` функцын адил дээрх функцэд хэв маяг таарч буй *бүх* тохиолдлуудыг (стрингс тус бүрээс) гаргаж ирдэг "\_all" хувилбар (`str_locate_all()`) бас байна. Үүний хайлтын үр дүн `list` -ээр үүсдэг.

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # Хайлт хийж буй хэв маягтай тохирох *эхний* тохиолдлыг олох
str_locate_all(phrases, "h" ) # Хайлт хийх хэв маягтай тохирсон *бүх* тохиолдлыг олох
```

<!-- ======================================================= -->

### Хэв маягийг тааруулж сугалж гаргах  {.unnumbered}

Олон хэв маягийг зэрэг ЭСВЭЛ (`|`) нөхцөлтэйгээр зэрэг хайж буй үед `str_extract_all()` -ийг хэрэглэснээр тохирох хэв маягууд тэр хэвээрээ гарч ирдэг давуу талтай. Жишээ нь occupations гэсэн стрингс векторт (дээр бичигдсэн табд буй) "teach", "prof", "tutor" гэсэн хэв маяг/үгийн *аль нэгийг* хайя.

Энэ үед `str_extract_all()` функ стрингс бүрийн *таарсан* хэв маяг/үгсийг ялгаж цуглуулсан `list` үүсдэг. Доорх жишээнд бичсэн 3 мэргэжлийн 2 бүтэц occupations датанд таарч байна.

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```

`str_extract()` функц стрингс тус бүрийн *зөвхөн эхний таарсан хэв маяг/үгийг* гаргаж ирдэг. Ингэснээр стрингс тус бүрт нэг элэменттэй карактер вектор үүсдэг. Тохироо таараагүй утгуудад `NA` үүсдэг. Үүссэн векторыг `na.exclude()`-д оруулснаар `NA`-г арилгаж болно. occupation 3-ын хоёрдах тохироо харагдахгүй байгааг анзаарна уу.

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->

### Хэсэгчлэх ба тоолох {.unnumbered}

Эдгээр үйлдлийг `str_subset()`, `str_count()` гүйцэтгэдэг.

Аливаа хэв маягийг `str_subset()` -ээр хайснаар таарсан хэв маягийг агуулж буй утга анхны хэлбэрээр гарч ирдэг.

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` -ээр тоон вектор үүсдэг: шалгагдсан утга бүрт хайгдаж буй хэв маяг **хэдэн ширхэг** байгаа нь гарч ирдэг.

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```

<!-- ======================================================= -->

### Regex-ийн группууд {.unnumbered}

ХИЙГДЭЖ БУЙ

<!-- ======================================================= -->

## Өвөрмөц карактерүүд

**Арагшаа ташуу зураас `\` бол "алгасах тэмдэг"**

Арагшаа ташуу зураасыг `\` арынх нь карактер утгыг "алгасах" зориулалтаар хэрэглэдэг. Тиймээс арагшаа ташуу зураасыг хашилтан *доторх* хашилттай хамт хэрэглэдэг (`"\""`) - дундах хашилт хоёр захын хашилтуудыг *эвдлэхгүй*.

Тэмдэглэл - хэрэв арагшаа ташуу зураасыг *хэвлэх* бол, *дахин нэг* арагшаа ташуу зураас бичих шаардлагатай болдог. Өөрөөр хэлбэл нэг арагшаа ташуу зураас бичихийн тулд хоёр ташуу зураастай код бичнэ (`\\`).

**Өвөрмөц карактерүүд**

| Өвөрмөц карактерүүд                                                               | Зориулалт                            |
|-----------------------------------------------------------------------------------|--------------------------------------|
| `"\\"`                                                                            | Арагшаа ташуу зураас                 |
| `"\n"`                                                                            | шинэ мөр (newline)                   |
| `"\""`                                                                            | давхар хашилт *доторх* давхар хашилт |
| `'\''`                                                                            | дан хашилт *доторх* дан хашилт       |
| `"\`"`| grave accent`"\r"`| carriage return`"\t"`| tab`"\v"`| vertical tab`"\b"\` | backspace                            |

Эдгээр өвөрмөц карактерүүдийн бүрэн жагсаалтыг R Console -д `?"'"` гэж уншуулж гаргаж ирнэ ( RStudio -ын Help цонхонд харагдна).

<!-- ======================================================= -->

## Regular expressions (regex)

<!-- ======================================================= -->

## Regex болон өвөрмөц карактерүүд

Regular expressions, буюу "regex" бол стрингсийн доторх хэв маяг, бүтцийг дүрсэлж хураангуйлсан хэл юм. Regular expressions-ыг сайн мэдэхгүй хүнд харь гаригийн бичиг шиг харагддаг. Энэхүү хэсэгт энэ хэлийн тайллыг тайлбарлахыг зорилоо.

*Энэ хэсгийн ихэнх агуулгыг [this tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) болон [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) линкүүдээс авсан*. Энэхүү линкийн хичээлийг интернетгүй газар хэрэглэх боломжгүй тул бид энэхүү номондоо сонгож шилээд заримыг нь оруулсан.

regular expression -ыг "бүтэцгүй" текстнээс бүтэц хайж илрүүлэхэд хэрэглэдэг - үүний жишээнд өвчний түүх, өргөдөл, гомдол, эмнэлэгийн тэмдэглэл болоэ хүснэгтэлсэн сул текстүүд ордог.

regular expression -ын үндсэн хэсгийг дараах дөрвөн аргаар бүтээдэг:

1)  Карактер багц\
2)  Мета карактер\
3)  Тоон үзүүлэлт\
4)  Бүлэг

**Карактер багц**

Карактерийн сонголтуудыг жагсаалтаар илэрхийлж, хаалтанд дотор багцлах арга юм. Аливаа стрингст хайлт хийж буй карактерүүдийн аль нэг нь олдвол тохироо үүслээ гэж үзнэ. Жишээ нь эгшиг үсгүүдийг хайхын тулд "[aeiou]" гэсэн карактер багцыг хэрэглэдэг. Нийтлэг хэрэглэгддэг карактер багцуудыг дор жагсаав:

| Карактер багц | Илэрхийлэх утга                 |
|---------------|---------------------------------|
| `"[A-Z]"`     | томоор бичсэн бүх үсэг          |
| `"[a-z]"`     | жижигээр бичсэн бүх үсэг        |
| `"[0-9]"`     | бүх цифр                        |
| `[:alnum:]`   | тоон болон үсгэн бүх тэмдэгтүүд |
| `[:digit:]`   | бүх тоон цифр                   |
| `[:alpha:]`   | бүх үсэг (том болон жижиг үсэг) |
| `[:upper:]`   | томоор бичсэн бүх үсэг          |
| `[:lower:]`   | жижигээр бисэн бүх үсэг         |

Карактер багцуудыг хамтад нь зэрэг нэг хаалтанд бичиж болно (зай авахгүй!). Жишээ нь `"[A-Za-z]"` (том болон жижиг бүх үсгүүд), `"[t-z0-5]"` (жижиг t-ээс z хүртэл ЭСВЭЛ 0-оос 5 хүртэл) гэх мэтээр бичиж болно.

**Мета карактер**

Мета карактер нь карактер багцын товчилсон хэлбэр. Нийтлэг хэрэглэгддэг мета карактерүүдийг дор жагсаав:

| Мета карактерүүд | Илэрхийлэх утга                                        |
|------------------|--------------------------------------------------------|
| `"\\s"`          | нэг хоосон зай                                         |
| `"\\w"`          | нэг ширхэг тоон болон үсгэн тэмдэгт (A-Z, a-z, or 0-9) |
| `"\\d"`          | нэг ширхэг тоон цифр (0-9)                             |

**Олшруулагч**

Зөвхөн нэг карактер хайх тохиолдол бараг гардаггүй. Иймээс олшруулагч ашиглаж урт хэмжээний үсэг/тоон хайлт хийдэг .

Олшуурах гэж буй карактерийн *ард* олшруулах тоог `{ }` хаалтанд дотор бичдэг,

-   `"A{2}"` нь **хоёр** том A үсэг илэрхийлнэ.\
-   `"A{2,4}"` нь **2 оос 4 -н** том A үсгийг илэрхийлнэ *(зай авч болохгүй!)*.\
-   `"A{2,}"` **2 болон түүнээс дээш** тооны том А үсгийг илэрхийлнэ.\
-   `"A+"` **нэг болон түүнээс дээш** тооны том А үсгийг илэрхийлнэ (өөр карактер гарч иртэл энэ бүлэг үргэлжлэх болно).\
-   Хэрэв од `*` тэмдэг урд нь тавьбал **0 болон түүнээс дээш** тохироо буй эсэхийг харуулна (тухайн хэв маяг байгаа эсэх нь эргэлзээтэй үед байгаа хэрэг болдог).

Нэмэх `+` тэмдгийг олшуулагчаар өгвөл таарсан хэв маягийг дараачийн карактер гарч иртэл хайх болно. Жишээ нь `"[A-Za-z]+"` (цагаан толгойн карактерүүд) -ээр бүх *үгсийг* илэрхийлнэ:

```{r}
# олшруулагчийг шалгах тест стринг
test <- "A-AA-AAA-AAAA"
```

Олшруулагчийг {2} гэж өгвөл зөвхөн дараалласан A -г л гаргаж ирнэ. Жишээ нь `AAAA`-д хоёр хос дараалласан А байна.

```{r}
str_extract_all(test, "A{2}")
```

Хэрэв олшруулагч {2,4} бол 2 -оос 4 удаа дараалласан A байх тохиолдлуудыг гаргаж ирнэ.

```{r}
str_extract_all(test, "A{2,4}")
```

Хэрэв олшруулагч `+` бол **нэг болон түүнээс дээш** тооны А байх тохиолдлууд гарч ирнэ:

```{r}
str_extract_all(test, "A+")
```

**Харьцангуй байрлал**

Эдгээр нөхцлүүд хайж буй хэв маягийн өмнө болон хойно нь юу байгаа вэ гэдгээр илэрхийлэгддэг. Жишээ нь "хоёр тооны ардах цэг" (`""`). (?\<=\\.)\\s(?=[A-Z])

```{r}
str_extract_all(test, "")
```

| Байрлын илэрхийлэл | Илэрхийлэх утга               |
|--------------------|-------------------------------|
| `"(?<=b)a"`        | **урдаа** "b" тэй "a"         |
| `"(?<!b)a"`        | **урдаа** "b" **БАЙХГҮЙ** "a" |
| `"a(?=b)"`         | **ардаа** "b" тэй "a"         |
| `"a(?!b)"`         | **урдаа** "b" **БАЙХГҮЙ** "a" |

**Бүлгүүд**

regular expression ийг бүлэглэснээр үр дүн илүү зохион байгуулалттайгаар гарч ирдэг.

**Regex -ын жишээ**

Сул текст дээр хэрхэн ажиллах талаар жишээ дор харуулав. Үүнээс бид regular expression-ийн хайлтын дүрмээр хэрэгтэй мэдээллээ гаргаж авах болно.

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Энэхүү илэрхийлэл нь бүх үгтэй тохирч байна (тохироо нь бүх карактертэй тохирох ба хоосон зай гэх мэт үсэг биш карактер гарч иртэл үргэлжилнэ):

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

`"[0-9]{1,2}"` бол үргэлжилсэн, 1 ээс 2 орон тоог илэрхийлэл. Үүнийг мөн `"\\d{1,2}"`, эсвэл `"[:digit:]{1,2}"` гэж бичиж болно.

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- нь бүх өгүүлбэрийг илэрхийлнэ (ингэхдээ өгүүлбэрийн эхний үсэг томоор, бичигдсэн ба өгүүлбэр төгсөхөд цэг тавигдсан гэж үзнэ). Илэрхийлсэн бүтэц Англи хэлээр уншигдахдаа: "Ардаасаа жижиг үсэгнүүд, хоосон зай, хэдэн үсэг, зай гэх мэтээр дагуулсан том үсэг     -->

<!-- ```{r} -->

<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->

<!-- ``` -->

Дараах линкийн 2 дугаар хуудаснаас чухал regex expressions-үүд, хэрэгтэй зөвлөгөөнүүдтэй танилцаж болно [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Мөн [tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) линкээс нэмэлт мэдээлэл авна уу.

<!-- ======================================================= -->

## Эх сурвалж материалууд

**stringr** функцын лавлагаа хуудсыг дараах линкээс үзэж болно: [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

**stringr** -ын винньетийг дараах линкээс үзэж болно: [here](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/characters_strings.Rmd-->

# Фактор {}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Factors_1500x500.png"))
```

Боломжит утгууд тодорхой байдлаар багцлагдан, эрэмбэлэн ангилагдсан датаг R дээр *фактор* дата гэнэ.

График, хүснэгт байгуулахад default-аар цагаан толгойн дарааллаар, багаас ихрүү чиглэлтэй (alpha-numeric) гарч ирдэг. Харин баганын утгад эрэмбэ (*шатлал*) тогтоосноор болиулж болдог. Үүний тулд карактер, тоон багануудыг фактор хэлбэрт хувиргах ашаардлагатй. Фактор датаны өөр ач холбогдол бол графикт стандарт легендийг байгуулж өгдөг. Энэ нь датанд аль нэг утга байхгүйгээс легендийн байрлал график янз бүр болж өөрчлөгдөөд байдаг асуудлыг шийдэж өгдө.


Энэ хэсэгт **forcats** багцын функцууд ( “**For** "**cat**egorical variables”-гэсэн үгийн товчлол) болон **base** R- зарим функцыг тайлбарлана. Мөн тархварзүйн долоо хоногтой (epiweeks) хэсэгт **lubridate**, **aweek** гэсэн багцуудаас цухас яригдах болно. 


**forcats** багц дах функцуудын бүрэн жагсаалтыг [here](https://forcats.tidyverse.org/reference/index.html) –ээс үзэж болно. Энд Энд зөвхөн чухал хэрэглэгддэг функцуудыг тайлбарласан.


<!-- ======================================================= -->
## Бэлтгэл  

### Багцыг ачааллах {.unnumbered}  

Энэ хэсэгт анализ хийхэд шаардлагатай багцуудыг доорхи кодоор ачааллана.**pacman** багцын `p_load()` функцээр шаардлагатай багцыг татаж аваад ачааллана уу. Өмнө татаж авсан багцуудаа **base** R -ын `library()`-аар ачааллаж болно. Багцын талаарх нэмэлт мэдээллийг [R basics] хэсгээс харна уу.

```{r}
pacman::p_load(
  rio,           # импорт/экспорт
  here,          # файлын зам
  lubridate,     # огноог янзлана
  forcats,       # факторыг янзлана
  aweek,         # автоматаар фактор үүсгэж тархварзүйн долоо хоног (epiweeks) үүсгэнэ
  janitor,       # хүснэгт
  tidyverse      # дата менежмент, график
  )
```



### Дата импортлох{.unnumbered}  

Жишээ дасгалуудад Эбола дэгдэлтийн үеийн зохиомол дата ашиглах болно. Эдгээр дасгалуудыг дагаж хийхийг хүсвэл <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линкийн "clean" linelist дээ дарж татаж авна уу </a> (as .rds file). Датагаа **rio**-ын `import()`функцээр импортлож болно (энэ нь.xlsx, .rds, .csv - зэрэг олон дата төрөлтэй ажиллаж чадна. [Import and export] хэсэгт илүү тайлбарласан).  

```{r, echo=F}
# linelist -ийг R луу импортлох
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# датаг импортлох
linelist <- import("linelist_cleaned.rds")
```


### Шинээр ангилагдсан (categorical) хувьсагч үүсгэх {#fct_newcat .unnumbered}  

Ойлгомжтой тайлбарлах үүднээс хамгийн нийтлэг хэрэглэгддэг үйлдэл болох ангилагдсан хувьсагч шинээр хэрхэн үүсгэхийг үзэх болно.

Тоон баганыг фактор хэлбэрт хувиргаснаар статистик бодолт хийх боломжгүй өолдог гэдгийг санаарай.

#### Багана үүсгэх{.unnumbered}  

Жишээгээр `days_onset_hosp` (өвчний шинж эхэлснээс эмнэлэгт хэвтэх хүртэл хугацаа) баганын мөрүүдийг ангилан ялгаж `delay_cat` гэсэн шинэ багана үүсгэх болно. Үүнийг  **dplyr** -ын `case_when()` функцээр хйинэ. `case_when()` функцын логик шалгуур (баруун тал) дэс дарааллан мөр болгонд үйлчилж, үүссэн утга нь `delay_cat` шинэ баганын (зүүн тал) тохирох мөрөнд ордог. `case_when()` функцын талаар [Cleaning data and core functions] хэсэгт дэлгэрэнгүй тайлбарласан.  

```{r}
linelist <- linelist %>% 
  mutate(delay_cat = case_when(
    # шалгуур                                   # TRUE байвал орох шинэ утга 
    days_onset_hosp < 2                        ~ "<2 days",
    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ "2-5 days",
    days_onset_hosp >= 5                       ~ ">5 days",
    is.na(days_onset_hosp)                     ~ NA_character_,
    TRUE                                       ~ "Check me"))  
```


#### Утгын default эрэмбэ {.unnumbered}  

`case_when()`-ээр үүсгэдсэн `delay_cat` багана карактер утгатай ангилагдсан багана байдаг. Өөрөөр хэлбэл фактор болж *амжаагүй* байдаг. Тийм ч учраас давтамж харуулсан хүснэгт дээр ангилалын жагсаалт цагаан толгойн дарааллаар эрэмбэлэгдсэн байдаг. Гэтэл энэ дараалал тухайн датаг ойлгоход учир дутагдалтай байдаг:  

```{r}
table(linelist$delay_cat, useNA = "always")
```

Barplot байгуулахад x-тэнхлэгийн дараалал автомат тохируулгатай байдаг ( R график байгуулахын тулд хамгийн их хэрэглэгддэг  **ggplot2** багцын талаар [ggplot basics] хуудасанд дэлгэрэнгүй тайлбарласан).  

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```



## Фактор болгож хувиргах  

Карактер эсвэл тоон баганыг *фактор* болгож хувиргахад  **forcats** -ын аль ч функцыг хэрэглэж болно (дэлгэрэнгүй мэдээлэл  [below](#fct_adjust) -д орсон). Эдгээр функц нь датаг юуны түрүүнд фактор болгож хувиргадаг тул цаашид шатлалтай ангилал үүсгэх боломжтой болдог. Тухайлбал шатлалын эрэмбийг `fct_relevel()` -ээр зааж өгч болно. Гэтэл `as_factor()` функц зөвхөн факторт хувиргахаас өөр үйлдэл нэмж хийдэггүй. 

**base** R -ын `factor()` функц мөн баганыг факторлуу хувиргадаг ба шатлалын эрэмбийг `levels = ` аргументэд нь та өөрөө зааж өгөх болно. 

Дор жишээнд `mutate()` болон `fct_relevel()` -ээр `delay_cat` баганыг карактерээс фактор болгож хувиргахыг харуулав. `delay_cat` багана үүсэх талаар өмнөх [Preparation](#fct_newcat) хэсэгт тайлбарласан. 

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat))
```

*Одоо энэхүү баганын "утгууд" фактор "түвшингүүд" боллоо гэсэн үг.*  Энэхүү үүсгэсэн түвшний жагсаалтыг *эрэмбийг* **base** R-ын  `levels()` функц эсвэл `table()` эсвэл **janitor** -ын `tabyl()` функцуудээр харж болно. Түвшний эрэмбэ нь default-аар цагаан толгойн болон багаас ихсэх (alpha-numeric) дарааллар гарч ирдэг. `NA` бол факторын түвшинд тооцогдохгүй болохыг анхаарна уу.   

```{r}
levels(linelist$delay_cat)
```

Үүнээс гадна `fct_relevel()` -ээр түвшний эрэмбийг гараар зааж өгч болно. Ингэхдээ доор үзүүлсний дагуу түвшин заасан утгуудаа таслалаар тусгаарлаж, хашилтанд уагсааж бичнэ. Датан дах утгаасаа үг үсгийн зөрөөгүй бичхийг анхаар. Хэрэв датанд байхгүй түвшин үүсгэх хэрэгтэй бол [`fct_expand()` instead](#fct_add))-ыг хэрэглэ.  

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", "2-5 days", ">5 days"))
```

Дээрх коммандаар зааж өгсний үр дүнд түвшний эрэмбэ илүү ойлгомжтой болно байна. 

```{r}
levels(linelist$delay_cat)
```

График дээр хэвлэгдэх дараалал ч гэсэн илүү ойлгомжтой болж байна.  

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```


## Түвшин нэмэх, хасах 

### Нэмэх {#fct_add .unnumbered}
Фактортоо нэмж түвшин оруулах бол `fct_expand()`-ыг хэрэглэ. Багана болон нэмэгдэж буй түвшний нэрийг (таслалаар тусгаарлаж) функцэл оруулдаг. Баганын нийт утгыг хүснэгтэлж харвал шинээр үүсгэсэн түвшин 0 давтамжтай харагддаг. **base** R-ын `table()` эсвэл **janitor**-ын `tabyl()` -аар хүснэгт болгож хараарай:  

```{r}
linelist %>% 
  mutate(delay_cat = fct_expand(delay_cat, "Not admitted to hospital", "Transfer to other jurisdiction")) %>% 
  tabyl(delay_cat)   # хүснэгт хэвлэ
```


Тэмдэглэл: **forcats** -д дутуу утгыг (`NA`) хялбар аргаар түвшин болгож хувиргах тусгай функц байдаг. [Missing values](#fct_missing) хэсгийг нэмж үзнэ үү.  


### Хасах {.unnumbered}  

`fct_drop()`-ээр "ашиглагдаагүй", 0 давтамжтай түвшинг хасдаг.  Өмнөх жишээний нэг түвшин ("эмнэлэгт хэвтээгүй тохиолдлууд") 0 давтамжтай байна. Фактортай баганаа `fct_drop()`-д оруулснаар энэхүү 0 давтамжтай түвшин хасагдна:  

```{r}
linelist %>% 
  mutate(delay_cat = fct_drop(delay_cat)) %>% 
  tabyl(delay_cat)
```




## Түвшний эрэмбийг тохируулах {#fct_adjust} 

**forcats** -ын функцуудээр түвшний эрэмбийг тохируулахад хялбар (багана фактор хэлбэрт хувирсан байх шаардлагатай): 

Ингэхдээ фактор баганад хоёр янзаар үйлчилнэ:  

1) Хүснэгтийн багана: датанд өөрчлөлт хийгдсэн тул цаашид хийгдэх үйлдэлд нөлөөлнө.  
2) *График дотор*: өөрчлөлт зөвхөн график дотор хийгдэх болно.  



### Гараар гүйцэтгэх {.unnumbered} 

Фактор дах түвшний эрэмбийг гараар янзалж болно. Фактор бус баганыг функцэд оруулбал багана эхлээд фактор хэлбэрт хувирдаг.  

Хаалтан дотор баганын нэрийг оруулаад араас нь дараахь хоёрын аль нэгийг оруул:  

* Түвшнүүдийг бүгдийг хүссэн дарааллын дагуу жагсааж оруулна (карактер вектор хэлбэрээр `c()`) эсвэл  
* Засагдах шаардлагатай нэг ширхэг түвшний нэрийг оруулаад түүний шинэ эрэмбийн байрлалыг `after = ` аргументэд зааж өгнө.  

Энэхүү жишээнд `delay_cat` баганын түвний эрэмбийг дахин зааж өгч (өмнө нь фактор байсан) хүссэн дарааллалдаа хэрхэн оруулахыг харуулав. 

```{r}
# түвшний эрэмбийг дахин зааж өгөх
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days")))
```

Зөвхөн нэг л түвшинг зөөх шаардлагатй үед `fct_relevel()` -ыг дангаар нь хэрэглэж,  засагдах эрэмбийн байрлалыг `after = ` аргументэд зааж өг. Жишээ нь дараахь коммандаар "<2 days" гэсэн түвшин хоёрдугаар байрлалруу зөөгдөж байна: 

```{r, eval=F}
# түвшний эрэмбийг дахин зааж өгч
linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 1)) %>% 
  tabyl(delay_cat)
```




### График дотор {.unnumbered}  

Хүснэгтээс гадна график доторх түвшний эрэмбийг **forcats** -аар зааж өгдөг. Эдгээр функцыг график байгуулдаг `ggplot()` дотор оруулаад түвшнийг эрэмбэлж, урвуулж (reverse) болно. Ингэснээр өөрчлөлт зөвхөн графикт л хийгдэх болно. 

Доор жишээнд хоёр графикийг`ggplot()` -ээр байгуулав ( [ggplot basics] хуудсаас лавлаж болно). Эхний графикт `delay_cat` баганыг x-тэнхлэгт байрлуулж,  түвшний эрэмбэ нь default хэлбэрээр байна. Хоёр дах графикийн кодонд баганын нэр, түвшний дарааллыг `fct_relevel()`-т оруулснаас график дээрх эрэмбэ өөрчлөгдсөн байна. 

```{r, echo =F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("2-5 days", "<2 days", ">5 days")))

```



```{r, warning=F, message=F, out.width = c('50%', '50%'), fig.show='hold'}
# ggplot дотор тохируулга хийж өгөөгүй учир эрэбмэ default буюу цагаан толгойн, багаас ихсэх дараалалтай байна 
ggplot(data = linelist)+
    geom_bar(mapping = aes(x = delay_cat))

# фактор лах түвшний эрэмбийг ggplot дотор тохируулж өгсөн
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days"))))
```

графикийн түвшинд ингэж өөрчлөлт хийхэд x- тэнхлэг дээрх default гарчигны утга алдагддаг. Иймээс гарчигийг **ggplot2**-ын  `labs()` аргументээр дахин нэрлэх хэрэгтэй. 




### Урвуулах {.unnumbered}  

Түвшний эрэмбийг урвуугаар нь эрэмбэлэх хэрэгцээ их байдаг. Энэ үед факторыг `fct_rev()`-т оруулж бичихэд хангалттай.  

Дата доторх факторын эрэмбэ нь хэвээр боловч графикт харагдах эрэмбэд өөрчлөлт оруулах гэж буй бол `guides()` функцыг хэрэглэж болно ([ggplot tips] хэсгээс харна уу).  




### Давтамжаар {.unnumbered}  

Датаны давтамжийн тоогоор эрэмбэлэхдээ `fct_infreq()`-ийг хэрэглэдэг. Дутуу утгад (`NA`) тодорхой түвшин зааж өгөөгүй тохиолдолд автоматаар хамгийн төгсгөлд эрэмбэлэгддэг ([this section](#fct_missing) -ээс харна уу). Давтамжийн урвуу дараалалд оруулах бол `fct_rev()`-т давхар оруулж эрэмбэлдэг.   

Энэ функцыг доор үзүүлсэнчлэн `ggplot()`дотор хэрэглэж болно.  

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# давтамжаар нь эрэмбэлэх
ggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by frequency")

# урвуу давтамжаар эрэмбэлэх
ggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Reverse of order by frequency")
```


### Харагдах байдлаар {.unnumbered}  

Датанд эхэлж гарч ирэх дарааллаар (эхний мөрөөс эхэлж тооцно) эрэмбэлэхийн тулд `fct_inorder()`-ийг хэрэглэ. Датаг `arrange()` функцээр эхэлж эрэмбэлээд, факторт хувиргаж буй үед `fct_inorder()`  функц илүү хэрэг болдог. 




### Өөр баган дах статистикийн тооцооллоор {.unnumbered}  

Сонгосон баганын түвшинг *өөр баганын статистикийн тооцооллын* дагуу эрэмбэлэхдээ `fct_reorder()`-ыг ашигладаг. Ингэж эрэмбэлэхэд аажмаар өгсөж, буурсан bars/цэгэн график байгуулагдаж харахад илүү ойлгомжтой болдог. 

Жишээнд x-тэнхлэгт `delay_cat` гэсэн фактор багана y-тэнхлэгт `ct_blood` гэсэн тоон багана байрлуулав (босго утга). `delay_cat` -ын бүлэг тус бүрт boxplot-оор CT -ыг дүнг байна. Жишээнд үүнийг CT үр дүнгийн медиан дүнгийн өгсөх дарааллаар эрэмбэлэгдсэн boxplots болгож хувиргав.

Эхний графикт түвшингүүд цагаан толгойн, багаас ихсэх тоон дарааллаар (alpha-numeric) эрэмбэлэгдсэн. Тиймээс boxplot -ын өндөр янз бүр холилдсон, тодорхой дараалалгүй харагдаж байна. Хоёрдах жишээнд  `delay_cat` баганыг  (x-тэнхлэгдэх)  `fct_reorder()` дотор оруулж, `ct_blood` баганыг араас нь хоёр дах аргументээр зааж өгч, "median" -ийг гуравдах аргументээр өгсөн байна (мөн "max", "mean", "min" зэргийг хэрэглэж болно). Тиймээс `delay_cat` түвшний дараалал нь `delay_cat` бүлэг бүрийн дундаж CT утгын өсөх дундаж CT утгыг тусгах болно. Үүнийг хоёр дах график дээрээс харж болно. Boxplot -ууд  өгсөх дарааллаар эрэмбэлэгдсэн байна. Хэрэв `NA` -г (дутуу утга) тодорхой түвшинд хуваарилаагүй болавтоматаар хамгийн сүүлд эрэмбэлэгддэг.  

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# анхны дарааллаар эрэмбэлэгдсэн boxplots 
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = delay_cat,
        y = ct_blood, 
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by original alpha-numeric levels")+
  theme_classic()+
  theme(legend.position = "none")


# CT баганын median утгаар эрэмбэлэгдсэн boxplots
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = fct_reorder(delay_cat, ct_blood, "median"),
        y = ct_blood,
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by median CT value in group")+
  theme_classic()+
  theme(legend.position = "none")
```

Энэ үйлдлийг хийхэд `ggplot()` коммандын өмнө ямар нэгэн нэмэлт үйлдлэл хийгдэх шаардлагагүй. Бүлэглэж, тооцоолол хийх үйлдлүүд бүгд ggplot комманд дотроо хийгддэг. 


### "Сүүлийн" утгаар {.unnumbered}  

Бүлэглэсэн шугаман графикт `fct_reorder2()` -ыг хэрэглэж болно. Энэ функц график дах шугамын "төгсгөлийн" хэсгийн түвшингүүдийг (мөн *легенд*) босоо тэнхлэгийн дагуу эрэмбэлдэг. Өөрөөр хэлбэл x-тэнхлэг дэх утгын хамгийн ихтэй хамааралтай y-утгыг эрэмбэлнэ гэсэн үг.

Жишээ нь өвчлөлийн бодит тоог эмнэлг тус бүрээр бүлэглэж цаг хугацаагаар харуулсан график байгуулахаар болов. Ингэхдээ `aes()` доторх `color = ` аргументэд `fct_reorder2()`-тай синтаксаа оруулбал легендийн босоо тэнхлэгийн эрэмбэ графикийн төгсгөлийн босоо тэнхлэгт харагдах эрэмбэтэй ижил болдог. Энэ талаар [online documentation](https://forcats.tidyverse.org/reference/fct_reorder.html) материалаас уншна уу.  

```{r, warning=F, message=F}
epidemic_data <- linelist %>%         # linelist-ээр эхэл
    filter(date_onset < as.Date("2014-09-21")) %>%    # харахад ойлгомжтой болхын тулд босго огноо өг
    count(                                            # долоо хоног тутам, эмнэлэг тус бүрээр харуулах
      epiweek = lubridate::floor_date(date_onset, "week"),  
      hospital                                            
    ) 
  
ggplot(data = epidemic_data)+                       # график байгуулж эхлэх
  geom_line(                                        # шугам хийх
    aes(
      x = epiweek,                                  # тархварзүйн долоо хоногийн х-тэнхлэг
      y = n,                                        # өндрөөр долоо хоног тутам дах бодит тоог илэрхийлнэ
      color = fct_reorder2(hospital, epiweek, n)))+ # эмнэлэг тус бүрээр датаг бүлэглэж өнгөөр ялгана. Графикийн төгсгөлийн тооны эрэмбээр факторын эрэмбийг тодорхойлно
  labs(title = "Factor levels (and legend display) by line height at end of plot",
       color = "Hospital")                          # легендийн гарчигийг өөрчлөх
```




## Дутуу утга {#fct_missing}  

фактор багана дутуу утгатай (`NA`) бол `fct_explicit_na()`-аар `NA`-г түвшин болгож нэр ("Missing" ) өгч болно. Default-аар хамгийн ард орж эрэмбэлэгддэг. Нэрийг нь  `na_level = ` аргументээр өөрчилж болно.  

Дээрх үйлдлийг `delay_cat` дээр туршиж, `tabyl()` -аар хүснэгтлэн хэвлэхэд `NA` "Missing delay" гэж нэрлэгдсэн буйг харж байна. 
```{r}
linelist %>% 
  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = "Missing delay")) %>% 
  tabyl(delay_cat)
```





## Түвшнүүдийг нэгтгэх  


### Гар аргаар {.unnumbered}  

Түвшний харагдах байдлыг `fct_recode()`-ыг ашиглаж гараар янзалдаг. Энэ нь **dplyr** -ын `recode()` функцтэй адил ([Cleaning data and core functions]-ээс хар) боловч `fct_recode()` -ыг хэрэглэснээр шинэ фактор түвшин үүсгэх боломжтой байдгаараа ач холбогдолтой. Ердийн `recode()`-ийг хэрэглэхэд шинэ утгыг хүлээж авдгүй ба нэмэлт тохируулга хийж байж боломжтой болдог.  

Энэхүү функцээр олон түвшинд ижил утга оруулж түвшнүүдийг "нэгтгэж" болно. Ингэхдээ хэрэгтэй мэдээлэл санамсаргүй утгагдхаас болгоомжил! Шинэ багана үүсгэн түвшнүүдийг нэгтгэвэл эрсдэл багатай (хуучих багана дээрээс бичигдэхгүй).  

`fct_recode()` -ын синтакс `recode()`-оос өөр. `recode()` -оор `ХУУЧИН = ШИНЭ`гэсэн дараалалтай бол `fct_recode()` нь `ШИНЭ = ХУУЧИН` гэсэн дараалалтай.     

Эхлээд `delay_cat` -ын түвшин дараах байдалтай байна:  
```{r, echo=F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 0))
```


```{r}
levels(linelist$delay_cat)
```

Шинэ түвшинг `fct_recode(column, "new" = "old", "new" = "old", "new" = "old")` гэсэн синтаксаар үүсгэж хэвлэв:  

```{r}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 2 days" = "<2 days",
    "2 to 5 days"      = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

Энд дээрх түвшнийг `fct_recode()` -оор нэгтгэв. "Less than 5 days" түвшинг шинээр нэмхэд алдаа гарч анхааруулж байна.


```{r, warning=F, message=F}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 5 days" = "<2 days",
    "Less than 5 days" = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```





### "Бусад" болгож хумих {.unnumbered}  

Гараар "Бусад" гэсэн түвшин үүсгэх бол `fct_other()` функцыг хэрэглэж болно. Дор жишээнд `hospital` баганын "Port Hospital" болон "Central Hospital" түвшнээс бусад түвшингүүд "Other" болж нэтггэдсэн байна. Энэ үед хасах, нэмэх шаардлагатай утгаа `keep = ` эсвэл `drop = `-аргументэд вектор хэлбэрээр зааж өгч болно. "Бусад" гэсэн түвшний харагдах байдлыг `other_level = `гэсэн аргументээр өөрчилж болно.  

```{r}
linelist %>%    
  mutate(hospital = fct_other(                      # түвшнүүдийг тохируул
    hospital,
    keep = c("Port Hospital", "Central Hospital"),  # тусдаа утгуудыг оруул
    other_level = "Other Hospital")) %>%            # Бусад бүх утгыг "Other Hospital" болго
  tabyl(hospital)                                   # хүснэгтийг хэвлэ

```




### Давтамжаар нь хумих {.unnumbered}

Хамгийн бага давтамжтай түвшнүүдийг `fct_lump()`-ээр зэрэг нэгтгэж болдог.  

Бага давтамжтай бүлгүүдийг зэрэг "бөөндөж" нэгтгэн "Other" түвшин үүсгэхийн тулд дараах үйлдлүүдээс сонгож хийнэ үү:  

* `n = ` -ээр хэдэн бүлэг үүсгэхээ зааж өгнө. Ингэснээр хамгийн их давтамжтай n бүлэг үлдэж, үлдсэн хэсэг нь "Other" бүлэгт нэтгэгднэ
.  
* `prop = ` -ыг тохируул. Үлдээх гэж буй түвшний давтамжид босго хувь зааж өг. Энэхүү босго хувиас бага утгууд "Other" болж нэгтгэгднэ.

"Other" түвшний харагдах байдлыг `other_level = ` аргументээр тохируулж өөрчилж болно. Доорх жишээнд хамгийн их давтамжтай хоёр эмнэлэгээс бусад нь "Other Hospital" болж нэтгэгдсэн.

```{r, warning=F, message=F}
linelist %>%    
  mutate(hospital = fct_lump(                      # түвшнүүдийг тохируул
    hospital,
    n = 2,                                          # дээрээсээ эхний хоёр түвшинг үлдээ
    other_level = "Other Hospital")) %>%            # бусдыг нь "Other Hospital"-т нэгтгэ
  tabyl(hospital)                                   # хүснэгтийг хэвлэ

```




, warn
## Бүх түвшнийг харуул  

Фактор хэрэглэхийн бас нэг ач холбогдол нь датанд ямар утга байгаагаас үл хамааран графикийн легенд болон тайлангийн хүснэгтийг жигд, стандарт болгож өгдөг. 

Олон график, зураг зэрэг бэлдэж буй үед (графикийг газар нутгаар нь ялгаж харуулах гэх мэт) легенд, тайлангийн хүснэгтийг яг адилхан байлгах шаардлагатй болдог (датанд зарим утгы нь өөр байсан ч гэсэн).  

### Графикт {.unnumbered}  

Үүний тулд `ggplot()`-ын тохируулгын нэг `scale_xxxx()` функцуудэд `drop = FALSE` гэсэн аргументийг нэмдэг. Ингэснээр датанд байхгүй ч гэсэн факторын бүх түвшин графикт гарч ирдэг. Фактор баганын түвшин `fill = ` аргументэд орсон үед scale_fill_discrete() дотор `drop = FALSE` гэж өгнө (доор харуулсан). Түвшингүүдийг `x = `(x-тэнхлэг) ,`color = `, `size = `-нарт оруулсан үед `drop = FALSE`-ыг `scale_color_discrete()` эсвэл `scale_size_discrete()` -д оруулна.  

Жишээнд насны ангиллыг эмнэлэг тус бүрээр давхар bar plot -д оруулж харуулсан. Үүн дээр `scale_fill_discrete(drop = FALSE)` гэж нэмснээр бүх насны бүлэг легенд дээр харагдаж байна (зарим нь датанд байхгүй ч гэсэн).

```{r}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +
  scale_fill_discrete(drop = FALSE)+                        # датанд байхгүй ч гэсэн легенд дээр бүх насны ангилал харагдна
  labs(
    title = "All age groups will appear in legend, even if not present in data")
```

### Хүснэгтэнд {.unnumbered}  

**base** R-ын `table()`болон **janitor**-ын `tabyl()` -ыг хэрэглэж бүх фактор түвшинг харуулдаг (хэрэглэгдээгүй түвшин ч гэсэн).  

Хэрэв хүснэгтийг **dplyr**-ын `count()` эсвэл `summarise()`-аар байгуулж буй бол `.drop = FALSE` гэсэн аргумент нэмж хэрэглэгдээгүй ч гэсэн бүх фактор түвшинг гарч ирэх болно.

[Descriptive tables] хуудас эсвэл [scale_discrete documentation](https://ggplot2.tidyverse.org/reference/scale_discrete.html), or the [count() documentation](https://dplyr.tidyverse.org/reference/count.html) линкээс нэмж уншна уу. [Contact tracing] хуудасны жишээг нэмж үзэж болно.  


## Тархвар зүйн долоо хоног  

Тархварзүйн долоо хоногийг хэрхэн байгуулах талаар [Grouping data] хуудаснт дэлгэрэнгүй бичсэн. Мөн [Working with dates] хуудаст тархварзүйн долоо хоногийг үүсгэж, хэлбэржүүлэх талаар оруулсан.


### График дээрх тархварзүйн долоо хоног  {.unnumbered}  

Тархварзүйн долоо хоногийг графикт харуулахдаа **lubridate**-ын `floor_date()` функцыг ([Grouping data] хуудаст тайлбарласан) хэрэглэж болно. Ингэснээр YYYY-MM-DD форматтай, огноо төрлийн дата үүсдэг. Ийм огноотой баганаар график байгуулвал эрэмбэ нь автоматаар зөв гарч ирдэг бөгөөд факторт хувиргаж, түвшинг эрэмбэлэх шаардлагагүй. Жишээнд өвчний эхэлсэн огноог `ggplot()` гистограммаар харуулав.  

Огнооны харагдах байдлыг `scale_x_date()` -ээр тохируулж болно. Энэ талаар [Epidemic curves] хуудаст дэлгэрүүлж бичсэн. `scale_x_date()` функцын `date_labels = ` аргументэд "strptime" гэсэн форматыг зааж өгдөг. Энэхүү формат "%" тэмдэгтийг огноог илэрхийлэх тэмдэг болгодог ( дэлгэрэнгүй мэдээллийг [Working with dates] хуудаст оруулсан). Тухайлбал "%Y" гэж бичвэл жилийг 4 цифрээр бичихийг, "%W" эсвэл "%U" -аар хэддүгээр долоо хоног болохыг зааж өгдөг (нэгдэх, бүтэнсайнаар эхэлдэг долоо хоног).  

```{r, warning=F, message=F}
linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week")) %>%  # долоо хоногийн багана
  ggplot()+                                                  # ggplot-ыг эхэл
  geom_histogram(mapping = aes(x = epiweek_date))+           # өвчний эхлэлийн гистограмм
  scale_x_date(date_labels = "%Y-W%W")                       # огнооны форматыг YYYY-WWw болгоно
```


### Датандах тархварзүйн долоо хоног  {.unnumbered}  

Хэрэв таны гол зорилго график бүтээх *биш* бол дараах хоёр аргыг хэрэглэж болох юм:

1) *For fine control over the display*, convert the **lubridate** epiweek column (YYYY-MM-DD) to the desired display format (YYYY-WWw) *within the data frame itself*, and then convert it to class Factor.  

Эхлээд **base** R -ын `format()` -аар огнооны YYYY-MM-DD форматыг YYYY-Www болгож хувирга ([Working with dates] хуудсаас харна уу). Ингэснээр карактер төрлийн багана болж хувирна. Үүнийг `factor()`-аар фактор болгож хувирга.  


```{r}
linelist <- linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week"),       # тархварзүйн долоо хоног үүсгэ (YYYY-MM-DD)
         epiweek_formatted = format(epiweek_date, "%Y-W%W"),  # Хувирга (YYYY-WWw)
         epiweek_formatted = factor(epiweek_formatted))       # Факторт хувирга

# Түвшнүүдийг харуул
levels(linelist$epiweek_formatted)
```

<span style="color: red;">**_АЮУЛТАЙ:_** Хэрэв та долоо хоногийн дугаарыг жилийн урд талд нь оруулбал  ("Www-YYYY") ("%W-%Y") default тохируулгаар (alpha-numeric) буруу эрэмбэлэгднэ (жишээ нь 01-2015 нь 35-2014 -ын урд талд бичигднэ). Үүнийг зөвхөн гараар янзалж болдог бөгөөд энэ нь маш их ажиллагаатай.</span>  

2) *For fast default display*, use the **aweek** package and it's function `date2week()`. Долоо хоногийн эхлэх өдрийг `week_start = ` аргументээр тохируулж болдог. Хэрэв `factor = TRUE` гэж тохируулбал үүсэх багана нь фактор болдог. Ингэснээр байж болох *бүх* долоо хоногийг оруулж болдог (тухайн долоо хоногт тохиолдол гараагүй байсан ч гэсэн ).
```{r, eval=F}
df <- linelist %>% 
  mutate(epiweek = date2week(date_onset, week_start = "Monday", factor = TRUE))

levels(df$epiweek)
```

[Working with dates] хуудаснаас  **aweek**-ийн талаар нэмж үзэж болно. Энэ багцад бас урвуу функц `week2date()` байдаг.  



<!-- ======================================================= -->
## Эх сурвалж {} 

R for Data Science номын  [factors](https://r4ds.had.co.nz/factors.html) хуудас 
[aweek package vignette](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html).
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/factors.Rmd-->


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Датаг пивот хийх  {}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```



Дата менежментийн үед *пивот*-ыг дараах хоёр тохиолдолд хэрэглэдэг:  

1. *Пивот хүснэгт*-ийг байгуулахад хэрэглэнэ. Пивот гэдэг нь датаны статистик үзүүлэлтүүдийг хүснэгтэлж, дүгнэж харуулахыг хэлдэг.
2. Дата хүснэгтийг **урт** -аас **өргөн** эсвэл **өргөн** -өөс **урт** формат болгож хувиргахад хэрэглэнэ.

**Энэхүү хуудаст хоёрдугаар хэрэглээг голчилж үзэх болно.** Эхний хэрэглээ нь дата анализийн маш чухал хэсэг тул [Grouping data] болон [Descriptive tables] хуудсуудад дэлгэрэнгүйгээр тайлбарлагдна. 
 

Энэ хуудсанд ихэвчлэн датаны форматыг янзлах талаар үзэх болно. "Цэгцтэй дата" буюу хувьсагч болгон өөрийн баганатай, ажиглалт бүр өөрийн мөртэй, утга бүр өөрийн гэсэн нүдэнд оршдог талаар санаж байх хэрэгтэй.Энэ талаар илүү дэлгэрэнгүйгээр  [at this online chapter in R for Data Science](https://r4ds.had.co.nz/tidy-data.html) -д тайлбарласан байдаг. 




## Бэлтгэл   

### Багцуудыг ачааллах  {.unnumbered}  

Энэ хэсэгт анализ хийхэд шаардлагатай багцуудыг доорхи кодоор ачааллана.**pacman** багцын `p_load()` функцээр шаардлагатай багцыг татаж аваад ачааллана уу. Өмнө татаж авсан багцуудаа **base** R -ын `library()`-аар ачааллаж болно. Багцын талаарх нэмэлт мэдээллийг [R basics] хэсгээс харна уу.  

```{r}
pacman::p_load(
  rio,          # Файлыг импортлох
  here,         # Файлыг байрлуулах
  tidyverse)    # дата менежмент + ggplot2 графикууд
```



### Датаг импортлох  {.unnumbered}


### Хумхаагийн бодит тоон дата  {-}  

Энэ хуудасны жишээ дасгалд хумхаагийн өдөр тутмын тохиоллдолтой зохиомол датаг ашиглах болно. Дагаж дасгалыг ажиллах бол <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/malaria_facility_count_data.rds' class='download-button'>линк дээр дарж татаж авна уу (as .rds file)<span></a>. Датагаа  **rio** багцын `import()` функцээр импортло (энэ функц .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг [Import and export] хуудаст нэмж тайлбарласан).  

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Дата импортлох
count_data <- import("malaria_facility_count_data.rds")
```

Эхний 50 мөрийг дор хэвлэж харуулав.

```{r, message=FALSE, echo=F}
# linelist датаг хүснэгт хэлбэрээр харуул
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Linelist бодит тоон дата  {-}  

Энэ хуудасны сүүлийн хэсэгт Эболагийн дэгдэлтийн зохиомол датаг ашиглах болно. Дагаж дасгалыг ажиллах бол  <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линкинй "clean" linelist дээр дарж татаж авна уу</a> (as .rds file). Датагаа  **rio** багцын `import()` функцээр импортло (энэ функц .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг [Import and export] хуудаст нэмж тайлбарласан).  

```{r, echo=F}
# linelist -ийг R -т импортло
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# Датасетээ импортло
linelist <- import("linelist_cleaned.xlsx")
```







<!-- ======================================================= -->
## Өргөнөөс уртруу хувиргах  {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```


<!-- ======================================================= -->
### "Өргөн" формат  {.unnumbered}

Ихэнх дата "өргөн" форматтай байдаг. Өргөн формат гэдэг нь тухайн субьекттэ хамаатай хэв шинж, хариултууд бүгд нэг мөрөнд хадгадагдсан байхыг хэлнэ. Ингэж харуулах нь ойгомжтой боловч анализ хийхэд тохиромжгүй байдаг.  

Өмнөх Бэлтгэл хэсэгт импортлож оруулсан `count_data` датаг авч үзье. Датаг харахад мөр болгон байгууллага тус бүрийн өдөр тутмын байдлыг ( "facility-day")-г харуулж байна. Яг жинхэнэ тохиолдлын тоо (хамгийн баруун талын багана) нь "өргөн" форматаар хадгалагдаж нас насан дах тохиолдлын тоо нь дан мөрөнд хадгалагдсан байна. 

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

Энэхүү датасетийн ажиглалт бүр эдгээр 65 байгууллагын нэгэнд тухайн өдөр гарсан хумхаагийн тоог илтгэж байна. Огноо нь ranging ` count_data$data_date %>% min()` -ээс ` count_data$data_date %>% max()` хүртэл үргэлжилнэ. Эдгээр байгууллагууд Хойд `Аймаг`-ын  (Spring, Bolo, Dingo, Barnard) гэсэн дөрвөн `Дүүрэгт` тарж байрласан. Энэхүү дата хумхаагийн тоог нийт болон гурван насны ангиллаар (<4 нас, 5-14 нас, 15 -аас дээр нас) тус бүр харуулсан. 

Иим "Өргөн" хэлбэрийн формат нь  "цэгцтэй дата" байж чаддаггүй.  Учир нь энэхүү баганын толгойнууд "хувьсагчийг" биш харин "насны бүлэглэл" хэмээх хувьсагийн *утгыг* илтгэж байдаг.

Энэ формат нь мэдээллийг хүснэгтээр үзүүлэх эсвэл тохиолдлын тоотой тайлангийн маягтаас өгөгдөл оруулахад (жишээ нь Excel дээр) хэрэгтэй байж болно. Харин анализ хийхийн өмнө энэ датаг "урт" фомартруу шилжүүлж "цэгцтэй дата" -ны стандартад нийцүүлэх хэрэгтэй байдаг. R -ын график байгуулдаг **ggplot2** багц "урт" форматтай дататай илүү зохицдог.  

Одоогийн форматад хумхаагийн *нийт* тоог цаг хугацааны хувьд тооцоход асуудалгүй:

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

Харин энэхүү нийт тохиолдлын тоонд насны ангилал хэрхэн нөлөөлж буйг хэрхэн тооцоолж харуулах вэ? Үүний тулд сонирхож буй хувьсагч болох (насны ангилал)-ыг датанд нэг баганад оруулах хэрэгтэй ба ингэснээр `{ggplot2}`-ын "mapping aesthetics" `aes()` аргументэд өгөгдөл болж орох боломжтой болно.



<!-- ======================================================= -->
### `pivot_longer()` {.unnumbered}

Датаг **tidyr** багцын `pivot_longer()` функцээр "урт" болгож болно. **tidyr** нь **tidyverse** -ын харьяа багцуудын нэг.  

Энэхүү функцээр хэсэг багануудыг зэрэг өгөгдлөөр (`cols = ` аргументэд) оруулж, хувиргах боломжтой. Тиймээс энэ нь датаны зөвхөн тодорхой хэсэгт үйлчилдэг. Энэ онцлог нь хумхаагийн датаг хувиргахад их тохиромэтой. Учир нь бид зөвхөн тохиолдлын тоотой багануудыг л хувиргах шаардлагтай. 

Энэхүү процессийн эцэст хоёр төрлийн багануудтай болдог. Үүний нэг нь шинээр үүссэн ангиллын нэрийг бичсэн (энэ ангиллууд хуучин хүснэгтийн баганын нэр байсан) багана, нөгөө нь эдгээр ангилалд тохирох утгууд (тохиолдлын тоо)-тай багана юм. Шинээр үүссэн хоёр баганын автоматаар үүссэн нэрийг хэрэглэж болно. Эсвэл `names_to = ` болон `values_to = ` аргументуудэд тусгай нэр өгч автомат нэрийг өөрчилж болно. 

`pivot_longer()` -ийг хэрхэн ашиглахыг харцгаая... 



### Стандарт пивот {.unnumbered}  

**tidyr** багцын `pivot_longer()` функцээр "өргөн" датаг "урт" формат болгох болно. Ялангуяа хумхаагийн тоог харуулсан дөрвөн тоон баганыг *насны ангиллууд*-ыг агуулсан нэг багана, үүнд тохирсон тоон үзүүлэлттэй утгыг агуулсан өөр нэг багана болгож хувиргах хэрэгэтэй.  

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Шинээр үүссэн хүснэгтийн (`df_long`) мөрийн тоо илүү  байгааг анхаар (12,152 -г 3,038 тэй харьцуул); Хүснэгт *урт* болсон. Өөрөөр хэлбэл яг дөрөв дахин урт болсон гэсэн үг. Учир нь хуучин хүснэгтийн нэг мөр  df_long хүснэгтийн дөрвөн мөр болж өөрчлөгдсөн ба хумхаагийн дөрвөн төрлийн (<4 нас, 5-14 нас, 15y+, нийт) тоон үзүүлэлт тус бүрт нэг мөр үүссэн гэсэн үг юм .

Шинэ хүснэгт урт болохоос гадна цөөн баганатай (8 -г 10-тэй харьцуулах) болсон байна. Учир нь өмнөх дөрвөн багана дах мэдээлэл ( `malaria_` гэж эхэлсэн баганууд) хоёр баганад хадгалагдах болсон. 

Эдгээр дөрвөн багана `malaria_`гэж эхэлж буй тул "tidyselect"-ын `starts_with()` функцыг ашиглаж хувиргалтаа хийж бас болно (эдгээр туслах функцуудын талаар[Cleaning data and core functions] хэсэгт дэлгэрэнгүй оруулсан).  

```{r}
# tidyselect-ын туслах функцуудээр өөрчлөх хүснэгтийг сонго
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

эсвэл байрлалаар нь сонго: 

```{r, eval=F}
# байрлалаар нь сонго
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

эсвэл хэсэг дараалласан багануудыг сонго:

```{r, eval=F}
# нэг хэсэг дарааллаасан багануудыг сонгох
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```



Энэхүү шинээр үүсэх хоёр баганууд `name` болон `value` гэж автоматаар нэрлэгддэг боловч доторх утгыг ойлгомжтой болгох үүднээс `names_to` болон `values_to` аргументүүдэд илүү тодорхой нэр өгч болно. Жишээ болгож `age_group` болон `counts` гэсэн нэр өгье:

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

Шинээр үүсгэсэн датагаа `{ggplot2}`-д оруулж шинэ үүссэн `count` баганыг y-тэнхлэгт байрлуулж, шинэ үүссэн `age_group` баганыг `fill = ` аргументэд (өнгөөр ялгана) өгч болох боломжтой боллоо. Ингэснээр bar графикт хумхаагийн тохиолдлын тоо насны бүлгүүдээр даврхаласан байдлаар харуулсна.

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Дараахь шинэ графикийг өмнөх графиктай харьцуулж *буруу хийгдсэн зүйлсийг?* тодруулцгаая.  

Тандалтын датаг янзалж байхад нийтлэг тохиолддог бэрхшээлтэй бид учирсан байна. Мөн `malaria_tot` баганын нийт тоог оруулснаас bar -ын өндөр байх ёстой хэмжээнээс хоёр дахин өндөр болж харагдаж байна. 

Үүнийг хэд хэдэн аргаар шийдвэрлэж болно. Энгийн арга бол `ggplot()`-д оруулахаас өмнө энэхүү нийт (`malaria_tot`)-ийг шүүж хасч болно:

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Эсвэл `pivot_longer()` коммандыг өгч байхдаа энэ хувьсагчийг хасч болно. Ингэснээр хүснэгтэд тусдаа хувьсагч хэвээр байх болно. Шинэ үүссэн мөрүүд ямар утгууд орж "өргөжсөн" -ийг харна уу.

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # нийт тоон үзүүлэлттэй баганыг оруулаагүй
    names_to = "age_group",
    values_to = "counts"
  )
```





### Олон ангилалтай датаг пивот хийх {.unnumbered}


Дээрх жишээний коммандыг "pivot longer" болгож хувиргах баганууд бүгд нэг төрлийн утгатай (карактер, тоон, логик г.м)  байх нөхцөлд илүү тохиромжтой.

Харин талбарын тархвар зүйчээр ажиллаж байхад ихэвчлэн датаг мэргэжлийн бус хүмүүс оруулсан байдгаас стандарт бус логикоор шивэгдсэн олон төрлийн дататай олон учрах болно. Хадлей Викхам **Цэгцтэй датан** -ны зарчмыг [seminal article](https://vita.had.co.nz/papers/tidy-data.pdf) -тайлбарлахдаа Толстойн үгтэй зүйрлэн "Цэгцтэй дата болгон адил ч бүх гэр бүлд байдагчлан замбараагүй дата болгон өөрийн жамаараа замбараагүй байдаг" гэж тайлбарлажээ.

Хамгийн элбэг тохиолддог бэрхшээлүүдийн нэг бол өөр өөр төрлийн дататай багануудыг пивот хийх юм. Ийм датаг пивот хийхэд янз бүрийн дата төрлүүд нэг баганад ордог. Энэ бол сайн арга биш. Энэ үүссэн замбараагүй байдлыг янзлах олон арга буй боловч  `pivot_longer()` -ыг хэрэглэж ийм байдал үүсэхээс та өөрөө сэргийлж болно.

А, В, С гурван зүйл тус бүрийг өөр цаг хугацаануудад хэд хэдэн ажиглалт хийсэн нөхцөл байдлыг авч үзье. Ийм нөхцлүүдээс дурьдвал Эболагийн тохиолдлуудад 21 хоног тутамд ажиглах, эсвэл алслгадсан тосгоны эрүүл мэндийн цэгийн үйл ажиллагааг жилд нэг удаа хянаr зэрэг байж болно. Эхний жишээ дээр ажиллаж үзье. Дата дараах байдлаар хадагалгдсан байв:


```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

Энэ хүснэгт төвөгтэй байдлаар бичигдсэн байна. Мөр болгон нэг зүйлийн талаарх мэдээллийг бичсэн боловч цаг хугацааны дараалал нь хойшоогоо улам л холдоод байна.  Мөн карактер болон огноон баганууд ээлжл орсон байна. 

Зохиогч миний бие өөр нэгэн их хэцүү байдалтай холерийн тандалтын дататай учирч байлаа. Энэ датанд 4 жилийн турш "өдөр бүр" 8 шинэ ажиглалт нэмэгдэж байсан ба компьютер дээрээ  Excel файлыг нь нээх бүрт 10-аас дээш минут зарцуулагддаг байсан!

Ийм байдалтай датанууд ажиллахын тулд "урт" форматруу хувиргах хэрэгтэй боловч ажиглалт тус бүрийн `огноо`, `карактер` (эрүүл мэндийн байдал) багануудын салангид хэвээр байлгах хэрэгэтэй. Тэгж чадахгүй бол олон хувьсагчуудын холимог нэг баганатай болж хоцрох аюултай (цэгцтэй дата болон дата менежментийн хувьд хамгийн болохгүй зүйл):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Өмнөх жишээнд пивот маань *огноо* болон *карактерүүд* нэгдэж нэг төрлийн `утга` агуулсан багана болж орсон. Үүнийг R автоматаар карактер багана болгож хувиргах ба агуулагдах датаг хэрэглэх боломжгүй болдог.  


Баганын анхны нэрний синтакс бүтцийг ашиглаж ийм байдлаас сэргийлж болно. Баганыг нэрлэх нийтлэг бүтэц байдаг. Үүнд ажиглалтын дугаар, доогуур зураас, "статус" болон "огноо" араас нь бичигдсэн байдаг.  Энэ синтаксыг ашиглаж пивот хийсний дараа энэ хоёр төрлийн датаг салангид багана хэвээр байлгаж болно. 

Үүнийг хийхдээ:  

* Карактер векторуудыг `names_to = ` аргументэд өгөөд, хоёрдугаарт нь `".value"` гэж оруулна. Энэхүү тусгай тэмдэглэгээ нь пивот хийгдэж буй баганын нэрэн дэх карактер дээр үндэслэж хуваагдах болно гэдгийг зааж өгч буй. 
* Мөн "хуваах" карактерийг `names_sep = ` аргументэд зааж өгнө. Доор жишнээд доогуур зураасыг "_" сонгосон. 

Ингэснээр шинээр үүсэх баганыг нэрлэж, хуваах үйлдэл анхны хувьсагчийн нэрэн дэх доогуур зураасыг тойрч хийгднэ гэсэн үг. 

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

__Сүүлийн засвар__:

`date` багана  *карактер* хэлбэрт байгааг анхаараарай. Үүнийг `mutate()` болон `as_date()` функцуудээр тохирсон огноо хэлбэрийн баганад хувиргахад хялбар ([Working with dates] хуудаст заасны дагуу ).  

Мөн `observation` баганын "obs" гэсэн бичиглэлийг нь хасч `тоон` форматад оруулна.  Үүнийг **stringr** багцын `str_remove_all()` функцээр хийж болно ([Characters and strings] хуудаст тайлбарласан).  

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

Ингээд бид энэхүү дата дээр ажиллаж болохоор боллоо. Жишээ нь дор коммандад heat хавтангаар дескриптив график байгуулж болж байна.

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```





<!-- ======================================================= -->
## Уртаас өргөнрүү {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```


Зарим тохиолдолд дата хүснэгтийг өргөн хэлбэрт шилжүүлэх хэрэгцээ гардаг. Энэ үйлдэлд `pivot_wider()` функцыг ашиглаж болно.

Жишээ нь анализийн үр дүнг уншигчдад ойлгомжтой хүснэгтээр харуулах үүднээс хүснэгтийг өргөн хэлбэрт хувиргах хэрэгцээ цөөнгүй гардаг (жишээ нь [Table for presentation][Tables for presentation]). Энэ үед олон мөрүүдэд тархан хадгалагдсан нэг субьектийн мэдээллийг нэг мөрөнд болгож харуулах үйлдэл ихэвчлэн хийгддэг.

### Дата {.unnumbered}

Энэ хэсэгт тохиолдол бүрт нэг мөртэй linelist датаг ашиглана ([Preparation](#pivot_prep) хэсэгт тайлбарласан).

Эхний 50 мөр:  

```{r, message=FALSE, echo=F}
# linelist-ыг хүснэгтээр харуул
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Насны ангилал, хүйсээр нь тохиолдлын тоог харуулахаар бол:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

Энэхүү хүснэгтээр бид **ggplot2** ашиглаж графикаар датаг харуулахад тохиромжтой боловч хүснэгтээр датаг тайлбарлахад тохирмжгүй болж байна.

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Өргөн хэлбэрт пивот хийх {.unnumbered}  

Тиймээс `pivot_wider()` -аар датаг хувиргаж, датаг илүү оновчтой байдлаар харуулсан хүснэгтийг тайланд хавсаргах боломжтой юм. 

`names_from` аргументээр *аль* баганыг ашиглаж шинээр үүсэх баганын *нэрсийг* үүсгэхийг зааж өгдөг бол `values_from` аргументээр *ямар* баганын *утгуудыг* авч шинэ нүднүүдэд хуваарилахыг зааж өгдөг. Мөн нэмэлтээр `id_cols = ` аргумент байдаг ба үүнд пивот хийхгүй багануудын нэрстэй векторыг зааж өгдөг. 

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

Энэ хүснэгт уншихад ойлгомжтой тул тайлан мэдээнд хавсаргахад их тохиромжтой харагдаж байна. Хүснэгтийн өнгө үзэмжийг  **flextable**,  **knitr** зэрэг багцуудаар янзалж болно. Энэ талаар [Tables for presentation] хэсэгт илүү тайлбарласан.  

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

---


<!-- ======================================================= -->
## Нөхөх 

`pivot` хийгээд дараа нь `bind` хийсний дараа зарим тохиолдолд хэдэн нүднүүд хоосон үлдэж, нөхөх шаардлага гардаг.

<!-- ======================================================= -->
### Дата {.unnumbered}

Жишээ болгож дараах хоёр датасетийг авч үзье. Хоёул хэмжилтийн дугаар, байгууллагын нэр, тохиолдлын тоо агуулсан боловч хоёр дах нь үүн дээр нэмээнд `Year` гэсэн хувьсагчтай.

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```


Хэрэв бид `bind_rows()` -аар хоёр датаг нэгтгэвэл `Year` хувьсагчийн (эхний дата дах) мэдээлэлгүй нүднүүд `NA` болж хувирна.


```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->
### `fill()` {.unnumbered}

Энэ тохиолдолд `Year` бол цаг хугацааны явцыг харуулдаг хэрэгтэй хувьсагч тул байлгаж байх нь чухал. Ингэхдээ `fill()` функцын аргументэд нөхөх шаардлагатай баганууд болно чиглэлийг (энэ тохиолдолд дээш/**up**) зааж өгч тэдгээр хоосон нүднүүдийг *нөхөж* болно :

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Мөн датаг дахин эрэмбэлсний дараа нөхөх чиглэлийг доош чиглэлтэй болгож болно:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

Одоо бид энэхүү хүснэгтийг ашиглан график байгуулах боломжтой боллоо:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

Харин энэ хүснэгтээр датаг танилцуулахад тийм ч тохиромжтой биш тул урт, цэгцгүй датаг өргөн цэгцтэй хэлбэрт хүснэгтлэн харуулья: 

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

Энэ тохиолдолд бид зөвхөн `Facility`, `Year`, `Cases` гэсэн гурван хувьсагчийг л оруулахыг зааж өгсөн ба хүснэгтийн бүтцэд таарахгүй учраас `Measurement` хувьсагчийг нэмж оруулаагүй: 

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Нэмэлт мэдээллүүд

Энд хэрэгтэй хичээлүүд буй [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/pivoting.Rmd-->


# Датаг бүлэглэх { }  


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```


Энэ хуудсанд дескриптив анализэд зориулж өгөгдлийг хэрхэн бүлэглэх, нэгтгэх талаар тусгасан болно. Үүнийг гүйцэтгэхэд энгийн, хэрэглэхэд хялбар функцуудтэй **tidyverse** багцуудыг ашигладх болно.


Датаг бүлэглэх үйлдэл бол дата менежмент, дата дүн шинжилгээний үндсэн элэмент мөн. Датаг статистикийн үзүүлэлтээр бүлэглэн шинжилж, график зураглалыг бүлгээр нь тус бүр харуулдаг.**dplyr**  багцын (**tidyverse** харьяа ) функцууд бүлэглэх болон үүнтэй холбоотой бусад үйлдлүүдийг гүйцэтгэхэд хялбар болгодог.  

Энэхүү хуудаст дараах сэдвүүдийн талаар оруулсан:  

* `group_by()` функцээр бүлэглэгдсэн дата 
* Датандах бүлгийг задлах 
* бүлэглэсэн датаг функцээр `summarise()` статистикийн үзүүлэлтүүдийг харуулах  
* `count()` болон `tally()` функцуудын ялгаа
* Бүлэглэсэн датанд `arrange()` -ыг хэрэглэх 
*  Бүлэглэсэн датанд `filter()` -ыг хэрэглэх  
*  Бүлэглэсэн датанд `mutate()` -ыг хэрэглэх 
*  Бүлэглэсэн датанд `select()` -ыг хэрэглэх  
* **base** R -ын `aggregate()` коммандыг хэрэглэх



<!-- ======================================================= -->
## Бэлтгэл {  }
     
### Багцыг ачааллах {.unnumbered}  
     
Энэ хэсэгт анализ хийхэд шаардлагатай багцуудыг доорхи кодоор ачааллана.**pacman** багцын `p_load()` функцээр шаардлагатай багцыг татаж аваад ачааллана уу. Өмнө татаж авсан багцуудаа **base** R -ын `library()`-аар ачааллаж болно. Багцын талаарх нэмэлт мэдээллийг [R basics] хэсгээс харна уу.  


```{r}
pacman::p_load(
  rio,       # Файлыг импортлох
  here,      # Файлыг байрлуулах
  tidyverse, # датаг цэвэрлэх, янзлах, график байгуулах (dplyr-г орно)
  janitor)   # мөр, баганын нийт дүнг нэмнэ
```




### Импорт дата {.unnumbered}

Энэ хэсэгт Эболагийн дэгдэлтийн үеийн зохиомол датаг ашиглах болно. Дагаж дасгалыг ажиллах бол <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линк дээр дарж "цэвэр" linelist татаж авна уу </a> (as .rds file). Датагаа  **rio** багцын `import()` функцээр импортло (энэ функц .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг [Import and export] хуудаст нэмж тайлбарласан). 

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Эхний 50 мөр `linelist`:  

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Бүлэглэх {  }
     
**dplyr** -ын `group_by()` функц зааж өгсөн багана дах өвөрмөц утгын дагуу мөрүүдийг бүлэглэх болно. Ингэхдээ олон багана зааж өгвөл, мөрүүд эдгээр багануудын хооронд үүссэн өвөрмөц комбинацын дагуу бүлэглэгдэх болно.  Өвөрмөц утга болгон (комбинац болгон) бүлэг бий болгоно. Ингэсний датанд хийгдэх аливаа өөрчлөлт, тооцоо зэрэг нь бүлэг тус бүрээр хийгдэх болно. 

Жишээлбэл дараах коммандаар `linelist` хүснэгтийн  `outcome` баганын утгуудаар мөрүүдийг бүлэглэсэн байна. Үүний дүнд үүсэх хүснэгтийг`ll_by_outcome`-д хадгалсан. Бүлэглэх багануудыг  `group_by()` функцэд хаалтан дотор бичнэ.  

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

`group_by()`коммандыг өгснөөр **датанд мэдэгдэхүйц өөрчлөлт гарахгүй**. Харин энэхүү бүлэглэсэн датанд `mutate()`, `summarise()`, `arrange()` зэрэг **dplyr**-ын бусад функцыг уншуулсны *дараа* өөрчлөлт хийгдэж эхэлдэг болохыг анхаар.

Гэхдээ хүснэгтийг хэвлэснээр бүлэглэсэн датаг *харж* болно. Хэвлээд үзвэл хүснэгт tibble хэлбэрт орсон байх ба [`tibble` class object](https://tibble.tidyverse.org/) ямар бүлгүүд, хэд бүлэглэгдсэн зэрэг мэдээлэл толгой мөрний дээр бичигдсэн байдаг.  

```{r}
# идвэхитэй ямар бүлгүүд байгааг хэвлэж хар
ll_by_outcome
```


### Өвөрмөц бүлгүүд {.unnumbered}  

**Бүлэг үүсгэж багануудын утгууд солбиж нэгдэн бүрдүүлсэн өвөрмөц комбинац болгон бүлэг юм**.

Үүссэн бүлэг *болон бүлэг тус бүрт хамрах мөрийн тоог * харахдаа  `tally()`функцэд баганыг оруул. Хэрэв зөвхөн үүссэн өвөрмөц бүлгүүдийн нэрсийг харах бол `group_keys()` коммандыг өг.  

Доорх жишээнд бүлэг үүсгэж буй `outcome` баганад **гурван** өвөрмөц утга байна: "Death", "Recover", `NA`. Нийт мөрийн тоо нас баралтад (deaths)` nrow(linelist %>% filter(outcome == "Death"))`, эдгэрэлтэд (recoveries)` nrow(linelist %>% filter(outcome == "Recover"))` , эмчилгээний үр дүн бичигдээгүй мөр ` nrow(linelist %>% filter(is.na(outcome)))` байсан.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```


Нэгээс дээш тооны баганыг ашиглаж бүлэглэж болно. Доор жишээнд хүснэгтийг `outcome` болон `gender` баганын дагуу бүлэглээд бүртгэлийг tally() -аар харуулсан байна. Үүнээс `outcome` болон `gender` багануудын утгууд нийлж хичнээн бүлэг үүсгэж буйг хараарай (хоёр баганын дутуу утгуудын комбинацаар үүссэн бүлгүүд мөн орно).

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### Шинэ багана {.unnumbered} 

Мөн `group_by()` *дотор* бүлэглэх шинэ баганыг оруулж бичиж болно. Энэ нь `group_by()`хийхийн өмнө `mutate()` хийхьэй адил үйлдэл юм. Богино хугацаанд бүлэглэсэн хүснэгт үүсгэх үед энэ аргыг хэрэглэх нь хялбар боловч кодоо илүү тодорхой болгох үүднээс шинээр үүсгэх баганаа тусдаа `mutate()` -аар үүсгэж араас нь `group_by()`-ыг pipe хийх нь илүү оновчтой байх болно.

```{r}
# group_by() комманд дотор үүсгэсэн binary баганын дагуу датаг бүлэглэсэн
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### Бүлэглэх баганыг нэмж/хасах {.unnumbered}  

Хэрэв өмнө нь бүлэглэсэн байсан датанд `group_by()` коммандыг уншуулахад хуучин бүлэг арилж шинэ бүлэг үүсдэг. Хэрэв хуучин бүлэг дээр нэмж бүлэг оруулах бол `.add = TRUE` аргументэд нэмж зааж өг.  

```{r, eval=F}
# outcome баганын дагуу бүлэглэгдсэн
by_outcome <- linelist %>% 
  group_by(outcome)

# gender  баганын дагуу нэмж бүлэглэ
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```


** Бүх бүлгийг үлдээх**  

Хэрэв фактор ангилалтай баганаар бүлэг үүсгэж байх явцад тухайн ангиллын аль нэг түвшинд хамрах утга датанд байхгүй байж болно. Энэ үед энэхүү хоосон түвшин хасагдаж, энэ түвшинд бүлэг үүсэхгүй. Хэрэв тухайн утга датанд байхгүй байсан ч гэсэн бүлэг болж орох шаардлагатай бол `.drop = FALSE` гэж `group_by()`-ын аргументийг тохируул. 


## Бүлгийг задлах  

Тусгайлан `ungroup()` гэсэн коммандаар задлахаас нааш бүлэг датанд оршсоор байх болно. Хэрэв бүлгийг буцааж задлахаа мартвал буруу тооцоололд хүрэх аюултай ! Доор жишээнд хэрхэн бүх бүлгийг задлахыг харуулав:  

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

Мөн тодорхой нэг баганыг `ungroup()` дотор оруулж комманд өгснөөр зөвхөн тухайн баганын бүлгийг л арилгаж болно.

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # gender-ын бүлгийг арилгаж, outcome-ын бүлэгүүдийг үлдээ
```


<span style="color: black;">**_ТЭМДЭГЛЭЛ:_**  `count()` функцыг уншуулсны дараа бүлгүүд автоматаар буцаж задардаг .</span>



## Нэгтгэх {#group_summarise} 

[Descriptive tables] хуудсын **dplyr** -ын талаар бичсэн хэсэгт `summarise()` функцээр хэрхэн хураангуй хүснэгт үүсгэх талаар илүү тайлбарласан. Энд гол тайлбарлах зүйл бол бүлэг үүсгэснээр энэ үйлдлйин хэв шинж нь хэрхэн өөрчлөгдөхийг товчхон харуулна.

**dplyr** -ын `summarise()` (эсвэл `summarize()`) функц хүснэгтэндэх датаг янзалж баганууддаа статистик дүнтэй хураагуй хүснэгтийг *шинээр* үүсгэдэг. Бүлэглээгүй датанп статистикийн дүн бүх мөрөнд тооцоолсны дүнд тавигддаг. Харин бүлэглэсэн датанд `summarise()`-ыг оруулбал статистикийн тооцоо *бүлэг тус бүрт* бодогддог.  

`summarise()` -ын синтаксыг бичихдээ эхлээд **шинэ** үүсгэх тооцооны дүнтэй баганын нэрс, тэнцүүгийн тэмдэг, датанд хийх статистикийн бодолт хийх функцыг бичнэ.Жишээ нь `min()`, `max()`, `median()`, `sd()` зэрэг статистик функцууд байж болно. Статистикийн функцууд дотор бодолтод оролцох баганууд болон бусад нэмэнлт аргументуудыг (`na.rm = TRUE` гэх мэт) бичнэ. Мөн `sum()` -ыг хэрэглэж логик шалгуурт тэнцсэн мөрийн тоог гаргаж болно  (давхар тэнцүүгийн тэмдэгтэйгээр `==`).   

Дор жишээнд `summarise()` -ыг  *бүлэглээгүй датанд* хэрэглэсэн байна. Статистикийн дүн нь нийт бүх мөрөнд тооцоолол хийсний дүнд гарсан.

```{r}
# бүлэглээгүй linelist дээр статистикийн хураангуй бодож гаргах
linelist |> 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

Харин удаах жишээнд `summarise()` функцийг бүлэглэсэн дата дээр ашиглаж байна. `outcome` баганын бүлэг тус бүрт статистикийн бодолт хийгдсэн. Бүлэглэсэн баганууд шинэ датафрэйм рүү хэрхэн шилжиж буйг анхаарна уу.    

```{r}
# бүлэглэсэн linelist дээр статистикийн хураангуй бодож гаргах
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

<span style="color: darkgreen;">**_ЗӨВЛӨГӨӨ:_** summarise функцын UK (`summarise()`) болон US (`summarize()`) хувилбарууд ижил. </span>




## Тоолж, бүртгэх  

`count()` болон `tally()` төстэй үйлдэл хийдэг боловч өөр. `tally()` болон `count()`-н лгааны талаар [here](https://dplyr.tidyverse.org/reference/tally.html)-ээс олж уншна уу.    

### `tally()` {.unnumbered}  

`tally()` бол `summarise(n = n())`коммандын богино хувилбар ба датаг *бүлэглэдэггүй*. Тиймээс бүлэглэсэн датанд хэрэглэх бол `group_by()` -ын араас залгуулж хэрэглэдэг. Мөн үүн дээр `sort = TRUE` гэж аргументийг тохируулснаар хамгийн том бүлгийг эхэнд жагсааж болно.   

```{r}
linelist %>% 
  tally()
```


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```


### `count()`  {.unnumbered}  

Харин `count()` функц дараах үйлдлүүдийг хийдэг:  

1)  тодорхой заасан багануудад `group_by()`-г хэрэглэдэг.
2) `summarise()` хэрэглэсний дүнд `n` баганад бүлэг тус бүр хэдэн мөр агуулагдаж буйг тоолж гаргадаг.
3) мөн `ungroup()` хийгддэг. 

```{r}
linelist %>% 
  count(outcome)
```

`group_by()` -ийн адил  `count()` комманд бас шинэ багана үүсгэдэг:  

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```


`count()` функцыг олон дахин дуудаж болно (өнхрүүлэх байдлаар). Жишээ нь хүйс тус бүрт ноогдох эмнэлэгийн тоог гаргахдаа доорх коммандыг өгнө.  Хамгийн арын багана нь автоматаар "n" гэж нэрлэгдсэн байснаа ( `name  = ` аргументээр) өөрчлөгдөж илүү тодорхой нэртэй болсон байна.  

```{r}
linelist %>% 
  # outcome-gender -ын хавсарч үүссэн бүлгүүдэд ноогдох мөрийг тоолох
  count(gender, hospital) %>% 
  # gather rows by gender (3) and count number of hospitals per gender (6)
  count(gender, name = "hospitals per gender" ) 
```


### Тооллого нэмэх{.unnumbered}  

Мөн `add_count()`-ээр тооллого хийж болох боловч `count()` болон`summarise()`-ээс ялгаатай. Энэ функцыг хэрэглэснээр *хуучин хүснэгт бүхлээрээ өөрчлөгдөхгүй* хэвээр байх ба бүлэг бүрийн тоог гаргасан шинэ `n` гэсэн багана нэмэгддэг. 

Өөрөөр хэлбэл шинэ `n` баганадах бүлэг тус бүрт агуулагдах мөрийн тоо тухайн бүлэгт хамаарах мөр болгонд бичигдэх болно гэсэн үг. Доор жишээнд ойлгомжтой харуулах үүднээс баганыг нэмээд дараа нь эрэмбэнд өөрчлөлт оруулсан болно. Мөн [filter on group size](#group_filter_grp_size) хэсэгт өөр нэгэн жишээ харуулсаныг олж үзнэ үү. 


```{r}
linelist %>% 
  as_tibble() %>%                   # tibble болгож харагдах байдлыг сайжруулна
  add_count(hospital) %>%           # эмнэлэгийн тоотой n баганыг нэм 
  select(hospital, n, everything()) # харахад хялбар болгох үүднээс дахин эрэмбэл
```



### Нийт дүнг нэм {.unnumbered} 

Нийт дүнг хялбар нэмэх арга бол `tally()` эсвэл `count()` хэрэглэсний дараа мөр, баганын *нийлбэрийг* гаргах хэрэгтэй. Үүнийг  [Descriptive tables](#tbl_janitor) хуудасны **janitor** багцыг тайлбарласн хэсгээс үзнэ үү. Энэ багцад `adorn_totals()`, `adorn_percentages()` зэрэг нийт дүнг нэмж, хувь болгох гэх мэт олон функцууд агуулагддаг. Доор товч жишээ харуулья: 

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # хоёр баганыг солбиж-хүснэгтлэн тоолох 
  adorn_totals(where = "row") %>%             # нийт мөрийн нийлбэр
  adorn_percentages(denominator = "col") %>%  # баганын нийлбэрийг деноминатор (хуваариар) тооцож хувийг гаргах
  adorn_pct_formatting() %>%                  # пропорцыг хувь болгож хувиргах
  adorn_ns(position = "front") %>%            # : "тоо (хувь)" гэж харуулах
  adorn_title(                                # гарчигийг янзлах
    row_name = "Age Category",
    col_name = "Gender")
```


*Нийлбэрээс* өөр нарийн статистикийн бодолтыг мөр дагуу бодож гаргах бол  [this section of the Descriptive Tables page](#tbl_dplyr_totals) хэсгээс харна уу.  



## Он сараар бүлэглэх  

Огноогоор бүлэглэхдээ огнооны нэгжийг (өдөр, тархварзүйн долоо хоног, сар гэх мэт) бичих нэг илүү багана байлгах (үүсгэх) хэрэг гардаг. Үүнийг [Working with dates] хуудасны [Epidemiological weeks section](#dates_epi_wks) хэсэгт заасны дагуу **lubridate**-ын `floor_date()` -аар үүсгэж болно. Энэ баганыг үүсгэсний дараа **dplyr**-ын `count()` -аар мөрүүдийг огноогоор бүлэглэж, нэгтгэсэн тоог гаргаж болно.

Огноотой ажиллаж байхад нэмэлтээр хийгддэг өөр нэгэн нийтлэг алхам бол датанд байхгүй ямар нэг огноог дарааллын дагуу "бөглөх" юм.
Нэгтгэгдсэн огнооны дараалалд **tidyr**-ын `complete()` -ыг хэрэглэвэл *тухайн хүрээнд байж болох бүх нэгжийг оруулан* огнооны дараалал*гүйцэд* болддог. Энэ алхмыг хийгэгүй тохиолдолд өвчин илрээгүй долоо хоногууд датанд харагдахгүй!  

Ингэхдээ `complete()` дотор огноотой баганаа `seq.Date()`-ийн багаас ихсэх *дарааллаар* *дахин зааж өгөх* хэрэгтэй бөгөөд, улмаар огнооны дараалал өргөжих болно. Энэхүү өргөжиж нэмэгдсэн шинэ огноонд тохиолдлын тоо `NA` гэж гарч ирдэг. Үүнийг `complete()`-ын  `fill = ` аргументэд 0 гэж зааж өгч засаж болно.  which expects a named list (хэрэв тохиолдлын тоотой баганын нэр `n` гэж нэрлэгдсэн байгаа бол `fill = list(n = 0)` гэж зааж өгнө. Энэ аргументийн өгөдөл нэртэй list байдаг. Энэ талаар `?complete` хуудас болон  [Working with dates](#dates_epi_wks) хуудасны жишээнүүдэд илүү тайлбарласан ).



### Linelist тохиолдлуудыг өдөр бүрээр бүлэглэх {.unnumbered}  

Энд`complete()`функцыг *хэрэглээгүй* байдлаар тохиолдлын тоог өдрөөр бүлэглэх коммандыг харуулав. Тохиолдол илрээгүй эхний өдрүүдийг алгасч харуулсан байгааг анзаарна уу. 

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # date_onset бичигдээгүй тохиолдлуудыг арилгана
  count(date_onset)              # огноо бүрт ноогдох тохиолдлын тоог тоол
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Энд `complete()` коммандыг ашиглаж тодорхой хугацаандах бүх өдрүүдийг гарч ирдэг болгоё.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset бичигдээгүй тохиолдлуудыг арилгана
  count(date_onset) %>%                   # огноо бүрт ноогдох тохиолдлын тоог тоол
  complete(                               # тохиолдол илрээгүй ч бүх өдөр харагдах болно
    date_onset = seq.Date(                # огноотой баганыг өдөр тутмыг харуулсан байдлаар зааж өгнө.
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # n баганын 0 тохиолдолтой мөрүүдийг бөглөх  ( автоматаар гарах NA-ын оронд) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist тохиолдлуудыг долоо хоног бүрээр бүлэглэх {.unnumbered}  


Долоо хоног бүрийн тоог мөн дээрхитэй адил зарчмаар хийнэ. Эхлээд `floor_date()` -ын нэгжийг `unit = "week"`хэмээн тохируулж тохиолдол бүрийн илэрсэн дотоо хоногийн дугаарыг тавьна. Дараа нь`count()` -аар дээрхийн адил долоо хоног бүрт ноогдох тохиолдлын тоог харуулна. Энэ комманд дээрээ `complete()` -ыг нэмбэл тохиолдол илрээгүй ч гэсэн бүх долоо хоног харуулах болно.

```{r}
# Тохиолдлын тоог долоо хоног бүрээр харуулсан хүснэгт байгуул
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset бичигдээгүй тохиолдлуудыг арилгана
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # өвчин эхлэл бүртгэгдсэн долоо хоногийн дугаартай багана
  count(week) %>%                         # долоо хоног бүрээр датаг бүлэглэж, бүлэг бүрт ноогдох мөрийн тоог тоол
  complete(                               # тохиолдол илрээгүй ч гэсэн бүх долоо хоногууд гарч ирдэг болго 
    week = seq.Date(                      # огноотой баганыг өдөр тутмыг харуулсан байдлаар зааж өгнө.
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # n баганын 0 тохиолдолтой мөрүүдийг бөглөх  ( автоматаар гарах NA-ын оронд)  
```

Шинээр байгуулсан хүснэгтийн эхний 50 мөрийг дор харуулав:  

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist тохиолдлуудыг сар бүрээр бүлэглэх {.unnumbered}

Тохиолдлыг сар бүрээр харуулахад мөн **lubridate**  багцын `floor_date()` -ыг хэрэглэнэ. Гэхдээ нэгжийн аргументэд `unit = "months"` гэж тохируулна. Ингэснээр огноо бүр тухайн сарынхаа эхний өдөрт хураагддаг. Үүний үр дүнд огноо хэлбэрийн дататай багана үүснэ. Энэ үед `complete()` алхмыг хийхдээ `by = "months"` гэж аргументээ тохируулна гэдгийг анхаарна уу.  


```{r}
# Тохиолдлын тоог сар бүрээр харуулсан хүснэгт байгуул
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # шинэ багана, өвчин эхэлсэн сарын эхний өдөр
  count(month) %>%                          # сар бүрт ноогдох тохиолдлын тоо
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # тохиолдол илрээгүй ч гэсэн бүх саруудыг гарч ирдэг болго
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Өдөр тутмын тооллогыг долоо хоногт шилжүүлэх {.unnumbered}

Өдөр тутмын тооллогыг долоо хоног бүрт шилжүүлэхдээ `floor_date()` -ыг дээрхийн адил ашиглана. Харин энэ удаад долоо хоногт ноогдох мөрийн тоо биш харин өдөр тутамд илэрсэн тохиолдлын тооны нийлбэрийг (`sum()`) тогтоох хэрэгтэй учраас `count()`биш оронд`group_by()`, `summarize()` функцуудыг хавсарч хэрэглэх шаардлагатай.



#### Өдөр тутмын тооллогыг сард шилжүүлэх {.unnumbered}

Өдөр тутмын тооллогыг сар бүрт шилжүүлэхдээ `floor_date()` -ыг `unit = "month"` нэгжтэйгээр дээрхийн адил ашиглана. Харин энэ удаад сар бүрт ноогдох мөрийн тоо биш харин өдөр тутамд илэрсэн тохиолдлын тооны нийлбэрийг (`sum()`) тогтоох хэрэгтэй учраас `count()`биш оронд`group_by()`, `summarize()` функцуудыг хавсарч хэрэглэх шаардлагатай. 



## Бүлэглэсэн датаг эрэмбэлэх

Бүлэглэсэн датаг **dplyr** -ын `arrange()` -аар эрэмбэлэх явц бүлэглээгүй linelist хүснэгтийг эрэмбэлэхтэй адил. Харин энэ үед аргументийг тохируулбал `.by_group =TRUE` эхлээд бүлэглэсэн баганууд эрэмбэлэгдэж, дараа нь `arrange()` оруулсан бусад баганууд эрэмбэлэгддэг. 



## Бүлэглэсэн датаг шүүх

### `filter()` {.unnumbered}

Дата хүснэгтийг шүүхдээ (filter) бусад функцтэй (`max()`, `min()`, `mean()`зэрэг ) хавсарч хэрэглэдэг ба бүлэглэсэн хүснэгтэд мөн адил хамт хэрэглэж болно. Жишээ нь медианаас дээш настан агуулсан мөрүүдийг үлдээх үйлдлийг бүлэглэсэн хүснэгтэд хийж болно. Өөрөөр хэлбэл бүлгүүдийн медиан наснаас дээш нас агуулсан мөрийг үлдээнэ гэсэн үг. 




### Бүлгээр хуваах {.unnumbered} 

Хуваахдаа **dplyr** -ын `slice()`-ыг ашиглаж болно. Энэ нь мөрийг байрлалын дагуу шүүгдэг ба бүлэглэсэн датанд адилхан үйлчилнэ [filters rows based on their position](https://dplyr.tidyverse.org/reference/slice.html). Хүссэн хэсгүүдэд хуваахын тулд бүлэг тус бүрийг эхлээд дотор нь эрэмбэлэх хэрэгэтй гэдгийг анхаар.

Жишээ нь эмнэлэг тус бүрд хэвтэгсдийн дундаас хамгйин сүүлийн 5-ыг сугалж авахын тулд:

1) linelist -ыг `hospital` баганын дугуу бүлэглэ
2) *Эмнэлэг/бүлэг тус бүр доторх* эмнэлэгт хэвтсэн огноог  хамгийн сүүлчээс хамгийн эртрүү чиглэлтэйгээр эрэмбэл
3) Эмнэлэг тус бүрийн хамгийн эхний 5 мөрийг сугалж гаргаж ирнэ 

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # харуулах
  select(case_id, hospital, date_hospitalisation)  # харуулах
```

`slice_head()` - n мөрийг дээрээс тоолж сонгоно  
`slice_tail()` - n мөрийг доороос тоолж сонгоно 
`slice_sample()` - n мөрийг санамсаргүй байдлаар сонгоно  
`slice_min()` - `order_by = ` баганадах хамгийн их утгатай n мөрийг сонгоно (`with_ties = TRUE`гэж тохируул) 
`slice_max()` - `order_by = ` баганадах хамгийн бага утгатай n мөрийг сонгоно (`with_ties = TRUE`гэж тохируул)   

[De-duplication] хуудаснаас `slice()`-ын талаар тайлбарласныг уншна уу.  




### Бүлгийн том жижигээр нь шүүх {#group_filter_grp_size .unnumbered} 

`add_count()` функц эх хүснэгтэд шинээр `n` гэсэн баганыг нэмдэг. Энэ баганын утга нь датандах мөр болгоны харьяалах бүлгийн хамрах хэмжээг зааж өгсөн байдаг. 

Доор уишээнд `add_count()` функцыг `hospital` багана дээр хэрэглэсэн байна. Тиймээс `n` багана дах утга бол тухайн мөрөнд бичигдсэн эмнэлэгийн бүлэгт ноогдох мөрний тоо юм. Тиймээс `n` баганын утгууд олон давтагдсан байна. Баганын нэр `n` -ийг  `add_count()`-ын `name = `аргументээр өөрчилж болно. Харуулахад ойлгомжтой болгох үүднээс багануудыг `select()`-ээр эрэмбэлсэн.  


```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # "энэ эмнэлэгтэй адилхан эмнэлэгт хэвтсэн мөрийн тоог" нэм 
  select(hospital, n, everything())
```

Ийм багана нэмэхэд жижиг (жишээ нь 500 аас доош хүн хэвтсэн) эмнэлэгт хэвтсэн тохиолдлуудыг шүүж гаргаж ирэхэд амар боллоо.

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```





##Бүлэглэсэн датаг хувиргах  

Бүх багана мөрийг хэвээр нь байхад (нэгтгэхгүй) *бүлгийн статистикийн тооцоо агуулсан шинэ багана* нэмэх бол `summarise()`-ын оронд `mutate()`-ыг `group_by()` угсруулж хэрэглэ.

Ингэснээр эх дата дээрээ бүлгийн статистикийг *бусад баганын хамтаар* харах боложмтой юм. Тухайлбал нэг мөрний утгыг бүлгийн утгатай нь харьцуулж болно. 

Доор жишээ код эмнэлэгт хожуу хэвтэлттэй мөрүүд болон хожуу хэвтэлтийн медиан үзүүлэлтүүдийг харьцуулж ялгааг харуулсан. Үүнийг хийх алхмууд нь: 

1) Датаг эмнэлэг тус бүрээр бүлэглэ  
2) `days_onset_hosp` (эмнэлэгт хожуу хэвтэх) баганыг ашиглан *тухайн мөрөн дэх* эмнэлэгийн хожуу хэвтэлийн дундаж үзүүлэлтийг тооцож бодсон шинэ багана үүсгэ. 
3) Хоёр баганын ялгааг тооц 

Ойлгомжтой байлгахын тулд зөвхөн тодорхой багануудыг `select()` -ээр сонгож харуулав. 

```{r}
linelist %>% 
  # Датаг эмнэлэг тус бүрээр бүлэглэ (linelist -д өөрчлөлт гарахгүй)
  group_by(hospital) %>% 
  
  # Шинэ баганууд
  mutate(
    # Эмнэлэгт хэвтэх хүртэлх өдрийн дундаж (таслалтын ард нэг орон байхаар хураа)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # Тухайн мөрний хожуу хэвтэлт болон яг тэр мөрний эмнэлэгийн хожуу хэвтэлтийн дундаж хоёрын ялгаа (таслалтын ард нэг орон байхаар хураа)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # Ойлгомжтой байлгахын тулд зөвхөн тодорхой багануудыг л сонго
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```



## Бүлэглэсэн дата  

`select()` функц мөн бүлэглэсэн датанд үйлчилдэг. Гэхдээ бүлэг үүссэн багана нь үргэлж сонгогдох болно (`select()` дотор зааж өгөөгүй байсан ч гэсэн). Бүлэг үүссэн баганыг оруулахгүй байхын тулд эхлээд `ungroup()` хийнэ.  










<!-- ======================================================= -->
## Нэмэлт материал {  }

Нэмэлт хэрэгтэй мэдээллүүдийг дараах линкуудээс үзнэ үү:  

Ямар ч нэгтгэж дүгнэсэн функцыг бүлэглэсэн датанд хийж болно; [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf) ээс харна уу.  

[**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html)  
The **tidyverse** reference pages on [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) хуудасны The Data Carpentry хэсэг болон [grouping](https://dplyr.tidyverse.org/articles/grouping.html)  

[Data manipulation](https://itsalocke.com/files/DataManipulationinR.pdf) хуудас

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)  






```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/grouping.Rmd-->

