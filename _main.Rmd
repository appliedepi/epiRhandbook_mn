---
knit: "bookdown::render_book"
title: "Тархвар судлаачийн R гарын авлага"  
description: "Тархвар судлаачийн R гарын авлага нь тархвар судлал, нийгмийн эрүүл мэндэд зориулсан R-ын лавлагаа сурах бичиг юм."
author: "гарын авлагын баг"
date: "`r Sys.Date()`"
#url: 'https://github.com/appliedepi/epiRhandbook_mn'
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
# output: bookdown::gitbook:
#      config:
#           sharing:
#                twitter: yes
#                facebook: yes
#                whatsapp: yes
#                github: yes
documentclass: book
---

# output: bookdown::gitbook:

Placeholder


## R-ыг тархвар судлал, нийгмийн эрүүл мэндэд ашиглах нь {-}  
## Энэхүү гарын авлагыг хэрхэн ашиглах вэ {-} 
## Талархал {-}  
### Оролцогчид {-}  
### Санхүүжилт, дэмжлэг {-}  
### Сэдэл {-}  
## Ашиглалтын нөхцөл ба Лиценз {-}  
### Лиценз {.unnumbered} 
### Ишлэл {.unnumbered}
### Хувь нэмрээ оруулах {.unnumbered}  

<!--chapter:end:index.Rmd-->

# (PART) Энэхүү номны тухай {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_about_book.Rmd-->


# Редакцийн болон техникийн тэмдэглэл

Placeholder


## Арга барил, загвар
### R багцууд {.unnumbered}
### Кодын загвар {.unnumbered}
### Нэр томъёо {.unnumbered}
### Тэмдэглэл {.unnumbered}
## Редакцийн шийдвэр
## Гол өөрчлөлт
## Session мэдээлэл (R, RStudio, багцууд)

<!--chapter:end:new_pages/editorial_style.Rmd-->


# Гарын авлага, өгөгдлийг татаж авах

Placeholder


## Офлайн гарын авлагыг татаж авах
### Татаж авах линкийг ашиглах {.unnumbered}
### Манай R багцыг ашиглах {.unnumbered}
## Дагаж ажиллахын тулд өгөгдлийг татаж авах
### Манай R багцыг ашиглах {.unnumbered}
### Нэг нэгээр нь татаж авах {.unnumbered}
#### Тохиолдлын linelist {.unnumbered}
#### Хумхаагийн тоон өгөгдөл {#data_malaria .unnumbered}
#### Ликерт-хэмжүүртэй өгөгдөл {.unnumbered}
#### Flexdashboard {.unnumbered}
#### Хавьтал мөшгөлт {#хавьтал-мөшгөлт .unnumbered}
#### GIS {.unnumbered}
#### Удмын мод {.unnumbered data-link="Phylogenetic trees"}
#### Стандартчилал {.unnumbered}
#### Цагийн цуврал (time series) ба дэгдэлт илрүүлэлт {#data_outbreak .unnumbered}
#### Асуумж судалгааны (survey) дүн шинжилгээ {#data_survey .unnumbered}
#### Shiny {#data_shiny .unnumbered}

<!--chapter:end:new_pages/data_used.Rmd-->

# (PART) Basics {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_basics.Rmd-->


# R суурь ойлголтууд

Placeholder


## Яагаад R-г ашиглана гэж?
## Гол нэр томъёо
## Сургалтын материалууд {#learning}
### RStudio доторх материалууд {.unnumbered}
### Cheatsheets {.unnumbered}
### Twitter {.unnumbered}
### Үнэгүй онлайн материалууд {.unnumbered}
### Англи хэлээс бусад хэл {.unnumbered}
## Суулгалт
### R болон RStudio {.unnumbered}
### Суулгах шаардлагатай болж магадгүй бусад програм хангамж {.unnumbered}
#### TinyTex {.unnumbered}
#### Pandoc {.unnumbered}
#### RTools {.unnumbered}
#### phantomjs {.unnumbered}
## RStudio {#rstudio}
### RStudio чиг баримжаа {.unnumbered}
### RStudio тохируулгууд {.unnumbered}
### Гарын товчлолууд (Keyboard shortcuts) {.unnumbered}
## Функцууд {#functions}
### Энгийн функцууд {.unnumbered}
### Олон аргументтай функцууд {.unnumbered}
### Функц бичих {.unnumbered data-link="Writing functions"}
## Packages {#packages}
### Install and load {.unnumbered}
#### Your library {.unnumbered}
#### Install from CRAN {.unnumbered}
#### How to install and load {.unnumbered}
### Code syntax {.unnumbered}
### Function help {.unnumbered}
### Update packages {.unnumbered}
### Delete packages {.unnumbered}
### Dependencies {.unnumbered}
### Masked functions {.unnumbered}
### Detach / unload {.unnumbered}
### Install older version {.unnumbered}
### Suggested packages {.unnumbered}
## Scripts {#scripts}
### Commenting {.unnumbered}
### Style {.unnumbered}
### Example Script {.unnumbered}
### R markdown {.unnumbered}
### R notebooks {.unnumbered}
### Shiny {.unnumbered}
### Code folding {.unnumbered}
## Working directory
### Recommended approach {.unnumbered}
### Set by command {.unnumbered}
### Set manually {.unnumbered}
### Within an R project {.unnumbered}
### Working directory in an R markdown {.unnumbered}
### Providing file paths {.unnumbered}
## Objects {#objects}
### Everything is an object {.unnumbered}
### Defining objects (`<-`) {.unnumbered}
### Object structure {.unnumbered}
### Object classes {.unnumbered}
### Columns/Variables (`$`) {.unnumbered}
### Access/index with brackets (`[ ]`) {.unnumbered}
### Remove objects {.unnumbered}
## Piping (`%>%`)
### **Pipes** {.unnumbered}
### Define intermediate objects {.unnumbered}
## Key operators and functions {#operators}
### Assignment operators {.unnumbered}
### Relational and logical operators {.unnumbered}
### Missing values {.unnumbered}
### Mathematics and statistics {.unnumbered}
#### Mathematical operators {.unnumbered}
#### Mathematical functions {.unnumbered}
#### Scientific notation {.unnumbered}
#### Rounding {.unnumbered}
#### Statistical functions {.unnumbered}
#### Other useful functions {.unnumbered}
### `%in%` {.unnumbered}
## Errors & warnings
### Error versus Warning {.unnumbered}
### General syntax tips {.unnumbered}
### Code assists {.unnumbered}

<!--chapter:end:new_pages/basics.Rmd-->


# Transition to R { }  

Placeholder


## From Excel  
### Benefits {.unnumbered}  
### Tidy data {.unnumbered}  
### Functions {.unnumbered}  
### Scripts {.unnumbered}  
### Excel-to-R resources {.unnumbered}
### R-Excel interaction {.unnumbered}  
## From Stata  
## From SAS  
## Data interoperability  

<!--chapter:end:new_pages/transition_to_R.Rmd-->


# Санал болгох багцууд

Placeholder


## CRAN -ын багцууд
## Github-ын багцууд

<!--chapter:end:new_pages/packages_suggested.Rmd-->


# R төсөл {}  

Placeholder


## Санал болгож буй хэрэглээ
## R төсөл үүсгэх {}
### Төслүүдийг сэлгэх {.unnumbered}
### Тохируулга {.unnumbered}  
### Бүтэц {.unnumbered}  
### Хувилбаруудыг хянах {.unnumbered}  
## Жишээ  

<!--chapter:end:new_pages/r_projects.Rmd-->


# Файл зөөж оруулах болон гаргах

Placeholder


## Ерөнхий
## rio багц
## **here** багц {#here}
## Файлын байршил
### Файлын "харьцангуй (relative)" байршил {.unnumbered}
### Файлын "үнэмлэхүй" байршил {.unnumbered}
### Гар аргаар байршлыг сонгох {.unnumbered}
## Дата импортлох
### Specific Excel sheets {.unnumbered}
### Missing values {#import_missing .unnumbered}
### Skip rows {.unnumbered}
### Manage a second header row {.unnumbered}
#### Remove the second header row {.unnumbered}
#### Make a data dictionary {.unnumbered}
#### Combine the two header rows {.unnumbered}
### Google sheets {.unnumbered}
## Multiple files - import, export, split, combine
## Import from Github {#import_github}
### CSV files {.unnumbered}
### XLSX files {.unnumbered}
### Shapefiles {.unnumbered}
## Manual data entry
### Entry by rows {.unnumbered}
### Entry by columns {.unnumbered}
### Pasting from clipboard {.unnumbered}
## Import most recent file
### Dates in file name {.unnumbered}
### Use the file info {.unnumbered}
## APIs {#import_api}
### HTTP request {.unnumbered}
### Packages {.unnumbered}
### Publicly-available data {.unnumbered}
### Authentication required {.unnumbered}
## Export
### With **rio** package {.unnumbered}
### To clipboard {.unnumbered}
## RDS files {#import_rds}
## Rdata files and lists {#import_rdata}
## Saving plots
## Resources

<!--chapter:end:new_pages/importing.Rmd-->

# (PART) Data Management {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_management.Rmd-->

# Дата цэвэрлэгээ ба үндсэн функцууд

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Энэ бүлэгт датаг "цэвэрлэхэд" хэрэглэгддэг нийтлэг аргууд болон R-ын дата менежментийн үндсэн функцуудыг сурах болно.

Дата цэвэрлэгээ хийх алхам бүрийг "raw" (түүхий) дата (linelist) импортлохоос авахуулаад хийгдэх үйлдэл бүрийг нэг бүрчлэн тайлбарлах болно. R- дата цэвэрлэгээ "pipe" (хоолой) холбоосоор дамжин хийгддэг бөгөөд "pipe" `%>%` буюу холбогч оператор дамжуулах үйлдлийг гүйцэтгэдэг.

### Үндсэн функцууд {.unnumbered}

Энэхүү номонд [**tidyverse**](https://www.tidyverse.org/) -ын харъяа багцууд, тэдний функцуудыг голчлон тайлбарлна. Гол хэрэглэгдэх функцуудыг дор жагсаав.

**tidyverse** багцын нэг [**dplyr**](https://dplyr.tidyverse.org/) багцын дата засаж, янзалдаг "үйл үгэн" функцууд түлхүү орсон (**dplyr** багцын нэр "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)(хүснэгтийг%20засах)%22%20гэсэн%20утгатай) буюу "хүснэгт засагч" гэсэн утгатай).( **tidyverse** --ын бусад багцуудад **ggplot2**,**tidyr**,**stringr**,**tibble**,**purrr**,**magrittr**,**forcats** ордог).

+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| Function                                            | Utility                                                             | Package                       |
+=====================================================+=====================================================================+===============================+
| `%>%`                                               | "pipe" (хоолой) нь датаг нэг функцээс нөгөөд дамжуулна              |     | **magrittr**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `mutate()`                                          | Баганыг үүсгэж, хувиргаж, өөрчилдөг \| \*\*dp                       | lyr\*\*                       |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `select()`                                          | Баганыг үлдээж, арилгаж, шинээр нэр өгдөг                           | \| **dplyr**                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rename()`                                          | Баганыг шинээр нэрлэдэг                                             |       | **dplyr**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_names()`                                     | Баганын нэрсийг жигд болгодог \| \*\*janit                          | or\*\*                        |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | Баганадах дата төрлийг өөрчилнө. \| \| \*                           | \*base\*\* R                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `across()`                                          | Олон баганыг зэрэг хувиргана \| **dplyr**                           |                               |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| **tidyselect** functions                            | Баганыг сонгохдоо logic ашиглана \|                                 | \| **tidyselect**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `filter()`                                          | Тодорхой мөрүүдийг авч үлдэх                                        |          | **dplyr**          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `distinct()`                                        | Мөрүүдийг давхардалтыг арилгах                                      |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rowwise()`                                         | Мөр дагуу үйлдэл хийх \| \*\*dplyr                                  | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `add_row()`                                         | Мөрийг гараар нэмэх \| \|                                           | **tibble**                    |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `arrange()`                                         | Мөрийг эрэмбэлэх                                                    |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `recode()`                                          | Баганадах утгыг дахин өгөх \|                                       | **dplyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `case_when()`                                       | Баганад илүү нарийвчилсэн логик шалгуураар утга оруулна\| \*\*dplyr | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | Баганад утга өгөх тусгай функцууд                                   | **tidyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `age_categories()` and `cut()`                      | Тоон утгатай баганаас ангилал үүсгэ \| \* \| \*epikit               | **and** base\*\* R            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_variable_spelling()`                         | Датаны тайлбар толийг ашиглан баганын утгыг өөрчлөх, арилг          | ах \| **linelist**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `which()`                                           | Логик шалгуур ашиглах; Индексийг харуулах (return indices)          |                  | **base** R |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+

Эдгээр функцууд Stata болон SAS программ дээр хэрхэн бичигддэг талаар [Transition to R] -линкээс үзэж болно.

Датаг янзалж байхад R-ын **data.table** багцын операторууд болох `:=`,`[ ]` гарч ирж болно. **data.table** багцын хэрэглэгддэг синтакс, аргачлалыг [Data Table] хуудаст товч оруулсан.

### Нэр томьёо {.unnumbered}

Энэхүү номонд хувьсагч (variable) -ийг багана, ажиглалт (observations) -ийг мөр гэж нэрших болно. Тархвар судлалын ихэнх датаг гол бүрдүүлдэг зүйлс бол багана, мөр, доторх утга гэж ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) -д тайлбарласан байдаг.

*Variables* (Хувьсагч) нь ижил хэв шинжтэй утгуудыг агуулсан байдаг (насны бүлэг, өвчин эхэлсэн огноо, эмчилгээний үр дүн гэх мэт). *Observations* (Ажиглалт) гэж тухайн нэгжид хийгдсэн бүх хэмжилтүүдийг хэлнэ (хүн, газар, лабораторийн дээж материал). Эдгээр шинж талуудыг бодитоор, барьцтай илэрхийлэх нь бэрхшээлтэй.

"Tidy" (цэгцтэй) датанд багана болгон хувьсагч, мөр болгон ажиглалт, нэг нүд болгон нэг утгыг зааж байдаг. Цэгцтэй загварт хэлбэржээгүй дата зарим тохиолдол бий. Тухайлбал "wide"(өргөн) дата гэхэд хувьсагч нь хэд хэдэн баганад хуваагдан байрладаг. Үүний жишээг [Pivoting data]-т хэсэгт харуулсан. Ажиглалт ч гэсэн хэд хэдэн мөрөнд хуваагдан байрласан байх тохиолдол бий.

Энэ номонд бид датаг хэрхэн хувиргаж, янзлаж, менежмент хийд талаар харуулахыг илүү эрмэлзсэн. Тийм ч учраас хувьсагч, ажиглалт зэрэг хийсвэр ойлголт хэрэглэхийн оронд мөр, багана зэрэг бодитой бүтэц заасан нэршилийг хэрэглэхээр шийдсэн. Харин статистик дүн шинжилгээний талаар тайлбарласан хэсгүүдэд хувьсагч, ажиглалт гэсэн нэршил илүү хэрэглэгдсэн.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Цэвэрлэх холбоос

**Энэ хэсэгт дата цэвэрлэгээг үе шат тус бүрээр нь тайлбарласан. Цэвэрлэгээний явцыг "pipe" цэвэрлэх холбоост нэг бүрчлэн залгаж үзүүлсэн.**

Тархвар судлалд датаг янзлах, цэвэрлэх нь хоорондоо холбоотой дараалласан үйлдлүүдээс бүрддэг. R программ дээр цэвэрлэгээг хийхдээ мөн адил *датаг нэг цэвэрлэх шатнаас нөгөөд угсруулан үйлддэг.*

Ийм угсруулсан үйлдлүүдийг **dplyr** -ын "үйл үгт" функцуууд болон **magrittr**-ын pipe`%>%` холбогч оператор хамтран гүйцэтгэдэг. Цэвэрлэгээ түүхий датагаар ("linelist_raw.xlsx") эхлээд R -ын "цэвэрхэн" хүснэгт (`linelist`) болж гардаг. Үүнийг шууд ашиглаж, хадгалж, экспортлож болно.

Цэвэрлэгээ хийж байхад үйлдлийн дараалал чухал. Нийтлэг хийгддэг үйлдлийн дараалалд:

-   Датаг оруулж ирэх\
-   Баганын нэрсийг өөрчлөх, арилгах\
-   Давхардсан утгуудыг арилгах\
-   Багана нэмж, хувиргах (утгыг дахин кодлох, стандардчилах гэх мэт)\
-   Мөрүүдийг шүүж, хасаж, нэмэх

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багцуудыг ачааллах

Дараах кодыг уншуулж шаардлагатай багцуудыг ачааллана. Энэ номонд багцыг ачааллахад **pacman** -ны `p_load()`-ыг голчлон хэрэглэнэ. Учир нь энэ функц шаардлагатай багцыг автоматаар татаж авч, ачааллаад ажиллахад бэлэн болгодог. **base** R-ын багцыг `library()`-аар та өөрөө шууд (татаж авалгүйгээр ) ачааллаж бас болно. [R basics] хэсгээс энэ талаар нэмж үзнэ үү.

```{r, message = F}
pacman::p_load(
  rio,        # дата оруулах  
  here,       # файлын холбоотой замыг тогтоох 
  janitor,    # дата, хүснэгт цэвэрлэх
  lubridate,  # огноотой ажиллах
  epikit,     # age_categories() функц
  tidyverse   # дата менежмент ба график зураглал
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Датаг импортлох

### Импорт хийх {.unnumbered}

Түүхий дата агуулсан Excel файлыг **rio**-ын `import()` функцээр импортлоно. **rio** нь файлын олон янзын төрөлтэй ажиллаж чаддагаараа давуу (.xlsx, .csv, .tsv, .rds. гэх мэт). [Import and export] хэсгээс дэлгэрүүлж үзнэ үү.

Энэ бүлгийн дасгалыг хамт хийх бол датаг дараах линкээс татаж авна уу. <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>линк дээр дарж "түүхий" linelist -ыг татаж ав</a> ( .xlsx файл).

Хэмжээ том датасетийн хувьд импортлоход хугацаа их шаарддаг учраас импорт хийх коммандаа pipe залгааснаас салангид уншуулж, түүхий датагаа тусдаа файлаар хадгалах нь тохиромжтой. Ингэснээр мөн анхны болон цэвэрлэгдсэн дата хувилбаруудыг харьцуулахад хялбар болдог.

Дорх жишээнд бид Excel-ийн түүхий файлыг импортлоод `linelist_raw` гэсэн хүснэгт болгож хадгаллаа.Энэхүү файлыг та өөрийн ажлын хавтас эсвэл R төслийн үндсэн хавтастаа байрлуулна гэж тооцсон учир файлын замыг бичихэд дэд хавтсыг оруулсангүй.

```{r, echo=F, message=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# here()-ийг ашиглаж датаг ачааллана
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Үүссэн хүснэгтийн эхний 50 мөрийг дараахаас харж болно. Тэмдэглэл: **base** R"-ын `head(n)` функцээр эхний `n` мөрийг R console дээр шууд харж болдог.

```{r message=FALSE, echo=F}
# linelist датаг хүснэгт хэлбэрээр харуул
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Тоймлон үзэх {.unnumbered}

Дата хүснэгтийн талаарх ерөнхий тойм мэдээг авахдаа **skimr** -ын `skim()` функцыг хэрэглэж болно. ([Descriptive tables] хэсгээс нэмж харна уу). Баганууд numeric (тоон), character (үсгэн) зэргээр төрөл төрлөөрөө тоймлогддог. Тэмдэглэл: "POSIXct" гэдэг нь нэг төрлийн боловсруулагдаагүй огноо датаны төрөл ([Working with dates] хэсгээс харна уу).

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганын нэрс

Хүснэгт импортлоход хамгийн эхний, толгой мөрийг баганын *нэр* гэж R уншдаг. Синтакст мөн энэ нэр хэрэгдэгднэ.

SAS, STATA зэрэг бусад статистик программд баганын толгой дох товчилсон нэрнээс гадна *"labels" (дэлгэрэнгүй нэр)* гэж байдаг. R дээр багана тус бүрт label өгөх боломжтой ч өргөн хэрэглэдэггүй. График дээр баганын нэрийг хэвлэлд үзэмжтэй харагдахуйцаар болгоход график хэвлэх комманддаа дэлгэцийн тохируулгад нь зааж өгч болно (тэнхлэгийн (axis) нэрс, ялгах тэмдгийн (legends), нэрс, багана толгой гэх мэт. [scales section of the ggplot tips page](https://epirhandbook.com/ggplot-tips.html#ggplot_tips_scales) болон [Tables for presentation](https://epirhandbook.com/tables-for-presentation.html#tables-for-presentation) хуудсаас нэмж уншна уу). Баганад label өгөх талаар [here](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) болон [here](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) линкүүдээс үзэж болно.

Баганын нэрс R дээр байнга хэрэглэгдэх тул "цэвэр" синтакстай байх нь чухал. Дараах аргаар нэрлэвэл тохиромжтой:

-   Богино
-   Зай авахгүй, доогуур зураас \_ хэрэглэх
-   Өвөрмөц тэмдэглэгээ оруулахгүй (&, \#, \<, \>, ...)
-   Төстэй нэрлэх ( жишээ нь бүх огноотой баганыг **date\_**onset, **date\_**report, **date\_**death гэж нэрлэх)

**base** R --ын `names()` функцээр `linelist_raw`--дах баганын нэрсийг хэвлэж харахад:

-   Зарим нэрс зай авсан (жишээ нь `infection date`)\
-   Огноотой баганууд жигд бус нэрлэгдсэн (жишээ нь `date onset` багана `infection date` ээс өөр)\
-   .xlsx файл дээр нь сүүлийн хоёр баганын толгой нэгтгэгдсэн (merged) байсан нь харагдаж байна. Учир нь нэгтгэгдсэн баганын эхний баганын нэр R -т "merged_header" гэж импортлогдоод хоёр дах баганын нэр "...28" гэж импортлогдсон байна ( хоосон 28 -р багана байсан).

```{r}
names(linelist_raw)
```

[***ТЭМДЭГЛЭЛ:*** зай авсан баганы нэрийг хойшоо харсан дан хашилтад хийдэг. Жишээ нь: linelist\$`` ` '\x60infection date\x60'` ``. Ингэхдээ компьютерийн гаран дээрх хойшоо харсан дан хашилт (\`) бичгийн дан хашилтаас ( ' ) өөр гэдгйиг анхаарна уу.]{style="color: black;"}

### Автомат цэвэрлэгээ {.unnumbered}

**janitor** багцын `clean_names()` функц баганын нэрсийн өвөрмөц байдлыг алдуулалгүйгээр жигдрүүлдэг. Ингэхдээ:

-   Бүх баганыг зөвхөн доогуур зураас, тоо, үсгээс бүрдсэн нэртэй болгож хувиргана.\
-   Өргөгдсөн эгшгүүд ASCII хэлрүү галиглагдна (Герман хэлний ö --г "o"-руу, Испани хэлний "enye" -г "n" болгох гэх мэт)\
-   Үсгийн том жижгийг `case =` аргументэд зааж өгч болно ("snake" хэлбэр default сонголт, "sentence", "title", "small_camel" гэх мэт өөр сонголтууд буй)\
-   Нэр өөрчлөх, орлуулахдаа `replace =` аргументийг ашиглаж болно (ж: `replace = c(onset = "date_of_onset")`)\
-   Онлайн [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) --г эндээс харж болно

Цэвэрлэх процесс `clean_names()` -эд түүхий linelist --ийг оруулснаар эхэлнэ:

```{r clean_names}
# түүхий датагаа clean_names() –д холбоод, үр дүнг нь "linelist" -доноо
linelist <- linelist_raw %>% 
  janitor::clean_names()

# баганын шинэ нэрс
names(linelist)
```

[***ТЭМДЭГЛЭЛ:*** сүүлийн баганын нэр "...28" байснаа "x28" болж хувирсан".]{style="color: black;"}

### Баганын нэрийг гараар цэвэрлэх {.unnumbered}

Баганын нэрсийг дээрх байдлаар жигдрүүлсний дараа гараар цэвэрлэх хэрэг заавал гардаг. Дорх кодонд **dplyr** --ын `rename()` -ыг pipe холбоост залгаж зарим баганын нэрийг янзалсан. `rename()` функц `NEW = OLD`-- гэсэн дарааллаар аргументээ авдаг. Эхлээд шинэ, дараа нь хуучин нэрийг бичнэ.

Дараах цэвэрлэгээний процесст нэр өгөх комманд нэмэгдэж орсныг ажиглаарай. Уншихад амар болгож зарим газар зай авсан.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
    
```

Баганын нэрс өөрчлөгдсөн байна:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Баганын байрлалаар нь нэр өгөх {.unnumbered}

Баганыг нэрийг солихдоо нэрээр нь дуудахаас гадна байрлалыг нь дуудаж болдог. Жишээ нь:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()`болон `summarise()` ашиглан нэр өгөх {.unnumbered}

Нэр өгөхдөө **dplyr** -ын `select()`болон `summarise()` функцуудыг хавсран ашиглавал арай түргэн. `select()`--ээр ажиллах гэж буй багануудаа сонгож авахад хэрэглэдэг (дараагийн хэсгүүдэд дахин дурьдна).`summarise()`--ын талаар [Grouping data] болон [Descriptive tables] хэсгүүдэд тайлбарласан. Эдгээр функц мөн адил `new_name = old_name` гэсэн дарааллаар аргументээ авна. Жишээ:

```{r, eval=F}
linelist_raw %>% 
  select(# ШИНЭ нэр              # ХУУЧИН нэр
         date_infection       = `infection date`, # нэрийг солиод, ЗӨВХӨН тухайн багануудыг л авч үлднэ
         date_hospitalisation = `hosp date`)
```

### Бусад {.unnumbered}

#### Excel дээрх баганын нэр хоосон байх {.unnumbered}

R-т баганын нэргүй дата байх боломжгүй. Тухайлбал Excel --ийн хүснэгт хоосон толгойтой баганатай R --луу импортлогдвол баганын байрлалаас нь хамаарч R автоматаар "...1", "...2" гэх мэтээр нэр өгдөг (жишээ нь хүснэгтийн 4 дэх багана нэргүй хоосон орж ирсэн бол R тэр баганыг "...4" гэж нэрлэнэ).

Энэ автоматаар өгөгдсөн нэрсийг байрлалынх нь дугаараар (дээр дурьдсан жишээний дагуу), эсвэл оноосон нэрээр нь дуудаж гараар цэвэрлэх боломжтой (`linelist_raw$...1`.

#### Excel багана, нүднүүд нэтгэгдсэн (merged) байх {.unnumbered}

Заримдаа Excel --ийн файл ыг хүлээж аваад харахад хүснэгтийн нүднүүд нэтгэгдсэн (merged) байдаг. Нэгтгэгдсэн нүдтэй хүснэгт хүн уншихад амар боловч, "цэгцтэй дата/tidy data" хэлбэрт ороогүй учраас компьютерт сайн уншигддаггүй ([Transition to R] хэсэгт тайлбарласан). R --дээр нэгтгэгдсэн нүднүүд уншигдахгүй.

Дата оруулж буй хүмүүстээ **хүнд уншигддаг дата машинд уншигддаг дата хоёр өөр** гэдгийг сайн ойлгуулах хэрэгтэй. Цэгцтэй датаны [**tidy data**](https://r4ds.had.co.nz/tidy-data.html) зарчмыг ойлгуулахыг мөн эрмэлз. Болж өгвөл дата оруулах аргачлалд нь өөрчлөлт хийж аль болох цэгцэрсэн, ямар нэг нэгтгэсэн нүдгүй дата хүлээж авахаар зохицуулбал сайн.

-   Хувьсагч тус бүр баганатай байна.\
-   Ажиглалт тус бүр мөртэй байна\
-   Утга тус бүр өөрийн нүдэнд байна.

**rio-ын** `import()` -ээр дата импортлож байхад нэтгэгдсэн нүд датанд байх тохиолдолд тухайн нүд задарч, доторх утга эхний нүдэнд бичигдээд дараах нүднүүд нь хоосон орхигддог.

Нэтгэгдсэн нүдний асуудлыг **openxlsx** багцын `readWorkbook()`функцээр шийдвэрлэх боломжтой. Үүний `fillMergedCells =` аргументийг TRUE гэж тохируулбал нэтгэгдсэн нүднүүд задрахад доторх утга бүгдэд нь зэрэг хуваарилагдан ордог онцлогтой.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***АЮУЛТАЙ:*** `readWorkbook()` -өөр баганын нэрс нэгтгэгдсэн бол давхардсан нэртэй багануудтай болчихдог. Үүнийг гараар цэвэрлэх шаардлагатай. R давхардсан нэртэй ажиллахдаа муу! Давхар нэртэй багануудын нэрийг байршлаар нь дуудаж янзалж болно (баганын нэрийг гараар цэвэрлэх хэсэгт тайлбарласан)]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана сонгох болон эрэмбэлэх

**dplyr**-ын `select()` --д баганыг дуудаж оруулахдаа дэс дарааг нь зааж өгч болно.

[***БОЛГООМЖЛОЛ:*** `linelist`- датаг `select()` --ээр янзалсан байгааг жишээ болгож харуулсан боловч хадгалаагүй. Pipe холбоостоо `names()-ыг` залгаснаар баганы нэр хэрхэн өөрчлөгдсөнийг харж болно.]{style="color: orange;"}

Цэвэрлэх холбоосонд [linelist --ын БҮХ нэрс цэвэрлэгдсэн байх үеийг энд харуулав]{style="color: orange;"}:

```{r}
names(linelist)
```

### Баганыг үлдээх {.unnumbered}

**Зөвхөн үлдээх шаардлагатай багануудаа л сонго.**

Шаардлагатай багануудаа `select()`коммандад хашилтгүйгээр оруул. Таны оруулсан дарааллаар хүснэгтийн багана эрэмбэлэгднэ. Байхгүй баганыг `select()`--д бичвэл R алдаа заана. (алдаа заахгүйгээр үргэлжлүүлэх талаар `any_of()`--ын тайлбараас үзнэ үү).

```{r}
# linelist датаг select() коммандаар цэвэрлээд names() -ээр баганын нэрсийг хэвлэсэн
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # баганын нэрсийг хэвлэж харуулах
```

### "tidyselect" туслах функцууд {#clean_tidyselect .unnumbered}

Багана үлдээх, хасах, хувиргах үйлдэл хийхдээ туслах функц ашиглавал хялбар болдог. Эдгээр туслах функцууд **tidyverse**-ын харьяа **tidyselect** багцыннх ба **dplyr** -ын багана сонгох үйлдэлтэй хавсарч хийгддэг.

Жишээ нь `everything()` функцээр "бичигдсэнээс бусад баганыг" сонгодог бөгөөд ингэх нь баганын дарааллыг өөрчлөхөд их хэрэгтэй. Дараах код `date_onset` болон `date_hospitalisation` багануудыг хамгийн эхэнд (зүүн талд) авчраад, үлдсэн багануудыг ард нь хэвээр нь үлдээсэн. `everything()` комманд хоосон хаалттай байгааг анхаар:

```{r}
# date_onset болон date_hospitalisation -г хамгийн урд зөөж авчрах
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

**dplyr** багцын `select()`, `across()`, `summarise()` нартай хамтран хэрэглэддэг **tidyselect** -ын функцуудыг дор жагсаав :

-   `everything()` - бичсэнээс бусад бүх багануудыг сонгоно\

-   `last_col()` - сүүлийн багана\

-   `where()` - аливаа функцыг бүх баганад уншуулж үзээд, TRUE тохиодлуудыг сонгоно\

-   `contains()` - заасан үсэг, тэмдэгт (character) агуулсан баганыг сонгох

    -   жишээ: `select(contains("time"))`\

-   `starts_with()` - баганын нэрийн эхлэл хэсгийг тааруулж сонгох

    -   жишээ: `select(starts_with("date_"))`\

-   `ends_with()` - баганын нэрийн төгсгөл хэсгийг тааруулж сонгох

    -   жишээ: `select(ends_with("_post"))`\

-   `matches()` -заасан regular expression (regex) тэй таарсан баганыг сонгох

    -   жишээ: `select(matches("[pt]al"))`\

-   `num_range()` - x01, x02, x03 зэрэг тоо, дугаараар тааруулж сонгох\

-   `any_of()` - аль нэг багана байхгүй тохиолдолд алдаа заахгүйгээр үйлдлийг гүйцэтгэнэ.

    -   жишээ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Үүнээс гадна ердийн операторуудыг ашиглаж болно. Жишээ нь `c()`-аар хэд хэдэн баганыг жагсааж, `:` тэмдэгтээр дарааллаж байрласан багануудыг сонгож болно. `!` (эсрэг),`&` (БА), `|` (ЭСВЭЛ) зэрэг тэмдэгтүүдээр багана сонгохдоо туслуулж болно.

Баганыг логик шалгуураар сонгох бол `where()`-ийг хэрэглэ. Хэрэв `where()`-ийг функцын дотор бичихээр бол хаалтыг нь хоосон байлгаж болохгүй. Дорх жишээнд зөвхөн тоон утгатай баганууд сонгохыг харууллаа.

```{r}
# Тоон утгатай багануудыг сонгох
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Нэрэндээ зөвхөн заасан character -ыг агуулагсан багануудыг сонгох бол `contains()` -ыг хэрэглэ. Мөн`ends_with()` болон `starts_with()` strings -ын байрлалыг илүү тодорхой зааж өгч болно.

```{r}
# тодорхой үг, үсэг нэрэндээ агуулсан багануудыг сонгох
linelist %>% 
  select(contains("date")) %>% 
  names()
```

`matches()` функц `contains()` -тай төстэй үүрэгтэй боловч regular expression ашигладгаараа онцлог ([Characters and strings]) хэсгээс нэмж харна уу. Энэ функцыг хэрэглэхдээ олон strings -үүдээ (ЭСВЭЛ) хооронд нь босоо зураасаар тусгаарлаад хашилтанд хийнэ :

```{r}
# олон strings-ийг эрэг хайж, тааруулах
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***БОЛГООМЖИЛ:*** Датанд байхгүй баганын нэрийг эдгээр функцэд өгвөл код алдаа зааж үйлдэл тэр дороо зогсчихдог. Тиймээс заасан strings байхгүй байх магадлалтай тохиолдолд `any_of()` -ийг хэрэглэвэл тохиромжтой. Ялангуяа багана хасахад их хэрэг болдог.]{style="color: orange;"}

Дор жишээнд бичсэн багануудын нэг нь л датанд буй боловч дорх код алдаа заахгүйгүээр үргэлжилж, цэвэрлэх холбоосын йлдлүүд зогсолтгүйгээр гүйцэтгэлээ хийж байна.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Баганыг хасах {.unnumbered}

Хасах ("-") тэмдэг (ж:`select(-outcome)`) эсвэл баганын нэрс жагсаасан вектороор (дор жишээнд үзүүлсэн) **аль баганыг хасахаа зааж өг**. Бусад баганууд хэвээр үлдэх болно.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # date_onset багана, fever-ээс vomit хүртэлх багануудыг хасах
  names()
```

**base** R -ын синтакс `NULL`-ыг ашиглаж баганыг хасч бас болно. Жишээ нь:

```{r, eval=F}
linelist$date_onset <- NULL   # base R -ын синтаксаар date_onset баганыг хасах
```

### Дангаараа үйлдэх коммандууд {.unnumbered}

`select()` -ийг дангаар нь хэрэглэж болдог (pipe холбоостой залгаа биш). Энэ тохиолдолд эхний аргумент нь янзлах гэж буй хүснэгтийн нэр байна.

```{r}
#  id болон насыг харуулсан шинэ linelist үүсгэх
linelist_age <- select(linelist, case_id, contains("age"))

# үүсгэсэн linelist-ийн баганын нэрсийг харуул
names(linelist_age)
```

#### Pipe холбоосонд нэмж залгах {.unnumbered}

`linelist_raw`-хүснэгт дэх дараах баганууд бидэнд шаардлагагүй: `row_num`, `merged_header`, `x28`. Эдгээрийг хасахдаа `select()` коммандыг pipe холбоосонд залгаж хасдаг:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################

    # баганыг хас
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Давхардалтыг арилгах

Энэхүү номын [De-duplication] хэсгээс давхардалтыг арилгах нэмэлт аргатай танилцаж болно. Энэ хэсэгт бид зөвхөн мөрний энгийн давхардалтыг арилгахыг харуулна.

**dplyr** багц `distinct()` гэсэн функцтэй. Энэ функц датан дах бүх мөрний давхардалтыг шалгасны дараа датаг зөвхөн өвөрмөц мөртэй болгож хувиргадаг. Энэ үйлдлээр зөвхөн 100% адилхан мөрүүдийн давхардалт арилдаг.

Давхардсан мөрийг хайхдаа мөрүүдийг хэсэгчилэн шалгаж болно (default аар бүх мөрийг зэрэг шалгана). Хэдий хэмжээний мөрүүдэд хайгуул хийхээ өөрөө тохируулж болно (давхардалтыг арилгах хэсэгт мөн тайлбарласан). Энэ тохиолдолд зөвхөн тухайн хайлт хийсэн хэсэгт л өвөрмөц мөртэй болдог.

Жишээнд хоосон `distinct()` цэвэрлэх холбоосонд залгасан байна. Ингэснээр 100% ижилхэн мөрүүдийн давхардал датанаас цэвэрлэгдсэн гэсэн үг (бүх мөр зэрэг шалгагдсан).

Жишээнд `linelist` -ийн мөрний тоо `nrow(linelist)` -оор эхэлж байна.

```{r}
linelist <- linelist %>% 
  distinct()
```

Давхардалтыг арилгасны дараа үлдсэн мөрийн тоог `nrow(linelist)` -ээр уншуулж шалгана. Хэрэв мөрийн тоо багассан бол 100% ижил давхардсан мөрнүүд арилсан гэсэн үг.

Pipe холбоосондоо `distinct()` -ийг залгаж өгөв:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################
    
    # давхардлыг арилгах
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана үүсгэх ба хувиргах

**Шинэ багана нэмэх эсвэл багана хувиргахдаа dplyr-ын `mutate()` функцыг ашиглахыг зөвлөж байна.**

Дараах жишээнд `mutate()`-аар хэрхэн шинэ багана нэмэхийг харуулав. Синтакс нь: `mutate(new_column_name = value or transformation)`

R-ын `mutate()` Stata-ын `generate`коммандтай төстэй боловч хуучин баганыг хувиргадаж болдгоороо онцлог.

### Шинэ багана {.unnumbered}

`mutate()` -ээр шинэ багана үүсгэх энгийн жишээг дор харуулав. Бүх мөрөндөө 10 гэсэн утгатай `new_col` хэмээх багана нэмж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Өөр баганын утгыг оролцуулан тооцоолол хийж бас болно. Дор жишээнд `ht_cm`, `wt_kg` гэсэн хуучин хоёр баганы утгыг оролцуулан тооцоолол хийж `bmi` (Биеийн Жингийн Индекс-БЖИ) -гэсэн шинэ багана үүсгэв (БЖИ = кг/жин\^2) .

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Олон багана зэрэг шинээр үүсгэх бол багана тус бүрийг таслалаар тусгаарлаж шинэ мөрөнд бичнэ. Үүнийг дор жишээгээр харуулав. Хуучин баганыг нэтгэхдээ **stringr** -ын `str_glue()`-эийг бас ашиглаж болдог. ([Characters and strings] -аас харж болно.

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # шинэ багана = хуучин баганыг хувилах
    new_var_static = 7,                   # шинэ багана = бүх утга ижилхэн
    new_var_static = new_var_static + 5,  # хуучин багана дээр шинэ багана үүсгэж болох ба ингэхдээ өөр баганын утгыг оролцуулан тооцоолол хийж болно. 
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") #  бусад баганын утгыг хооронд нь нийлүүлж (paste) шинэ баганаү үсгэж болно.
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # жишээ үзүүлэх зорилгоор зөвхөн шинэ багануудыг харуулсан
```

Үүссэн шинэ багануудыг шалга. Жишээ болгож шинээр үүссэн багана, эдгээрий үүсгэхэд оролцсон хуучин багануудыг дор хэвлэлээ :

```{r message=FALSE, echo=F}
# linelist датаг хүснэгтээр харуулав
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ЗӨВЛӨГӨӨ:*** `mutate()` -ын өөр нэгэн хувилбар нь `transmute()` юм. Энэ функц `mutate()` шиг шинэ багана нэмэхээс гадна функц дотор бичигдээгүй бүх баганыг хасдаг.]{style="color: darkgreen;"}

```{r, eval=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# дээр үүсгэсэн баганыг хасна
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Багана дах дата төрлийг хувиргах {.unnumbered}

Огноо, тоо, логик (TRUE/FALSE) утгатай баганын дата төрлийг зөв тодорхойлж оруулбал цаашид ажиллахад хялбар байдаг. Жишээ нь хашилттай "2" character гэж уншигддаг бол хашилтгүй 2 -ыг тоо гэж уншина!

Импорт хийж байхдаа баганын дата төрлийг тохируулж болдог ч олон үйлдэлтэй. [R Basics] хэсэгт обьектийн дата төрөл, үүнийг хэрхэн хувиргах талаар дэлгэрүүлж уншиж болно.

Дараах кодоор багануудын төрөл зөв танигдсан эсэхийг шалгана. Мөн `skim()` -ээр багана дах дата төрлийг харж болно.

Энд харуулснаар `age` баганын дата төрөл character байна. Энэ багананд математик тооцоолол хийхийн тулд дата төрөл нь тоо байх шаардлагатай!

```{r}
class(linelist$age)
```

`date_onset` баганын төрөл нь мөн character байна! Анализ хийхийн тулд эдгээр багана огноо гэж танигдсан байх шаардлагатай!

```{r}
class(linelist$date_onset)
```

Эдгээр тохиолдолд `mutate()`-аар баганыг дахин тодорхойлж зөв төрөлд нь хувиргаж болно. Ингэхэд багана дах утга өөрчлөгдөхгүй зөвхөн дата төрөл өөрчлөгддөг. Дорх жишээнд `age` баганын дата төрлийг тоо болгож хувиргаж байна:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Мөн `as.character()`, `as.logical()` функцуудыг дээрхийн адил хэрэглэж болно. Factor төрөлрүү хувиргахдаа **base** R -ын `factor()` эсвэл **forcats**-ын `as_factor()`-г хэрэглэдэг. Энэ талаар [Factors] хэсгээс нэмж уншна уу.

Огноог болгоомжтой хувиргах шаардлагатай. [Working with dates] хэсэгт хэд хэдэн аргуудыг дурьдсан. Түүхий дата дах огноонууд бүгд ижилхэн форматтай байвал цаашид Date төрөлд хувиргахад хялбар ( "MM/DD/YYYY", эсвэл "DD MM YYYY" гэх мэт). Огноог Date төрөлд хувиргасны дараа зөв хувирсан эсэхийг заавал шалгаж бай.

### Бүлэглэсэн дата {.unnumbered}

`mutate()` функц *бүлэглэгдсэн* датанд ( [Grouping data] хэсгийг хар) арай өөр байдлаар хэрэглэдэг. Ихэнх статистикийн `mean()`, `median()`, `max()` зэрэг тооцооллыг нийт датанд биш бүлэглэсэн хэсгүүдэд тооцоолдог.

```{r, eval=F}
# насыг бүх мөрний дунджаар хуваах
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# насыг эмнэлэгт хэвтсэн бүлгийн дунджаар хуваах
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Бүлэглэсэн хүснэгтэд `mutate ()` -г хэрхэн хэрэглэх талаар [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) хэсгээс нэмж уншна уу.

### Олон баганыг хувиргах {#clean_across .unnumbered}

Кодыг богино болгох үүднээс багануудыг зэрэг хувиргах шаардлага гардаг. Үүнийг **dplyr** -ын ( **tidyverse** багцуудын нэг) `across()`-оор хийж болно. **dplyr** -ын фүх функцийг `across()` -тай хавсарч хэрэглэх боломжтой ч `select()`, `mutate()`, `filter()`, `summarise()` зэрэгтэй илүү хамт хэрэглэдэг.[Descriptive tables] хэсгээс `summarise()` -тай хэрхэн хавсарч хэрэглэж болох талаар харна уу.

`across()`-ын`.cols =` аргументэд сонгосон багануудаа оруулаад, `.fns =` аргументэд гүйцэтгэх функцээ зааж өгнө. `.fns` -д заагдсан функц өөрийн аргументтэй бол таслал аваад `across()` хаалт дотроо нэмж оруулна.

#### `across()` багана сонгох {.unnumbered}

Хувиргах багануудаа `.cols =` -д зааж өг. Баганыг нэг бүрчлэн нэрлэж оруул. Эсвэл "tidyselect" -ын туслах функцээс ашиглаж болно. Сонгосон функцээ `.fns =`-д зааж өг. Оруулсан функц **хаалтгүйгээр** бичигдсэн байгааг дор жишээнээс харна уу.

`Дор жишээнд across()` дотор бичигдсэн багануудад `as.character()` хувиргалт зэрэг хийгдэж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Багана сонгох үйлдлийг "tidyselect" -ын туслах функцууд ашиглаж хялбарчилдаг. Энэ функцуудын талаар Багана сонгох болон эрэмбэлэх хэсэгт дэлгэрүүлж тайлбарласан. Эдгээр туслах функцэд : `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` `any_of()` орно.

Энд **бүх баганыг** хэрхэн зэрэг character төрөлд хувиргахыг харуулав:

```{r, eval=F}
#бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Дор зөвхөн нэрэндээ "date" гэсэн үг агуулсан багануудыг character -руу хувиргаж байна (таслал, хаалтны байрлалыг ажигла):

```{r, eval=F}
#"date" -гэсэн үг нэрэнд нь бичигдсэн бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Дор POSIXct хэлбэрт (цаг хугацааг харуулсан түүхий датаны хэлбэр) байсан багануудыг хэрхэн хувиргахыг харуулав. Ингэхдээ `is.POSIXct()` функцээр багануудыг шалгаад `TRUE` хариу өгсөн багана болгоныг `as.Date()`-руу хувиргаснаар зөв Date хэлбэрт оруулах болно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Дээр бичсэнээр `across()` доторх `where()` функцээр `is.POSIXct` функц үнэн (TRUE), худал (FALSE) эсэхийг шалгаж байна.\
-   Энэхүү `is.POSIXct()` нь **lubridate** багцын функц. Бусад төстэй "is"-ээр эхэлдэг функцууд `is.character()`, `is.numeric()`, `is.logical()` нар **base R** багцын функцууд.

#### `across()` функцууд {.unnumbered}

`?across()` коммандаар зааврыг гаргаж ирж танилцаж `across` -коммандад функц хэрхэн оруулах талаар дэлгэрэнгүйтэй танилцаж болно . Функц гэдэг ойлголтод хэд хэдэн тодорхойлолт байдаг ба таны зохиосон функц ч бас үүнд ордог.

-   Функцын нэрийг дангаар нь өгч болно (ж:`mean` эсвэл `as.character`)\

-   Функцыг **purrr**-багцын форматаар уншуулж (ж:`~ mean(.x, na.rm = TRUE)`) ( [this page][Iteration, loops, and lists]-ээс хар)\

-   Олон функцуудыг list -д жагсааж оруулж болно (ж: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Олон функц зэрэг оруулж буй үед , multiple transformed columns will be returned per input column, with unique names in the format `col_fn`. Шинээр үүсэх багануудын нэрийг **glue** -ын `.names =` аргументээр тохируулж болно ( [Characters and strings]-ээс нэмж хар) `{.col}` болон `{.fn}` are shorthand for the input column and function.

`across()`-ын талаарх нэмэлт онлайн эх сурвалжууд: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### `coalesce()` {.unnumbered}

Энэхүү **dplyr** багцын функц хамгийн эхний дутуу биш утгыг байрлал бүрт олж тогтоодог. Ингэснээр хамгийн эхний боломжит дутуу биш утгыг дутуу утгатай газар таны заавраар "нөхдөг".

Үүнийг дараах байдлаар тайлбарлая: Таньд хоёр вектор дата байна гэж бодъё. Нэг нь өвчтөний оношлогдсон тосгонууд, нөгөө нь өвчтөний амьдардаг хотууд. Үүний эхний дутуу биш утгыг coalesce-г ашиглаж индекс бүрт олж болно:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # хэвлэ
```

Хүснэгтэд мөн адил хэрэглэгднэ: таны заасан багана дах эхний дутуу биш утгыг мөрийн дагуу өөр баганад оноож өгнө (таны заасан дарааллын дагуу ).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Энэ жишээнд "мөр - дагуух" гүйцэтгэлийг харуулав. Энэ үйлдлийг хэрхэн хийх талаар Мөр-дагуу тооцоолол хэсгээс харна уу.

### Cumulative математик {.unnumbered}

Мөр дэх утгыг өмнөх мөрний утгатай нэгтгэж sum/mean/min/max зэрэг функцуудыгг ашиглаж cumulative дүнг бодохдоо дараах функцыг хэрэглэдэг:

`cumsum()` -аар cumulative нийлбэрийг олно:

```{r}
sum(c(2,4,15,10))     # нийлбэр нэг утга бодогдно
cumsum(c(2,4,15,10))  # утга тус бүрт cumulative нийлбэрийг бодно
```

Хүснэгтийн хувьд мөн адилхан. Дэгдэлтийн үе дэх тохиолдлын тооны сumulative нийлбэрийг дараах кодоор бодно.

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # linelist-ээс эхэл
  count(date_onset) %>%                 # Өдөр тутмын мөрийг тоолох ('n')   
  mutate(cumulative_cases = cumsum(n))  # Мөр болгонд cumulative нийлбэрийг бодсон шинэ багана үүсгэ
```

Дээрх коммандаар хийсэн хүснэгтийн эхний 10 мөрийг харах код:

```{r}
head(cumulative_case_counts, 10)
```

Cumulative тохиолдлын тоогоор график хийх тухай [Epidemic curves] хэсгээс уншина уу.

Мөн дараах функцуудын талаар харна уу:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### **base** R -г ашиглах {.unnumbered}

**base** R-аар шинэ багана үүсгэх (эсвэл хуучин баганыг өөрчлөх) бол дататай хүснэгтийн нэрийн ард `$` тэмдэгт тавьж *шинэ* үүсгэх (эсвэл өөрчлөх) баганын нэрийг ард нь шууд залгаж бичдэг. Оруулах шинэ утгаа оноох операторыг ашиглаж `<-` оруулна. **base** R -т хүснэгтийн нэрийг баганын нэрний өмнө бичдэг болохыг анхаарна уу (ж: `dataframe$column`). Энэ жишээнд `bmi` -г хэрхэн **base** R -ыг ашиглаж үүсгэхийг харуулав:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Pipe холбоосонд залгах {.unnumbered}

**Дор жишээнд шинэ мөр үүсгэх, зарим баганын төрлийг хувиргах үйлдлийг pipe холбоосонд залгаж харуулав.**

```{r }
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    ###################################################
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Утга өөрчлөх

Дараах тохиолдлуудад утга өөрчлөх шаардлага гарна:

-   аливаа нэг утгыг янзлах (ж: нэг огнооны жил буруу эсвэл буруу форматтай орсон байх)
-   янз бүрээр галиглагдаж бичигдсэн утгуудыг жигд болгох
-   categorical утгатай шинэ багана үүсгэх
-   numerical утгыг бүлэглэж шинэ багана нэмэх (ж: насны бүлэглэл)

### Өвөрмөц утгууд {.unnumbered}

Утгыг гараар өөрчлөхийн тулд `mutate()` дотор `recode()` -ыг оруулдаг.

Жишээ нь буруу бичигдсэн огноо өөрчлөхдөө (ж: "2014-14-15") шууд эх дата дээрээ (боловсруулалт хийхийн өмнө) гараар янзалж болно. Эсвэл `mutate()`, `recode()`-функцуудыг pipe холбоост залгаж огноог өөрчилж болно. Сүүлийн аргыг хэрэглэх нь бусдад нээлттэй (transparent), дахин боловсруулалт хийх боломжтой болдгоороо ач холбогдолтой.

```{r, eval=F}
# алдаатай утгыг засах                   # хуучин утга  # шинэ утга
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Дээр бичигдсэн `mutate()` үйлдлийг дараах байдлаар уншина: "`date_onset` баганыг шинэчлэгдсэн `date_onset` тай тэнцүүлж бичих ба ингэснээр ХУУЧИН УТГА нь ШИНЭ УТГА-аар солигдно". `recode()` функцын энэ дараалал (ХУУЧИН = ШИНЭ) R -ын ихэнх функцэд эсрэгээрээ байдаг (шинэ = хуучин). R хөгжлийн нийгэмлэг үүнийг сайжруулахаар ажиллаж байна.

**Нэг баганад олон утгыг зэрэг өөрчлөх өөр нэгэн жишээг дор харуулав.**

`linelist` -ын "hospital" баганыг цэвэрлэх шаардлагатай боллоо. Учир нь хэд хэдэн газар алдаатай бичигдэж, дутуу утгууд болон орсон байна.

```{r}
table(linelist$hospital, useNA = "always")  # бүх өвөрмөц утгыг дутуу утгыг оролцуулан хэвлэ  
```

Энэ жишээнд "hospital" баганыг хэвээр үлдээх боловч `recode()` коммандаар зарим утгад өөрчлөлт оруулж байна. Тус бүр ардаа таслалтай байгааг анхаар!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # лавлагаа: ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Одоо `hospital` баганын галиглал хэрхэн засагдаж жигдэрсэн байгааг хар:

```{r}
table(linelist$hospital, useNA = "always")
```

[***ЗӨВЛӨГӨӨ:*** тэнцүүгийн тэмдгийн ард, урд авах зайн урт хамаагүй. Бичсэн кодоо уншихад хялбар байлгах үүднээс = тэмдгийг мөр болгонд тэгшхэн тааруулж бичдэг. Мөн хүмүүст ойлгомжтой болгохын тулд "хэш" тэмдэгтээр аль нь хуучин, аль нь шинэ утга гэдгийг зааж өгдөг.]{style="color: darkgreen;"}

[***ЗӨВЛӨГӨӨ:*** заримдаа *хоосон* утга датад орж ирсэн байдаг ( R-ын дутуу утга буюу `NA` болж танигдаалгүйгээр). Хоосон утга байгааг давхар хашилтан дотор дунд нь зай авахгүй бичдэг ("").]{style="color: darkgreen;"}

### Логик үйлдлүүд {.unnumbered}

Энэ хэсэгт логик болон нөхцөл (conditions) ашиглаж баганын утгыг хэрхэн өөрчилдгийг харуулав:

-   `replace()`, `ifelse()`, `if_else()` зэрэг функцуудыг энгийн логик үйлдэлд хэрэглэдэг
-   `case_when()` функцыг нарийн логик үйлдэлд хэрэглэнэ

### Энгийн логик үйлдэл {.unnumbered}

#### `replace()` {.unnumbered}

Энгийн логик шалгуурыг `mutate()` дотор **base** R-ын `replace()` -функцыг оруулж үүсгэдэг. Энэ дотор шаардлагатай логик нөхцөлөө оруулж өгнө. Синтаксын ерөнхий формат:

`mutate(col_to_change = replace(col_to_change, мөрний шалгуур үзүүлэлт, шинэ утга))`.

Мөн датан дах **аль нэг утгыг өвөрмөц дугаараар нь дуудаж өөрчлөх** үйлдэлд`replace()` -ийг их хэрэглэдэг. Дорх кодоор `case_id` баганад 2195 гэсэн утга байвал үүнтэй харалдаа орших мөрний gender багана дах утгыг "Female" болгож өөрчилж байна.

```{r, eval=F}
# Жишээ: заасан нэг ширхэг ажиглалтыг "Female" болгож өөрчлөх
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

**base** R -т үүнтэй ижил үйлдлийг индекслэх тэмдэг буюу дөрвөлжин хаалт `[ ]` гүйцэтгэдэг (дор жишээнд харуулав). Дор кодыг дараах байдлаар уншина: "`linelist` хүснэгтийн `gender` баганыг (`case_id` баганадаа '2195' гэсэн утгатай тохиолдолд) 'Female' болго ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` болон `if_else()` {.unnumbered}

Энгийн логик үйлдэл хийдэг `ifelse()`, `if_else()` гэсэн функцууд байдаг ч оронд нь `case_when()` функцыг хэрэглэвэл илүү ойлгомжтой байдаг (дэлгэрэнгүйг доор бичсэн). Эдгээр "if else" коммандууд нь `if` болон `else` программчлалын хялбаршуулсан хэлбэр. Синтаксын ерөнхий формат:\
`ifelse(нөхцөл, хэрэв нөхцөл TRUE бол дуудах утга, нөхцөл FALSE бол дуудах утга)`

Дор `source_known` баганыг тодорхойлсон байна. Энэхүү кодоор `source` баганын мөрөнд дутуу утга *биш* бол харалдаа мөрний `source_known` баганын утгыг "known" болгоод, харин `source` мөрний утга дутуу утга *мөн* бол харалдаа мөрний `source_known` баганын утгыг "unknown" болгоно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

**dplyr** багцын `if_else()` -ээр огноо янзлах нь элбэг. Хэрэв 'жинхэнэ' утга нь огноо бол 'худал' утгыг ч огноо гэж үзэх тул ердийн `NA`-ын оронд тусгай `NA_real_` хэрэглэнэ.

```{r, eval=F}
# Нас баралтын огноотой багана үүсгэ. Өвчтөн нас бараагүй бол `NA`-аар бич.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**олон зэрэг ifelse -ийг бичихэээс зайлсхий. Оронд нь `case_when()` -ийг хэрэглэ!** `case_when()` -ээр хялбар уншигдаж, алдаа бага гаргадаг.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Код бичихэд хэрэглэдэг обьектийг хүснэгтээс гадуур байлгахыг хүсвэл object used in your code switch its value, consider using `switch()` from **base** R.{style="color: red;"}

### Нарийн логик үйлдлүүд {#clean_case_when .unnumbered}

Бүлэглэгдсэн утгад өөрчлөлт оруулах, нарийн логик үйлдэл зэрэгт хийх **dplyr** -ын `case_when()` -ыг хэрэглэвэл тохиромжтой. Энэ функц хүснэгтийн мөр болгоныг шалгаад, шалгуурт нийцсэн утгыг заасны дагуу өөрчилдөг.

`case_when()` комманд нь Баруун-Тал/Right-Hand Side (RHS) болон Зүүн-Тал/Left-Hand Side (LHS) -ын зарчмаар бичигдэж "тилда" `~` тэмдэгээр хуваагддаг. Логик шалгуур нь зүүн талдаа, харин нийцүүлэх утга нь баруун талдаа бичигдэж, тус бүр таслалаар зааглагдна.

Жишээ нь, `age` болон `age_unit` баганыг ашиглаж `age_years` баганыг үүсгэсэн байна:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # хэрэв age жилээр бол
            age_unit == "months" ~ age/12,    # хэрэв age сараар бол
            is.na(age_unit)      ~ age,       # хэрэв age_unit дутуу утга байвал (age жилээр)
            TRUE                 ~ NA_real_)) # бусад бүх тохиолдолд дутуу утгаар оруул
```

Mөрөнд шүүлт хийгдэх явцад шалгуурт нийцсэн утгууд шууд өөрчлөгдөөд явдаг ба шүүгдэх дараалал нь дээрээс доош байна.

As each row in the data is evaluated, the criteria are applied/evaluated in the order the `case_when()` statements are written - from top-to-bottom. If the top criteria evaluates to `TRUE` for a given row, the RHS value is assigned, and the remaining criteria are not even tested for that row. Thus, it is best to write the most specific criteria first, and the most general last.

Along those lines, in your final statement, place `TRUE` on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like "check me!" or missing.

[***DANGER:*** **Vvalues on the right-side must all be the same class** - either numeric, character, date, logical, etc. To assign missing (`NA`), you may need to use special variations of `NA` such as `NA_character_`, `NA_real_` (for numeric or POSIX), and `as.Date(NA)`. Read more in [Working with dates].]{style="color: red;"}

### Дутуу утга {.unnumbered}

Дата цэвэрлэгээ хийж байхад дутуу утгыг янзалдаг хэрэглэгддэг функцуудыг дор харуулав.

Дутуу утгыг олж, янзлах талаар [Missing data] хэсгээс нэмж үзэж болно. Тухайлбал `is.na()` функц логик шалгуураар дутуу утгыг олдог.

**`replace_na()`**

`NA` дутуу утгыг өөр бичиглэлтэй дутуу утгаар ("Missing") солихын тулд **dplyr** функцын `replace_na()` -г `mutate()` дотор бичнэ. `recode` -ийг хэрэглэх зааварт дурьдсанчлан баганын нэрийг `replace_na()` дотор оруулахыг анхаар.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

Энэхүү функц нь **forcats** багцад хамаарна. **forcats** багц Factor төрлийн датаг янзалдаг. Factor нь *ordered* ( жишээ нь `c("First", "Second", "Third")` ) утга болон аливаа түвшин зааж өгөх гэж буй ( жишээ нь: эмнэлэгүүд) утгуудыг R хэлэнд оруулсан хэлбэр. [Factors] хэсгээс нэмж харна уу.

Factor датаны `NA` -г "Missing" болгож өөрчлөхөөр `replace_na()` комманд өгвөл `invalid factor level, NA generated` гэсэн алдаа гарч ирдэг. Энэ нь "Missing"-г Factor -т хэлбэрт хувиргаагүй байхдаа утга болгож оруулах оролдлого хийсэн тул комманд буцаагдаж, алдаа гарч ирж буй юм.

Үүнийг шийдвэрлэх хамгийн хялбар арга бол **forcats** багцад байдаг`fct_explicit_na()` функцыг ашиглах ба энэ функц нь баганыг factor болгож, `NA` -г character "(Missing)" хэлбэрт хувиргадаг.

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Өөр нэгэн арай удаан хувилбар бол `fct_expand()`-г ашиглаж factor -ын түвшингүүдийг нэмж оруулсны дараа дутуу утгаа өөрчлөх юм.

**`na_if()`**

*Тодорхой нэг утгыг* `NA`- болгохын тулд **dplyr**'s-ын `na_if()` -г хэрэглэдэг. Доорх коммандаар `replace_na()-`ын эсрэг үйлдлйиг хийнэ. Энд `hospital` багана дах "Missing" утга болгон `NA` болж хувирах юм.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Тэмдэглэл `na_if()` **-г логик шалгуурт хэрэглэх боломжгүй** (жишээ нь "бүх утга \> 99"). Оронд нь `replace()` эсвэл `case_when()` -ыг хэрэглэ:

```{r, eval=F}
# 40 -өөс дээш градусыг NA  болго
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# 1 Jan 2000 -аас өмнөх огноог дутуу утга болго
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Цэвэрлэгээний толь {.unnumbered}

**linelist** болон түүний `clean_variable_spelling()` функцээр цэвэрэлэгээний тольтой хүснэгтийг цэвэрлэдэг. **linelist** багцыг R Epidemics Consortium [RECON](https://github.com/reconhub/linelist) боловсруулж гаргасан.

1)  Цэвэрлэгээний толийг дараах гурван баганатайгаар бүтээ:

    -   алдаатай утгуудыг заасан багана\
    -   зөв утгуудыг заасан багана\
    -   өөрчлөлт оруулах баганын хамралт (жишээ нь ".global" гэвэл бүх баганыг өөрчлөх)

Тэмдэглэл: .global толь баганад өвөрмөцөөр бичигдсэн толийг давамгайлж бичигдэх болно.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Цэвэрлэгээний толь бичсэн хүснэгтээ R луу импортло. Энэ жишээг [Download handbook and data] хуудсанд заасны дагуу татаж авч болно.

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Түүхий linelist -ийг `clean_variable_spelling()` функцэд оруулаад `wordlists =` аргументэд цэвэрлэгээний тольтой датагаа зааж өгнө. Үүний `spelling_vars =` аргументээр өөрчлөх баганын нэрстэй баганыг зааж өгч болно ( default)-аар гуравдах багана) . Хэрэв бүх factor болон character баганыг хамруулья гэвэл `spelling_vars =` аргументийг `NULL` гэж заана. Энэ функц удаан уншигдаж болохыг анхаар.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # өөрчлөх баганын нэрстэй багана. default-аар гуравдах багана
  )
```

Одоо баруун тийш нь гүйлгээд датанд хэрхэн өөрчлөлт орсныг харж болно. Энд `gender` багана жижгээс том үсэгтэй болж, шинж тэмдэг агуулсан бүх багана yes/no -өөс 1/0 болж хувирсан байна.

```{r message=FALSE, echo=F}
#  linelist -ийг хүснэгтээр харуул
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Note that your column names in the cleaning dictionary must correspond to the names *at this point* in your cleaning script. See this [online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) for more details.

#### Цэвэрлэх pipe холбоосонд залгах {.unnumbered}

**Доорхи pipe холбоосонд багана нэмэх, баганын хувиргах үйлдлүүд залгагдсан.**

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ###################################################

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Тоог ангилах {#num_cats}

Энэ хэсэгт numeric баганаас хэрхэн categorical (ангилсан) утга үүсгэх аргуудыг үзнэ. Тоон ангилалын жишээнд насны ангилал, шинжилгээний үзүүлэлтийн ангилал зэрэг орно. Гол хэрэглэгдэх функцууд:

-   **epikit** багцын `age_categories()`\
-   **base R -ын** `cut()`\
-   `case_when()`\
-   `quantile()`, `ntile()`зэрэг кванталууд

### Тархалт Review distribution {.unnumbered}

Жишээгээр `age_years` баганыг ашиглаж `age_cat` баганыг үүсгэнэ.

```{r}
# linelist -хүснэгт дэх нас заасан баганын дата төрлийг тогтоох
class(linelist$age_years)
```

Эхлээд датаны тархалтын дүрсийг шалгаж хуваах цэгүүдээ (cut-points) тогтооно. [ggplot basics] хэсгээс дэлгэрүүлж харна уу.

```{r, out.height='50%'}
# тархалтын дүрсийг шалга
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***АНХААРУУЛГА*** Заримдаа тоон хувьсагч нар "character" хэлбэрээр импортлогдох тохиолдол байдаг. Энэ нь тухайн хувьсагчын аль нэг утганд тоон биш тэмдэгт агуулагдсан байснаас болдог. Жишээ нь нас заасан баганад "2 сар" (2 months) гэж бичигдэх, бутархай тоонд цэг биш таслал тавигдах тохиолдлууд байдаг ("4,5" -аар дөрөв аравны тав гэсэн санаа илэрхийлсэн байх).]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

Тоон баганын утгыг ангилахдаа **epikit** багцын `age_categories()` -ыг хэрэглэвэл хялбар байда (тэмдэглэл: энэхүү функцыг тоон биш хувьсагчид мөн хэрэглэж болдог ). Мөн үүссэн багана нь автоматаар шаталсан (ordered) factor төрлийн багана болдог ач холбогдолтой.

Шаардлагатай оролтууд:

-   Тоон вектор (багана)\
-   `breakers =` аргумент - шинэ үүсэх ангиллын хуваагдах цэгүүдийг заасан тоон векторуудыг бичнэ.

Эхлээд энгийн жишээ авч үзье:

```{r}
# Энгийн жишээ
################
pacman::p_load(epikit)                    # багцыг ачаалла

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # багана үүсгэ
      age_years,                            # шинэ багана үүсгэхэд ашиглах numeric багана
      breakers = c(0, 5, 10, 15, 20,        # хуваагдах цэгүүд
                   30, 40, 50, 60, 70)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

The break values you specify are by default the lower bounds - that is, they are included in the "higher" group / the groups are "open" on the lower/left side. As shown below, you can add 1 to each break value to achieve groups that are open at the top/right.

```{r}
# дээд хязгаарыг ижилхэн ангилалд оруулж байна
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Ангиллын нэрсийг `separator =` аргументээр тохируулж болно. Default тэмдэг нь "-". тоон утгын дээд хязгаарыг хэрхэхийг `ceiling =`аргументээр тохируулна. Дээд хязгаар тогтоох бол `ceiling = TRUE`гэж өгнө. Ингэснээр хамгийн дээд тогтоосон тоогоор ангилал дуусч "XX+" гэсэн ангилал үүсэхгүй. Энэхүү зааж өгсөн дээд хязгаараас их (эсвэл `upper =` -т зааж өгсөн) ямар ч тоо `NA` ангилалд орно. Доор жишээнд `ceiling = TRUE` -аар өгснөөр XX+ ангилал үүсэхгүй, 70 -аас дээш (зааж өгсөн хамгийн дээд хязгаар) тоо NA болж буйг харж болно.

```{r}
# ceiling аргументийг TRUE дээр тохируулсан
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 бол дээд хязгаар ба үүнээс дээш тоо NA болно

# sхүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Мөн `breakers =` аргументийн оронд та өөрөө `lower =`, `upper =`, `by =` гэсэн аргументуудэд гараар хуваах тоогоо оруулж өгч болно:

-   `lower =` Таны зааж өгсөн хамгийн бага тоо - default нь 0\
-   `upper =` таны зааж өгсөн хамгийн их тоо\
-   `by =` ангилал хоорондын интервал

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

энэ функцын Help хуудаснаас нэмэлт мэдээллийг үзэж болно (R console-д `?age_categories` гэсэн коммандаар гаргана).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()` бол **base** R -д багтдаг `age_categories()` тай адил үйлдэлтэй функц. Гэвч `age_categories()` дээр ажиллахад илүү хялбар байдаг. Энэхүү функцын `age_categories()` -аас гол ялгаатай шинжүүд:

-   Өөр багц суулгаж/уншуулах шаардлагагүй.\
-   Ангилал баруун/зүүн талруугаа нээлттэй/хаалттай эсэхийг зааж өгч болно.\
-   Ангиллын нэрсийг алдаагүй зөв өөрөө бичнэ.\
-   Хамгийн бага ангилалдаа 0-г оруулах бол өөрөө зааж өгөх шаардлагатай.

`cut()` дотор эхлээд ангилах гэж буй numeric баганаа (`age_years`) оруулаад, хуваах цэгүүдээ *breaks* аргументэд тоон вектор хэлбэрээр `c()` -д оруулна. `cut()` -аар үүсгэгдсэн багана дэс дараат (ordered) factor хэлбэртэй байдаг.

Default-аар баруун/дээд тал "нээлттэй" (зүүн/доод тал нь "хаалттай" ) байдаг. Энэ нь `age_categories()` функцэд эсрэгээрээ байдаг. Default тэмдэглэгээ нь "(A, B]" бөгөөд энэ нь A ороогүй B орсон гэсэн утгатай. **Үүнийг эсрэг хэлбэрийг `right = TRUE` гэж аргументэд зааж өгснөөр үйлдэгднэ.**

Тиймээс хамгийн бага тоотой ангилалд default -аар "0" ордоггүй ба "0" утга `NA` болж хувирдаг. Тухйалбал нярай хүүхдүүдийн нас 0 гэж кодлогддог тул анхаарч байх шаардлагатай. Үүнийг өөрчлөхийн тулд `include.lowest = TRUE` гэсэн аргументийг нэмснээр s "0" утга vхамгийн бага тоотой ангилалд багтах болно. Автоматаар үүссэн ангиллын нэр хамгийн бага ангилалд "[A],B]" болдог. Хэрэв `include.lowest = TRUE` гэсэн аргументийг өгч, мөн `right = TRUE`, гэх юм бол хамгийн их тоотой ангилалд үйлчилдэг болохыг анхаар.

Үүсгэсэн ангилалд нэр өгөх бол `labels =` аргументийг ашиглаж болно. Гараар бичигдэх тул алдаа гаргахаас сэргийлээрэй! Cross-tabulation (солбисон хүснэгт) ашиглаж алдаагаа шалгаарай

`cut()` ашиглаж `age_years` баганаас `age_cat` гэсэн шинэ багана үүсгэх жишээг дор харуулав:

```{r}
# Тоон age хувьсагчийг хувааж, ангилагдсан багана үүсгэ
# Ангиллын доод хязгаар нь битүү харин дээд хязгаар нь нээллттэй байна.
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # 0 -г доод ангиолд багтаа
      ))

# ангилал тус бүр дэх ажиглалтын тоог жагсааж хар
table(linelist$age_cat, useNA = "always")
```

**Хийсэн ажлаа шалга!!!** Насны тоон үзүүлэлтүүд зөв ангилалдаа орсон эсэхийг тоон болон ангилагдсан багануудыг солбиж харуулсан хүснэгт ашиглаж шалга. Захын утгуудыг шалга (жишээ нь 15 ын тоо 10-15 эсвэл 16-20 гэсэн ангилалтай хөрш байна).

```{r}
# Тоон болон ангилагдсан баганыг солбиж харуулсан хүснэгт
table("Numeric Values" = linelist$age_years,   # ойлгомжтой болгох үүднээс багануудад нэр өгсөн
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # NA утгуудыг шалгахаа бүү мартаарай
```

**`NA` утгуудад дахин нэр өгөх**

`NA` -утгуудад "Missing" гэсэн нэртэй ангилалд оруулж болно. Шинээр үүсэх багана Factor учир (хязгаарлагдсан утгууд), шууд `replace_na()` аар хувиргалт хийх боломжгүй. [Factors] хэсэгт тайлбарсанчлан **forcats** багцын `fct_explicit_na()` функцыг хэрэглээрэй.

```{r}
linelist <- linelist %>% 
  
  # cut() -аар age_cat-ыг үүсгэнэ. Factor төрлийн багана үүснэ.     
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # Дутуу утгыг тодорхой болго
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # нэрийг өөрөө өгч болно
  )    

# ангилал тус бүр лэх ажиглалтын тоог харуулсан хүснэгт
table(linelist$age_cat, useNA = "always")
```

**Хуваах, нэрлэх үйлдлийг түргэсгэх**

Аливаа векторыг түргэн хугацаанд хувааж, нэр өгөх жишээг дор харуулав. [R basics] хэсгийн `seq()`, `rep()` -ийн тайлбараас нэмж үзэж болно.

```{r, eval=F}
#  0 -ээс 90 хүртэлх тоог 5 аар хуваагдсэн цэгүүд үүсгэ. 
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Дээрх үүссэн ангиллуудад нэр өг (cut() default тохируулгатай)
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# ажиглалтын тоо хоёр векторт адилхан байна
length(age_seq) == length(age_labels)
```

`cut()` функцын талаар Help хуудаснаас нь `?cut` комманд R console.-т өгснөөр мэдэж болно.

### Квантил хуваагдлууд {.unnumbered}

In common understanding, "quantiles" or "percentiles" typically refer to a value below which a proportion of values fall. Жишээ нь, `linelist` -ийн нас заасан баганын 95 дах персентил гэдэг нь нас заасан бүх утгыг 95% нь орж буй утгуудыг хэлж байдаг.

Ердийн хэллэгт "квантил", "децил" гэдэг нь аливаа датаг 4 эсвэл 10 тэнцүү хуваахыг хэлдэг (хуваасан тооноос нэг илүү ангилал үүсэхийг анхаараарай).

Квантилаар хуваахдаа **base** R-ын **stats** багц дах `quantile()` функцыг ашиглана. Та тоон вектор болон 0-оос 1 хүртэлх магадлалыг оноосон векторыг (жишээ нь хүснэгтийн багана) оруулж өгнө. Хуваагдах цэгүүд вектор хэлбэртэй үүснэ. Энэ функцын талаарх нэмэлт статистикийн аргачлалын талаар `?quantile`комманд өгч уншна уу.

-   хэрэв таны оруулсан тоон векторт дутуу утга агуулж буй бол `na.rm = TRUE` гэж тохируулах хэрэгтэй.\
-   `names = FALSE` гэж тохируулснаар нэрлэгдээгүй тоон векторыг гаргаж ирнэ.

```{r}
quantile(linelist$age_years,               # ажиллах гэж буй тоон вектороо зааж өгнө
  probs = c(0, .25, .50, .75, .90, .95),   # персентилээ зааж өгнө
  na.rm = TRUE)                            # дутуу утгыг үл тоох 
```

`quantile()` -аар бодогдсон хуваагдах цэгүүдээ `age_categories()`, `cut()` функцын оролтод оруулж болно. Дор жишээнд бид `age_years` багана дах хуваагдах цэгийн `quantiles()` -аар бодож `cut()` коммандад өгч үүсгэсэн `deciles` баганыг харууллаа. Гарсан үр дүн дэх хувийг **janitor** багцын `tabyl()` функцийг ашиглаж харуулав ( [Descriptive tables] хуудсаас харна уу). Бүлэгүүд тус тус яг 10% биш буйг харж байна.

```{r}
linelist %>%                                # linelist-ээс эхэд
  mutate(deciles = cut(age_years,           # cut()-аар age_years баганасс decile баганыг үүсгэ
    breaks = quantile(                      # quantile()-аар хуваагдах цэгүүдийг тодорхойл
      age_years,                               # age_years дээр хэрэгжүүл
      probs = seq(0, 1, by = 0.1),             # 0.0 -ээс 1.0 -ыг 0.1 -ээр хуваа
      na.rm = TRUE),                           # дутуу утгуудыг үл тоох
    include.lowest = TRUE)) %>%             # cut() -д  0 насыг оролцуул
  janitor::tabyl(deciles)                   # хүснэгт болгож харуулах
```

### Тэнцүү хэмжээтэй бүлгүүд үүсгэх {.unnumbered}

Тооноос бүтэн бүлэг үүсгэх өөр нэгэн функц бол **dplyr** багцын `ntile()` юм. Энэ функц таны датаг яг тэнцүү бүлгүүдэд хуваахыг оролддог. *Гэвч `quantile()` -ээс ялгаатай тал нь нэг тоо хоёр өөр бүлэгт орж болдог тул анхаарах хэрэгтэй.* Тоон вектор болон үүсгэх бүлгийн тоог оруулж өгөх хэрэгэтй. `cut()` функцээр багана үүгэхэд дотор нь бүлэглэгдсэн утга байдаг бол `ntile()`-ээр үүссэн багана дах утга зөвхөн бүлгийн дугаарууд болохыг анхаарна.

```{r}
# ntile()-аар бүлэг үүсгэ
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# бүлэг тус бүрт ноогдох ажиглалтын тоо пропорцыг харуулах
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# зах хязгаарыг харуулах үүднээс min/max -г мөн нэмж харуул
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# нэгтгэж, хэвлэ - зарим утга олон бүлэгт зэрэг орж болохыг анхаар
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

**dplyr** -ын `case_when()` -ыг ашиглаж тоон баганаас бүлэглэсэн багана үүсгэж бас болно. Гэхдээ шууд автоматаар эрэмбэлэгдсэн factor төрлийн багана үүсдэг тул **epikit** -ын `age_categories()` эсвэл `cut()` -ыг хэрэглэх нь илүү хялбар байдаг.

Хэрэв `case_when()` -г хэрэглэх бол Re-code values хэсгээс нэмж хэрхэн зөв хэрэглэх талаар үзнэ үү. Мөн энэ үед бүх баруун гар тал дах утгууд ижил төрөл байх хэрэгтэй. Хэрэв `NA` -г баруун гар талд бичих бол "Missing" эсвэл `NA` -г төлөөлсөн тусга `NA_character_` хэрэглэх шаардлагатай.

### Цэвэрлэх холбоост залгах {.unnumbered}

Жишээгээр хоёр ангилагдсан баганыг цэвэрлэх pipe холбоостоо залгаж өгч харууллаа.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
  
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Мөр нэмэх

### нэг нэгээр нэмэх {.unnumbered}

Мөрийг нэг нэгээр нь гараар оруулах ажиллагаа ихтэй ба **dplyr**-ын `add_row()` -аар гүйцэтгэдэг. Багана тус бүр нэг төрлийн дата агуулсан байх шаардлагатайг санаарай (character, numeric, logical, гэх мэт). Мөр нэмэх дээ үүнтэй зохицох хэрэгтэй.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

`.before` болон `.after.` аргументээр нэмэх мөрийн байрлалыг зааж өгдөг. Жишээ нь`.before = 3` гэвэл одоо харагадаж байгаагаас 3 мөрний өмнө нэм гэсэн үг. Default -аар мөр төгсгөлд нь нэмэгддэг. Зааж өгөөгүй багана буй байвал доторх утга нь дутуу утга (`NA`) -аар ордог.

Шинэ үүссэн *мөрийн дугаар* хачин харагдаж болох ба ("...23") but the row numbers in the pre-existing rows *have* changed. So if using the command twice, examine/test the insertion carefully.

Хэрэв зааж өгсөн дата төрөл чинь таарахгүй бол доорхи шиг алдаа гарч ирнэ:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(огноо төрлийн мөр нэмж буй бол, огноогоо `as.Date()` функцэд оруулж өгөөрэй ( `as.Date("2020-10-10")`).

### Мөрүүдийг холбох {.unnumbered}

Нэг хүснэгтийн мөрийг өөр нэг хүснэгтийн доороос залгаж дата үүсгэх бол **dplyr** -ын `bind_rows()`- ыг хэрэглэдэг. Энэ талаар [Joining data] хэсэгт илүү тайлбарласан.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөрийг шүүх

Багануудыг цэвэрлээд, шинэ утгуудыг оруулсны дараа нийтлэг хийгддэг алхам бол **dplyr** -ын `filter()` -ээр мөрөнд шүүлт хийх явдал юм.

`filter()` дотор датанд үлдэхийн тулд `TRUE` байх ёстой логикийг зааж өгнө. Дараах хэсгүүдэд энгийн болон нарийн логик нөхцлүүдээр хэрхэн мөрийг шүүдгийг харуулав.

<!-- ======================================================= -->

### Энгийн шүүлтүүр {.unnumbered}

Логик шалгуурт нийцсэн мөрүүдийг `linelist` хүснэгтэд шүүж гаргаж ирэх энгийн жишээг харуулав. **Зөвхөн Хаалтан доторх логик шалгуурт `TRUE` нөхцлүүд л үлддэг.**

Энэ жишээний логик шалгуур `gender == "f"` буюу gender багана дах утгууд "f" (үсгийн том жижиг хамааатай) эй тэнцүү эсэхийг шалгасан шалгуур юм.

Шүүлтүүр уншигдахын өмнө `linelist` дэх мөрийн тоо `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # gender баганад "f" гэсэн мөрүүдийг л авч үлднэ
```

Шүүж ялгасны дараа `linelist` хүснэгтэд `linelist %>% filter(gender == "f") %>% nrow()` мөр үлдсэн.

### Дутуу утгуудыг ялгах {.unnumbered}

Нийтлэг хийдэг үйлдлүүдийн нэг бол дутуу утга агуулсан мөрүүдийг ялгах юм. Ингэхдээ шууд `filter(!is.na(column) & !is.na(column))` коммандыг өгөхийн оронд **tydir** багцын яг энэ үйлдэлд зориулсан функц болох `drop_na()` -ыг хэрэглэвэл оновчтой. Хэрэв хаалт хоосон бол дутуу утга агуулсан ямар ч мөрийг арилгах болно. Мөн өөрийн хүссэн баганыг нэрээр нь дуудаж, эсвэл "tidyselect" функцыг ([above](#clean_tidyselect)) ашиглаж дутуу утгыг тодорхой багануудад шалгаж болно.

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # case_id, age_years багануудад дутуу утгатай  мөрийг арилгах
```

[Missing data] хэсгээс дутуу утгыг янзлан төрөл бүрийн аргатай танилцаж болно.

### Мөрийн дугаараар шүүлт хийх {.unnumbered}

Хүснэгт болон tibble-ийн мөр болгонд (R Viewer цонхоор харахад) эхний баганын зүүн талд харагддаг. Энэ дугаарууд өөрөө тусдаа багана биш боловч `filter()` шүүлт хийхэд хэрэглэж болно.

Дугаараар нь шүүлт хийхдээ **логик шалгуурын нөхцлийн нэг хэсэгт dplyr** -ын `row_number()` функцыг нээлттэй хааллтайгаар оруулдаг. Логик нөхцөлд `%in%` оператор болон тоонуудын жагсаалт ордог (дор үзүүлсний дагуу). Эхний N мөрийг харахаын тулд **dplyr** функцын `head()` функцыг хэрэглэнэ үү.

```{r, eval=F}
# Эхний 100 мөр
linelist %>% head(100)     # tail() -аар сүүлийн мөрүүдийг харж болно

# Эхний 5 мөр
linelist %>% filter(row_number() == 5)

# Заасан гурван баганын 2-20 дах мөрийг харуул
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

You can also convert the row numbers to a true column by piping your data frame to the **tibble** function `rownames_to_column()` (do not put anything in the parentheses).

<!-- ======================================================= -->

### Комплекс шүүлт хийх {.unnumbered}

Илүү комплекс логик шүүлт хийхдээ хаалт `( )`, ЭСВЭЛ `|`, үгүйсгэх `!`, `%in%`, `БОЛОН &`операторуудыг ашигладаг.

Тэмдэглэл: `!` операторыг үгүйсгэх логик шалгуурын өмнө тавьдаг. Жишээ нь `!is.na(column)` комманд өгөхөд тухайн баганад *дутуу утга байхгүй* бол `TRUE` гэж гарна. Үүний адил `!column %in% c("a", "b", "c")` комманд өгөхөд баганын утга вектор биш `TRUE` гэж гарна.

#### Датаг шалга {.unnumbered}

Доорх нэг мөр коммандаар өвчний эхлэлийг харуулсан гистограмм хийгдэх болно. Зургаас харахад 2012-2013 оны хооронд гарсан жижиг дэгдэлтийн дата түүхий датанд орсон буйг харж байна. **Бидний анализэд энэхүү өмнөх дэгдэлтийн датаг арилгах шаардлагатай.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### Тоон болон огнооны датан дах дутуу утгад шүүлт хийх {.unnumbered}

June 2013 -аас хойшхи мөрүүдийг шууд `date_onset` баганыг ашиглаж гшүүх боломжтой уу? **Анхааруулга! `filter(date_onset > as.Date("2013-06-01")))` комманд өгвөл дараагийн дэгдэлт дэх дутуу утгатай бүх мөрийг арилгана!**

[***АЮУЛТАЙ:*** Тоон болон огноонд их (\>) багын (\<) тэмдэг хэрэглэснээр дутуу утгатай (`NA`) бүх мөрийг арилгана.! Учир нь `NA` -г хязгааргүй их эсвэл бага гэж тодорхойлдог.]{style="color: red;"}

*(Огноо болон **lubridate** багцтай ажиллах талаар [Working with dates] хэсгээс үзээрэй)*

#### Шүүлтүүрийн загвар төлөвлөх {.unnumbered}

Солбисон хүснэгтээр зөв мөрүүдийг хамрагдсан эсэхийг шалга:

```{r}
table(Hospital  = linelist$hospital,                     # эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчин эхэлсэн (date_onset)-ийн жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Энэхүү датанаас эхний дэгдэлтийн (2012 болон 2013 онууд дах)хэсгийг шүүхийн тулд ямар шалгуур нэмж болох вэ? Үүнээс харахад:

-   2012 болон 2013 -д болсон эхний дэгдэлтүүд A , B эмнэлэгт гарсан байна. Мөн Port эмнэлэгт 10 тохиолдол байсан байна.\
-   Хоёрдах дэгдэлтийн үед A болон B эмнэлэгүүдэд дэгдэлт гараагүй. Харин Port эмнэлэгт гарсан байна.

Дараах хэсгийг хэрэгтэй:

-   Өвчний эхлэл 2012 болон 2013 онд А, B, Port эмнэлэгүүдэд тэмдэглэгдсэн мөрүүд `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))`:

    -   2012 болон 2013 тэмдэглэгдсэн өвчний эхлэлтэй мөрүүдийг хасах `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))`
    -   A болон B эмнэлэгийн огноо нь дутуу мөрүүдийг хасах `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`\
    -   Огноо нь дутуу утгатай бусад мөрийг **хасахгүй** байх `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`.

Эхлээд linelist -ийн мөрийн тоо nrow(linelist)\`. Шүүлт хийх нөхцөл:

```{r}
linelist <- linelist %>% 
  # Өвчний эхлэл нь 1 June 2013 -ээс хойш ЭСВЭЛ өвчний эхлэл нь дутуу ба A болон B эмнэлэгээс өөр эмнэлэгт гарсан
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Солбицох хүснэгт дахин хийж үзвэл A болон B эмнэлэгүүдийн дата бүтнээрээ, Port эмнэлэгт 2012, 2013 онд гарсан 10 тохиолдлын мөрүүд хасагдаж бусад утгууд хэвэндээ байна (яг бидний зорьсны дагуу).

```{r}
table(Hospital  = linelist$hospital,                     # Эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчин эхэлсэн (date_onset) жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Шүүлт хийх нэг коммандад олон нөхцлийг таслалаар тугаарлан оруулж болно. Илүү тодорхой болгох үүднээс тус тусад нь filter() өгч pipe -аар залгаж болно.

*Тэмдэглэл: зарим уншигчид шууд `date_hospitalisation` шүүлтүүрийг ашиглах нь хялбар болохыг анзаарсан байж талтай. Учир нь энэ нь ямар нь дутуу утгагүй 100% бүтэн. хэрэв тийм бол энэ таны зөв. Дээрх жишээний хувьд өвчни эхлэл харуулсан`date_onset`-г зөвхөн иж бүрдэл шүүлтийг хэрхэн хийхийг үзүүлэх үүднээс сонгосон гэдгийг анхаарна уу.*

### Бие даасан үйлдэл {.unnumbered}

Шүүлт хийх үйлдлийг дангаар нь бас гүйцэтгэж болно (pipe холбоосонд залгалгүйгээр). Энэ тохиолдолд бусад **dplyr** -ын функцын адил эхний аргумент нь дата өөрөө байх болно.

```{r, eval=F}
# dataframe <- filter(хүснэгт, мөрийг үлдээх нөхцлүүд )

linelist <- filter(linelist, !is.na(case_id))
```

**base** R -ын синтакс дах дөрвөлжин `[ ]` хаалт (хүссэн багана, мөрийг заадаг) ашиглан хүссэн хэсгээ салгаж үзэж болно.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Мөрүүдийг түргэн шалгах {.unnumbered}

Дата янзалж байхад зарим мөрүүдийг шалгаж үзэх шаардлага цөөнгүй удаа гардаг. RStudio -ийн цонхон дээр датаг хүснэгтээр хэвлэж үзэхэд **base** R -ын функц `View()`-ийг хэрэглэдэг.

linelist-ийг RStudio хар:

```{r, eval=F}
View(linelist)
```

Доор тодорхой нэг нүдийг шалгаж харах хоёр аргыг харуулав (тодорхий мөр, тодорхой багана):

**dplyr -ын`filter()` болон `select()`функцууд:**

Тодорхой мөрүүдийг авч үлдэхийн тулд `filter()` -т датаг оруулж, араас нь тодорхой багануудыг авч үлдэхийн тулд`select()` ийг pipe -аар холбож `View()` дотор бичнэ. Жишээ нь дараах 3 тохиолдлын өвчин эхэлсэн болон эмнэлэгт хэвтсэн огноог харахын тулд дараах коммандыг өгнө:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

**base** R -ын синтакс дах `[ ]` хаалт ашиглан хүссэн хэсгээ салгаж үзэж, дээрхитэй ижил үр дүнг гаргаж бас болно.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Pipe холбоост нэмэх {.unnumbered}

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
  
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    
    filter(
          # case_id баганад дутуу утгагүй мөрүүдийг л үлдээ
          !is.na(case_id),  
          
          # зөвхөн хоёрдах дэгдэлтийн датаг үлдээ
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөр дагуу тооцоолол

Хэрэв мөрийн дагуу тооцоолол хийх бол **dplyr**-ын `rowwise()` функцыг хэрэглэ. Онлайн винньетийг [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html)- ээс нэмж үзнэ үү .\
Дор жишээнд linelist датаг `rowwise()` шалгаад мөр болгонд "yes" хэмээх утгатай нүдийг тоолж нийлбэрийг харуулсан шинэ багана нэмж байна. Тооцоонд орох багануудыг `sum()` функц дотор нэрээр нь векторт `c()` хийж зааж өгдгө. `rowwise()` функц нь нэг төрлийн `group_by()` функц юм тиймээс хамгийн сүүлд нь `ungroup()` комманд өгөх хэрэгтэй ([Grouping data] хэсэг).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # үзүүлэх зорилготой
```

Оруулах багануудыг зааж өгөхдөө "tidyselect" туслах функцуудыг `select()` хэсэгт тайлбарласны дагуу хэрэглэж болно. Ингэхдээ зөвхөн тохируулга нэмэлтээр хийж өгөх өд л болно (учир нь та **dplyr** бусад функцуул `select()`, `summarise()` зэргээс өөр функц хэрэглэж байгаа тул).

**dplyr** -ын `c_across()` дотор нөхцлөө оруулж өгнө. Учир нь `c_across` ([documentation](https://dplyr.tidyverse.org/reference/c_across.html)) функц `rowwise()` -аар ажилладаг. Жишээ нь дараах код нь:

-   `rowwise()` хийгдэх ба ингэснээр үүний дараа хийгдэх үйлдэл (`sum()`) мөр болгонд хийгдэх болно (багануудын нийлбэр биш).
-   `num_NA_dates` хэмээх шинэ баганыг нэмж, defined for each row as the number of columns (with name containing "date") for which `is.na()` evaluated to TRUE (they are missing data).\
-   `ungroup()` хийснээр дараагийн хийгдэх үйлдлүүдэд `rowwise()` нөлөөлөхгүй байх болно.

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # үзүүлэх зорилготой
```

Мөн `max()` зэрэг бусад функцыг хэрэглэж болно. `max()`-аар мөр болгон дах хамгийн шинэ огноог харуулдаг:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # үзүүлэх зорилготой
```

## Эрэмбэлэн ялгах

Мөрийг баганын утгаар эрэмбэлэх бол **dplyr** функцын `arrange()` -ыг хэрэглэнэ.

Simple list the columns in the order they should be sorted on. Хэрэв эрэмбэлэлтийг аль нэг баганадах ангиллын дагуу хийх бол `.by_group = TRUE` гэж аргументийг тохируулна ([Grouping data] хэсгээс харна уу).

Default-аар бол баганын утга "ихсэх" дарааллаар эрэмбэлэгддэг (тоо болон үсгэн утга). Баганын нэрийг `desc()` -д оруулсанаар "ихсэх" дараалалд оруулж болно.

Ялангуяа тайлагнах, илтгэх хүснэгт [Tables for presentation] -дээр ажиллахад `arrange()` -ыг ашиглавал оновчтой. Ингэхдээ `slice()` -аар ангилал тус бүрийн "оройн" мөрүүдийг харуулах, factor2ын шатлалыг харагдах байлоаар нь эрэмбэлж тохируулж болдог.

Жишээ нь, linelist датаг `hospital` багана дах мөрийн дагуу эрэмбэлээд, дараа нь `date_onset` -ээр буурах дарааллаар эрэмбэлэе гэвэл дараах кодыг хэрэглэнэ:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# ХАРАГДАХГҮЙ
#
# convert one remaining old outbreak row to missing for ease
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# БАГАНУУДЫГ ЭКСПОРТЛОХОД БЭЛДЭЖ ЭРЭМБЭЛ
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# ЦЭВЭРЛЭГДСЭНLINELIST ФАЙЛЫГ "DATA" ХАВТАСТ ЭКСПОРТЛОХ
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"), overwrite = TRUE)
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cleaning.Rmd-->


# Огноотой ажиллах нь

Placeholder


## Бэлтгэл
### Багцуудыг ачаалах {.unnumbered}
### Import data {.unnumbered}
## Current date
## Convert to Date
### **base** R {.unnumbered}
### **lubridate** {.unnumbered}
### Combine columns {.unnumbered}
## Excel dates
## Messy dates
## Working with date-time class
### Convert dates with times {.unnumbered}
### Convert times alone {.unnumbered}
### Extract time {.unnumbered}
## Working with dates
### Extract date components {.unnumbered}
### Date math {.unnumbered}
### Date intervals {.unnumbered}
## Date display
### `format()` {.unnumbered}
### Month-Year {.unnumbered}
## Epidemiological weeks {#dates_epi_wks}
### **lubridate** {.unnumbered}
### Weekly counts {.unnumbered}
### Epiweek alternatives {.unnumbered}
## Converting dates/time zones
## Lagging and leading calculations
## Resources

<!--chapter:end:new_pages/dates.Rmd-->


# Characters and strings { }  

Placeholder


## Preparation { }
### Load packages {.unnumbered}  
### Import data  {.unnumbered}  
## Unite, split, and arrange { }
### Combine strings {.unnumbered}
### Dynamic strings {.unnumbered}
### Unite columns  {#str_unite .unnumbered}
### Split {.unnumbered}  
### Split columns {.unnumbered}  
### Arrange alphabetically {.unnumbered} 
### base R functions {.unnumbered}
## Clean and standardise  
### Change case {.unnumbered}
### Pad length  {#str_pad .unnumbered}
### Truncate {.unnumbered} 
### Standardize length {.unnumbered}
### Remove leading/trailing whitespace {.unnumbered}  
### Remove repeated whitespace within {.unnumbered}  
### Wrap into paragraphs {.unnumbered}  
## Handle by position { }
### Extract by character position {.unnumbered}  
### Extract by word position {.unnumbered} 
### Replace by character position {.unnumbered} 
### Evaluate length  {.unnumbered}
## Patterns { }
### Detect a pattern {.unnumbered}
#### Convert commas to periods {.unnumbered}  
### Replace all {.unnumbered}  
### Detect within logic {.unnumbered}
### Locate pattern position {.unnumbered}  
### Extract a match {.unnumbered}  
### Subset and count {.unnumbered}  
### Regex groups {.unnumbered}
## Special characters  
## Regular expressions (regex) 
## Regex and special characters { } 
## Resources { }

<!--chapter:end:new_pages/characters_strings.Rmd-->


# Factors {}

Placeholder


## Preparation  
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
### New categorical variable {#fct_newcat .unnumbered}  
#### Create column {.unnumbered}  
#### Default value order {.unnumbered}  
## Convert to factor  
## Add or drop levels  
### Add {#fct_add .unnumbered}
### Drop {.unnumbered}  
## Adjust level order {#fct_adjust} 
### Manually {.unnumbered} 
### Within a plot {.unnumbered}  
### Reverse {.unnumbered}  
### By frequency {.unnumbered}  
### By appearance {.unnumbered}  
### By summary statistic of another column {.unnumbered}  
### By "end" value {.unnumbered}  
## Missing values {#fct_missing}  
## Combine levels  
### Manually {.unnumbered}  
### Reduce into "Other" {.unnumbered}  
### Reduce by frequency {.unnumbered}
## Show all levels  
### In plots {.unnumbered}  
### In tables {.unnumbered}  
## Epiweeks  
### Epiweeks in a plot {.unnumbered}  
### Epiweeks in the data {.unnumbered}  
## Resources {} 

<!--chapter:end:new_pages/factors.Rmd-->


# Pivoting data {}

Placeholder


## Preparation  
### Load packages {.unnumbered}  
### Import data {.unnumbered}
### Malaria count data {-}  
### Linelist case data {-}  
## Wide-to-long {}
### "Wide" format {.unnumbered}
### `pivot_longer()` {.unnumbered}
### Standard pivoting {.unnumbered}  
### Pivoting data of multiple classes {.unnumbered}
## Long-to-wide {}
### Data {.unnumbered}
### Pivot wider {.unnumbered}  
## Fill 
### Data {.unnumbered}
### `fill()` {.unnumbered}
## Resources  

<!--chapter:end:new_pages/pivoting.Rmd-->


# Grouping data { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered}  
### Import data {.unnumbered}
## Grouping {  }
### Unique groups {.unnumbered}  
### New columns {.unnumbered} 
### Add/drop grouping columns {.unnumbered}  
## Un-group  
## Summarise {#group_summarise} 
## Counts and tallies  
### `tally()` {.unnumbered}  
### `count()`  {.unnumbered}  
### Add counts {.unnumbered}  
### Add totals {.unnumbered} 
## Grouping by date  
### Linelist cases into days  {.unnumbered}  
### Linelist cases into weeks {.unnumbered}  
### Linelist cases into months {.unnumbered}
### Daily counts into weeks {.unnumbered}
#### Daily counts into months {.unnumbered}
## Arranging grouped data
## Filter on grouped data
### `filter()` {.unnumbered}
### Slice rows per group {.unnumbered} 
### Filter on group size {#group_filter_grp_size .unnumbered} 
## Mutate on grouped data  
## Select on grouped data  
## Resources {  }

<!--chapter:end:new_pages/grouping.Rmd-->


# Joining data { }  

Placeholder


## Preparation { }
### Load packages {.unnumbered}
### Import data {.unnumbered}
### Example datasets {.unnumbered}
#### "Miniature" case linelist {#joins_llmini .unnumbered}  
#### Hospital information data frame {#joins_hosp_info .unnumbered}  
### Pre-cleaning {.unnumbered}
## **dplyr** joins { }
### General syntax {.unnumbered}
### Left and right joins {.unnumbered}  
#### "Should I use a right join, or a left join?" {.unnumbered}  
### Full join {.unnumbered} 
### Inner join {.unnumbered} 
### Semi join {.unnumbered} 
### Anti join {.unnumbered} 
#### Simple `anti_join()` example {.unnumbered}  
#### Complex `anti_join()` example {.unnumbered}  
## Probabalistic matching { }
### Probabilistic matching {.unnumbered}  
### Probabilistic deduplication {.unnumbered}  
## Binding and aligning  
### Bind rows {.unnumbered}
### Bind columns {.unnumbered}
#### Use `match()` to align ordering {.unnumbered}  
## Resources { }

<!--chapter:end:new_pages/joining_matching.Rmd-->


# De-duplication {}  

Placeholder


## Preparation { }
### Load packages {.unnumbered}
### Import data {.unnumbered}
#### Here is the data frame {#dedup_data .unnumbered}  
## Deduplication { }
### Examine duplicate rows {.unnumbered}  
### Keep only unique rows  {.unnumbered}
### Deduplicate elements in a vector {.unnumbered}  
### Using **base** R {.unnumbered}
## Slicing { }
### Slice with groups  {.unnumbered}
### Keep all but mark them  {.unnumbered}
### Calculate row completeness {.unnumbered} 
## Roll-up values {#str_rollup}
### Roll-up values into one row {.unnumbered}  
### Overwrite values/hierarchy {.unnumbered} 
## Probabilistic de-duplication  
## Resources { }

<!--chapter:end:new_pages/deduplication.Rmd-->


# Iteration, loops, and lists { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
## *for loops* {  }
### *for loops* in R {#iter_loops .unnumbered}  
### Core components {.unnumbered}   
### Sequence {.unnumbered}  
### Operations  {.unnumbered}  
### Container {.unnumbered}
### Printing {.unnumbered}  
### Testing your for loop {.unnumbered}
### Looping plots {.unnumbered}
### Tracking progress of a loop {.unnumbered} 
## **purrr** and lists {#iter_purrr}
### Load packages {.unnumbered}  
### `map()` {.unnumbered}  
#### Example - import and combine Excel sheets {#iter_combined .unnumbered}  
### Split dataset and export {.unnumbered}  
#### Split dataset {.unnumbered}  
##### More than one `group_split()` column {.unnumbered}  
#### Export as Excel sheets {.unnumbered}  
#### Export as CSV files {.unnumbered}  
### Custom functions {.unnumbered}  
### Mapping a function across columns {.unnumbered}  
### Extract from lists {.unnumbered}  
#### Names of elements {.unnumbered}  
#### Elements by name or position {.unnumbered}  
#### `pluck()` {.unnumbered}  
### Convert list to data frame {.unnumbered}  
### Discard, keep, and compact lists {.unnumbered}  
### `pmap()` {.unnumbered}
## Apply functions  
## Resources { }

<!--chapter:end:new_pages/iteration.Rmd-->

# (PART) Analysis {.unnumbered}

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_analysis.Rmd-->


# Descriptive tables { }

Placeholder


## Preparation {  }
### Load packages {.unnumbered}
### Import data {.unnumbered}
## Browse data {  }
### **skimr** package {.unnumbered}
### Summary statistics {.unnumbered} 
## **janitor** package {#tbl_janitor}  
### Simple tabyl {.unnumbered}  
### Cross-tabulation {.unnumbered}  
### "Adorning" the tabyl {#tbl_adorn .unnumbered}  
### Printing the tabyl {.unnumbered}
### Use on other tables {.unnumbered}  
### Saving the tabyl {.unnumbered}  
### Statistics {#janitor_age_out_stats .unnumbered}  
### Other tips {.unnumbered}  
## **dplyr** package   
### Get counts {.unnumbered}  
### Show all levels {.unnumbered}  
### Proportions {#tbl_dplyr_prop .unnumbered}  
### Plotting {.unnumbered}  
### Summary statistics {.unnumbered}  
### Conditional statistics {.unnumbered}  
### Glueing together {.unnumbered}  
#### Percentiles {.unnumbered}  
### Summarise aggregated data {.unnumbered}  
### `across()` multiple columns {.unnumbered}  
### Pivot wider {#tbls_pivot_wider .unnumbered}
### Total rows {#tbl_dplyr_totals .unnumbered}  
#### **janitor**'s `adorn_totals()` {.unnumbered}  
#### `summarise()` on "total" data and then `bind_rows()` {.unnumbered}  
## **gtsummary** package {#tbl_gt}   
### Summary table {.unnumbered}
### Adjustments {.unnumbered}  
### Multi-line stats for continuous variables {.unnumbered}  
## **base** R   
### Proportions {.unnumbered}  
### Totals {.unnumbered}  
### Convert to data frame {.unnumbered}  
## Resources {  }

<!--chapter:end:new_pages/tables_descriptive.Rmd-->


# Simple statistical tests { }

Placeholder


## Preparation {  }
### Load packages {.unnumbered}
### Import data {.unnumbered}
## **base** R {}
### T-tests {.unnumbered} 
### Shapiro-Wilk test {.unnumbered}  
### Wilcoxon rank sum test {.unnumbered}
### Kruskal-Wallis test {.unnumbered}
### Chi-squared test {.unnumbered} 
## **rstatix** package {}
### Summary statistics {.unnumbered}  
### T-test {.unnumbered}  
### Shapiro-Wilk test {.unnumbered}  
### Wilcoxon rank sum test {.unnumbered}  
### Kruskal-Wallis test {.unnumbered}  
### Chi-squared test {.unnumbered}  
## `gtsummary` package {#stats_gt}
### Chi-squared test {.unnumbered}
### T-tests {.unnumbered} 
### Wilcoxon rank sum test{.unnumbered}
### Kruskal-wallis test {.unnumbered}
## Correlations 
## Resources {  }

<!--chapter:end:new_pages/stat_tests.Rmd-->


# Univariate and multivariable regression { }

Placeholder


## Preparation {  }
### Load packages {.unnumbered}
### Import data {.unnumbered}
### Clean data {.unnumbered}
#### Store explanatory variables {.unnumbered}  
#### Convert to 1's and 0's  {.unnumbered}   
#### Drop rows with missing values {.unnumbered}  
## Univariate {  }
### **base** R {.unnumbered}
#### Linear regression {.unnumbered}  
#### Logistic regression {.unnumbered}  
#### Univariate `glm()` {.unnumbered}
#### Printing results {.unnumbered}
#### Looping multiple univariate models {.unnumbered}  
### **gtsummary** package {#reg_gt_uni .unnumbered}
## Stratified {  }
## Multivariable  
### Conduct multivariable {.unnumbered}  
#### Building the model {.unnumbered}  
### Combine univariate and multivariable {.unnumbered}
#### Combine with **gtsummary**  {.unnumbered}  
#### Combine with **dplyr** {.unnumbered}  
## Forest plot {  }
### **ggplot2** package {.unnumbered}
### **easystats** packages {.unnumbered}
## Resources {  }

<!--chapter:end:new_pages/regression.Rmd-->


# Missing data { }

Placeholder


## Preparation { }
### Load packages {.unnumbered}  
### Import data {.unnumbered}
### Convert missing on import {.unnumbered}  
## Missing values in R { }
### `NA` {.unnumbered}  
### Versions of `NA` {.unnumbered}  
### `NULL` {.unnumbered}  
### `NaN` {.unnumbered}  
### `Inf` {.unnumbered}  
### Examples {.unnumbered}  
## Useful functions { }
### `is.na()` and `!is.na()` {.unnumbered}  
### `na.omit()` {.unnumbered}  
### `drop_na()` {.unnumbered}  
### `na.rm = TRUE` {.unnumbered}  
## Assess missingness in a data frame { }
### Quantifying missingness {.unnumbered}
### Visualizing missingness {.unnumbered}  
### Explore and visualize missingness relationships {.unnumbered} 
### "Shadow" columns {.unnumbered}
## Using data with missing values  
### Filter out rows with missing values {.unnumbered}
### Handling `NA` in `ggplot()` {.unnumbered}
### `NA` in factors {.unnumbered}
## Imputation { }
### Types of missing data {.unnumbered}
### Useful packages {.unnumbered}
### Mean Imputation {.unnumbered}
### Regression imputation {.unnumbered}
### LOCF and BOCF {.unnumbered}
### Multiple Imputation {.unnumbered}
## Resources { }

<!--chapter:end:new_pages/missing_data.Rmd-->


# Standardised rates { }  

Placeholder


## Overview  
## Preparation {  }
### Load packages {.unnumbered}
### Load population data {.unnumbered}  
### Load death counts {.unnumbered}  
### Clean populations and deaths {.unnumbered}  
### Load reference population {.unnumbered}  
### Clean reference population {.unnumbered}
### Create dataset with standard population {#standard_all .unnumbered}  
## **dsr** package {  }
### Standardized rates {.unnumbered}
### Standardized rate ratios {.unnumbered}
### Standardized rate difference {.unnumbered}
## **PHEindicatormethods** package {#standard_phe  }
### Directly standardized rates {.unnumbered}
### Indirectly standardized rates {#standard_indirect .unnumbered}
## Resources {  }

<!--chapter:end:new_pages/standardization.Rmd-->


# Moving averages { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered}
### Import data {.unnumbered}
## Calculate with **slider** {  }
### Rolling by date  {#roll_index .unnumbered}  
### Indexed data {.unnumbered}  
### Rolling by group {#roll_slider_group .unnumbered}  
## Calculate with **tidyquant** within `ggplot()` {  }
## Resources {  }

<!--chapter:end:new_pages/moving_average.Rmd-->


# Time series and outbreak detection { }  

Placeholder


## Overview {  }
## Preparation {  }
### Packages {.unnumbered}
### Load data {.unnumbered}
### Clean data {.unnumbered}
### Download climate data {.unnumbered} 
### Load climate data {.unnumbered}
## Time series data {  }
### Duplicates {.unnumbered}
### Missings {.unnumbered}
## Descriptive analysis {  }
### Moving averages {#timeseries_moving .unnumbered}
### Periodicity {.unnumbered}
### Decomposition {.unnumbered}
### Autocorrelation {.unnumbered}
## Fitting regressions {  }
### Fourier terms {.unnumbered}
### Negative binomial {.unnumbered}
### Residuals {.unnumbered}
## Relation of two time series {  }
### Merging datasets {.unnumbered}
### Descriptive analysis {.unnumbered}
### Lags and cross-correlation {.unnumbered}
### Negative binomial with two variables {.unnumbered}
#### Residuals {.unnumbered}
## Outbreak detection {  }
### **trending** package {.unnumbered}
#### Cut-off date { -}
#### Add rows {.unnumbered}
#### Fourier terms {.unnumbered}
#### Split data and fit regression {.unnumbered}
#### Prediction validation {.unnumbered}
### **surveillance** package {.unnumbered}
#### Farrington method {.unnumbered}
#### GLRNB method {.unnumbered}
## Interrupted timeseries {  }
## Resources {  }

<!--chapter:end:new_pages/time_series.Rmd-->


# Epidemic modeling { }  

Placeholder


## Overview {  }
## Preparation {  }
## Estimating R<sub>t</sub> {  }
### EpiNow2 vs. EpiEstim {.unnumbered}
### EpiNow2 {.unnumbered}
#### Estimating delay distributions {.unnumbered}
#### Running **EpiNow2** {.unnumbered}
#### Analysing outputs {.unnumbered}
### EpiEstim {.unnumbered}
#### Using serial interval estimates from the literature {.unnumbered}
#### Using serial interval estimates from the data {.unnumbered}
#### Specifying estimation time windows {.unnumbered}
#### Analysing outputs {.unnumbered}
## Projecting incidence {  }
### EpiNow2 {.unnumbered}
### projections {.unnumbered}
#### Using serial interval estimates from the literature {.unnumbered}
#### Using serial interval estimates from the data {.unnumbered}
#### Projecting incidence {.unnumbered}
## Resources {  }

<!--chapter:end:new_pages/epidemic_models.Rmd-->


# Contact tracing { }

Placeholder


## Preparation
### Load packages {.unnumbered}  
### Import data {.unnumbered}
#### Case data {.unnumbered}  
#### Contacts data {.unnumbered}  
#### Follow-up data {.unnumbered}  
#### Relationships data {.unnumbered}  
## Descriptive analyses  
### Demographics {.unnumbered}  
#### Age and Gender of contacts {.unnumbered}  
### Contacts per case {.unnumbered}  
## Contact Follow Up  
### Data cleaning {.unnumbered}  
### Plot over time {.unnumbered}  
### Daily individual tracking  {.unnumbered}  
### Analyse by group {.unnumbered}  
## KPI Tables  
## Transmission Matrices  
## Resources  

<!--chapter:end:new_pages/contact_tracing.Rmd-->


# Survey analysis { }  

Placeholder


## Overview {  }
## Preparation {  }
### Packages {.unnumbered}
### Load data {.unnumbered}
### Clean data {.unnumbered}
## Survey data {  }
## Observation time {  }
## Weighting {  }
## Survey design objects {  }
### **Survey** package  
### **Srvyr** package  
## Descriptive analysis {  }
### Sampling bias 
### Demographic pyramids 
### Alluvial/sankey diagram
## Weighted proportions {  }
### **Survey** package 
### **Srvyr** package 
### **Sitrep** package 
### **Gtsummary** package
## Weighted ratios {  }
### **Survey** package 
### **Srvyr** package 
## Resources {  }

<!--chapter:end:new_pages/survey_analysis.Rmd-->


# Survival analysis { }  

Placeholder


## Overview {}
## Preparation {  }
### Load packages {.unnumbered}  
### Import dataset {.unnumbered}  
### Data management and transformation {.unnumbered}
## Basics of survival analysis {}
### Building a surv-type object {.unnumbered}
### Running initial analyses {.unnumbered}
### Cumulative hazard {.unnumbered}  
### Plotting Kaplan-Meir curves  {.unnumbered}
## Comparison of survival curves 
### Log rank test {.unnumbered}
## Cox regression analysis {}
### Fitting a Cox model {.unnumbered}
### Forest plots {.unnumbered}
## Time-dependent covariates in survival models {}
### Time-dependent covariate setup {.unnumbered} 
#### Add unique patient identifier {.unnumbered}  
#### Expand patient rows {.unnumbered}  
### Cox regression with time-dependent covariates {.unnumbered} 
## Resources {  }

<!--chapter:end:new_pages/survival_analysis.Rmd-->


# GIS basics { }  

Placeholder


## Overview {  }
## Key terms {}  
### GIS software {.unnumbered}
### Spatial data {.unnumbered}
### Visualizing spatial data {.unnumbered}
## Getting started with GIS  
### Types of maps for visualizing your data {.unnumbered}
## Preparation {  }
### Load packages {.unnumbered}  
### Sample case data {.unnumbered}
### Admin boundary shapefiles {.unnumbered}  
### Population data {.unnumbered}  
### Health Facilities {.unnumbered}
## Plotting coordinates {  }
## Spatial joins {}
### Points in polygon {.unnumbered}
### Nearest neighbor {.unnumbered}
### Buffers {.unnumbered} 
### Other spatial joins {.unnumbered}  
## Choropleth maps {}  
## Mapping with ggplot2
## Basemaps { }
### OpenStreetMap {.unnumbered} 
## Contoured density heatmaps {}
### Time series heatmap {.unnumbered}
## Spatial statistics
### Spatial relationships {.unnumbered}  
### Spatial autocorrelation {.unnumbered}  
### Spatial regression {.unnumbered}  
## Resources {  }

<!--chapter:end:new_pages/gis.Rmd-->

# (PART) Data Visualization {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_viz.Rmd-->


# Tables for presentation { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered} 
### Import data {.unnumbered}  
### Prepare table {.unnumbered}  
## Basic flextable {  }
### Create a flextable {.unnumbered}  
### Column width {.unnumbered}
### Column headers {.unnumbered}
### Borders and background {.unnumbered}  
### Font and alignment {.unnumbered}
### Merge cells {.unnumbered}  
### Background color {.unnumbered}
## Conditional formatting {  }
## All code together {#tbl_pres_all}  
## Saving your table {  }
### Save single table {.unnumbered}
### Print table in R markdown {.unnumbered}  
## Resources {  }

<!--chapter:end:new_pages/tables_presentation.Rmd-->


# ggplot basics {}

Placeholder


## Preparation {}
### Load packages {.unnumbered}
### Import data {.unnumbered}  
### General cleaning {.unnumbered}
### Pivoting longer {.unnumbered}
## Basics of ggplot {}
## `ggplot()`  
## Geoms  
## Mapping data to the plot {#ggplot_basics_mapping}  
### Plot aesthetics {.unnumbered}  
### Set to a static value {.unnumbered}  
### Scaled to column values {.unnumbered}  
### Where to make mapping assignments {#ggplot_basics_map_loc .unnumbered}
### Groups {#ggplotgroups .unnumbered}  
## Facets / Small-multiples {#ggplot_basics_facet}  
### `facet_wrap()` {.unnumbered}
### `facet_grid()` {.unnumbered}  
### Free or fixed axes {.unnumbered}  
### Factor level order in facets {.unnumbered}  
## Storing plots  
### Saving plots {.unnumbered}
### Modifying saved plots {.unnumbered}  
### Exporting plots {.unnumbered}   
## Labels 
## Themes {#ggplot_basics_themes} 
### Complete themes {.unnumbered}  
### Modify theme {.unnumbered}  
## Colors  
## Piping into **ggplot2**   
## Plot continuous data
### Histograms {.unnumbered}
### Box plots {.unnumbered}
### Violin, jitter, and sina plots {.unnumbered}
### Two continuous variables  {.unnumbered}
### Three continuous variables {.unnumbered}  
## Plot categorical data  
### Preparation  {.unnumbered}
#### Data structure {.unnumbered}  
#### Column class and value ordering {.unnumbered}  
### `geom_bar()` {#ggplot_basics_bars .unnumbered}  
### `geom_col()` {.unnumbered}  
### `geom_histogram()` {.unnumbered}  
## Resources  

<!--chapter:end:new_pages/ggplot_basics.Rmd-->


# ggplot tips {}

Placeholder


## Preparation {}
### Load packages {.unnumbered}
### Import data {.unnumbered}  
## Scales for color, fill, axes, etc. {#ggplot_tips_colors}
### Color schemes
### Scales {#ggplot_tips_scales .unnumbered}  
### Scale arguments {.unnumbered}  
### Manual adjustments {.unnumbered}  
### Continuous axes scales {.unnumbered}  
#### Display percents {.unnumbered}  
#### Log scale {.unnumbered}  
### Gradient scales {.unnumbered}  
### Palettes {.unnumbered}  
#### Colorbrewer and Viridis {.unnumbered}
## Change order of discrete variables {}  
#### **ggthemr** {.unnnumbered}  
## Contour lines  
## Marginal distributions  
## Smart Labeling {}  
## Time axes {}
## Highlighting {}
## Plotting multiple datasets  
## Combine plots {}
### `plot_grid()` {.unnumbered}
### Combine legends {.unnumbered}  
### Inset plots {.unnumbered} 
## Dual axes {}
## Packages to help you  
### Point-and-click **ggplot2** with **equisse**  {.unnumbered}
## Miscellaneous  
### Numeric display {.unnumbered}  
## Resources

<!--chapter:end:new_pages/ggplot_tips.Rmd-->


# Epidemic curves { }  

Placeholder


## Preparation
### Packages {.unnumbered}  
### Import data {.unnumbered}
### Set parameters {.unnumbered}
### Verify dates {.unnumbered}
## Epicurves with **incidence2** package { }
### Simple example {.unnumbered}
### Change time interval of case aggregation {.unnumbered}  
### Groups {.unnumbered}
### Filtered data {.unnumbered}
### Aggregated counts {.unnumbered}
### Facets/small multiples {.unnumbered}  
### Modifications with `plot()` {.unnumbered} 
### Modifications with ggplot2 {.unnumbered}
### Change colors  {.unnumbered}  
#### Specify a palette {.unnumbered}  
#### Specify manually {.unnumbered}  
### Adjust level order {.unnumbered}  
### Vertical gridlines {.unnumbered}  
### Cumulative incidence {.unnumbered}  
### Rolling average  {.unnumbered}
## Epicurves with ggplot2 { }
### Specify case bins {.unnumbered}  
### Weekly epicurve example {.unnumbered}  
#### Sunday weeks {.unnumbered}  
### Group/color by value {.unnumbered}
### Adjust colors {.unnumbered}  
### Adjust level order {.unnumbered}  
### Adjust legend {.unnumbered}
### Bars side-by-side {.unnumbered}  
### Axis limits {.unnumbered}  
### Date-axis labels/gridlines {.unnumbered} 
#### Demonstrations {.unnumbered}
### Aggregated data {.unnumbered} 
#### Plotting daily counts {.unnumbered}  
#### Plotting weekly counts {.unnumbered}
### Moving averages {.unnumbered}
### Faceting/small-multiples {.unnumbered}
#### Total epidemic in facet background {.unnumbered}
#### One facet with data {.unnumbered}  
## Tentative data  
### Using `annotate()` {.unnumbered}
### Bars color {.unnumbered}  
## Multi-level date labels  
## Dual-axis { }  
## Cumulative Incidence {}
## Resources { }

<!--chapter:end:new_pages/epicurves.Rmd-->


# Demographic pyramids and Likert-scales {}  

Placeholder


## Preparation {}
### Load packages {.unnumbered}
### Import data {.unnumbered}  
### Cleaning {.unnumbered}  
## **apyramid** package {}
### Linelist data {.unnumbered}  
#### Missing values {.unnumbered}  
#### Proportions, colors, & aesthetics {.unnumbered}  
### Aggregated data {.unnumbered}  
## `ggplot()` {#demo_pyr_gg}
### Preparation {.unnumbered}
### Constructing the plot {.unnumbered} 
### Compare to baseline  {.unnumbered} 
## Likert scale {}
## Resources {}

<!--chapter:end:new_pages/age_pyramid.Rmd-->


# Heat plots { }  

Placeholder


## Preparation { }
### Load packages {.unnumbered}  
## Transmission matrix  
### Data preparation {.unnumbered}  
#### Make cases data frame {.unnumbered} 
#### Make infectors data frame {.unnumbered}  
### Create heat plot {.unnumbered}  
## Reporting metrics over time { }
### Data preparation {.unnumbered}
#### Aggregate and summarize {.unnumbered}
### Create heat plot {.unnumbered}
### Basic {.unnumbered}  
### Cleaned plot {.unnumbered}
### Ordered y-axis {.unnumbered}  
### Display values {.unnumbered}  
## Resources { }

<!--chapter:end:new_pages/heatmaps.Rmd-->


# Diagrams and charts { }  

Placeholder


## Preparation { }
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
## Flow diagrams { }
### Simple examples {.unnumbered} 
### Syntax  {.unnumbered}
### Complex examples  {.unnumbered}
### Outputs  {.unnumbered}
### Parameterized figures {.unnumbered} 
## Alluvial/Sankey Diagrams { }
### Load packages {.unnumbered}  
### Plotting from dataset {.unnumbered} 
## Event timelines { }
## DAGs { }
## Resources { }

<!--chapter:end:new_pages/diagrams.Rmd-->


# Combinations analysis { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered}
### Import data {.unnumbered}  
### Re-format values {.unnumbered}  
## **ggupset** {  }
## `UpSetR` {  }
## Resources {  }

<!--chapter:end:new_pages/combination_analysis.Rmd-->


# Transmission chains { }

Placeholder


## Overview {  }
## Preparation {  }
### Load packages {.unnumbered}  
### Import data {.unnumbered}
### Creating an epicontacts object {.unnumbered}
## Handling {  }
### Subsetting {.unnumbered}
### Accessing IDs {.unnumbered}
## Visualization {  }
### Basic plotting {.unnumbered}
#### Visualising node attributes {.unnumbered}
#### Visualising edge attributes {.unnumbered}
### Temporal axis {.unnumbered}
#### Specifying transmission tree shape {.unnumbered}
#### Saving plots and figures {.unnumbered}
### Timelines {.unnumbered}
## Analysis {  }
### Summarising {.unnumbered}
### Pairwise characteristics {.unnumbered}
### Identifying clusters {.unnumbered}
### Calculating degrees {.unnumbered}
## Resources {  }

<!--chapter:end:new_pages/transmission_chains.Rmd-->


# Phylogenetic trees {}  

Placeholder


## Overview {}
## Preparation {}
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
### Clean and inspect {.unnumbered}  
## Simple tree visualization {}
### Different tree layouts {.unnumbered}  
### Simple tree plus sample data {.unnumbered}  
## Tree manipulation {}
### Zoom in {.unnumbered}  
### Collapsing branches {.unnumbered} 
### Subsetting a tree {.unnumbered} 
### Rotating nodes in a tree {.unnumbered} 
### Example subtree with sample data annotation {.unnumbered} 
## More complex trees: adding heatmaps of sample data {.unnumbered}
## Resources {}

<!--chapter:end:new_pages/phylogenetic_trees.Rmd-->


# Interactive plots { }  

Placeholder


## Preparation {  }
### Load packages {.unnumbered}  
### Start with a `ggplot()` {.unnumbered}  
### Import data {.unnumbered}
## Plot with `ggplotly()` {  }
## Modifications {  }
### File size {.unnumbered}  
### Buttons {.unnumbered}  
## Heat tiles {  }
## Resources {  }

<!--chapter:end:new_pages/interactive_plots.Rmd-->

# (PART) Reports and dashboards {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_reports_dashboards.Rmd-->


# Reports with R Markdown { }  

Placeholder


## Preparation {  }
## Getting started {  }
### Install rmarkdown R package {.unnumbered}
### Starting a new Rmd file {.unnumbered}
### Important to know {.unnumbered}
## R Markdown components {  }
### YAML metadata {.unnumbered}
### Text {.unnumbered}
#### New lines {.unnumbered}  
#### Case {.unnumbered}  
#### Color {.unnumbered}  
#### Titles and headings {.unnumbered}  
#### Bullets and numbering {.unnumbered}  
#### Comment out text {.unnumbered}
### Code chunks {.unnumbered}
#### In-text R code {.unnumbered}  
### Images {.unnumbered}  
### Tables {.unnumbered}  
### Tabbed sections {.unnumbered}  
## File structure {}
### Self-contained Rmd {.unnumbered}  
#### Source other files {.unnumbered}
### Runfile {.unnumbered}  
### Folder strucutre {.unnumbered}  
## Producing the document  
### Option 1: "Knit" button {.unnumbered}  
### Option 2: `render()` command {.unnumbered}
###  Options 3: **reportfactory**  package {.unnumbered}  
## Parameterised reports {  }
### Setting parameters {.unnumbered}
#### Option 1: Set parameters within YAML {.unnumbered}
#### Option 2: Set parameters within `render()` {.unnumbered}  
#### Option 3: Set parameters using a Graphical User Interface {.unnumbered}  
### Parameterized example {.unnumbered} 
### Parameterisation without `params` {.unnumbered}
## Looping reports  {  }
## Templates  
### Word documents {.unnumbered}
### Powerpoint documents {.unnumbered}
### Integrating templates into the YAML {.unnumbered}
### Formatting HTML files {.unnumbered}
## Dynamic content  
### Tables {.unnumbered}  
### HTML widgets {.unnumbered}
## Resources {  }

<!--chapter:end:new_pages/rmarkdown.Rmd-->


# Organizing routine reports {  }  

Placeholder


## Preparation
### Load packages {.unnumbered}  
## New factory  
## Create a report  
## Compile  
### Compile by name {.unnumbered}  
### Compile by number {.unnumbered}
### Compile all {.unnumbered}
### Compile from sub-folder {.unnumbered}  
### Parameterization {.unnumbered}
### Using a "run-file" {.unnumbered}  
## Outputs  
## Miscellaneous  
### Knit {.unnumbered} 
### Scripts {.unnumbered}  
### Extras {.unnumbered} 
## Resources {  }

<!--chapter:end:new_pages/reportfactory.Rmd-->


# Dashboards with R Markdown { }

Placeholder


## Preparation
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
## Create new R Markdown  
## The script  
### YAML {.unnumbered}  
### Code chunks {.unnumbered}  
### Narrative text {.unnumbered}  
### Headings {.unnumbered}  
## Section attributes  
## Layout {#layout}  
### Pages {.unnumbered}  
### Orientation {.unnumbered}  
### Tabs {.unnumbered} 
## Adding content  
### Text {.unnumbered}  
### Tables {.unnumbered}  
### Plots {.unnumbered}  
### Interactive plots {.unnumbered}  
### HTML widgets {.unnumbered}
## Code organization
## Shiny  
### Settings {.unnumbered}  
### Worked example {.unnumbered}  
### Other examples {.unnumbered}  
## Sharing  
## Resources  

<!--chapter:end:new_pages/flexdashboard.Rmd-->


# Dashboards with Shiny { }  

Placeholder


## Preparation  
### Load packages {.unnumbered}  
### Import data {.unnumbered}  
## The structure of a shiny app {  }
### Basic file structures {.unnumbered}  
### The server and the ui {.unnumbered}
### Before you start to build an app {.unnumbered}
## Building a UI 
## Loading data into our app
## Developing an app server
## Adding more functionality
### Adding static text {.unnumbered}  
### Adding a link {.unnumbered}
### Adding a download button {.unnumbered}
### Adding a facility selector {.unnumbered}  
### Adding another tab with a table {.unnumbered}
## Sharing shiny apps
## Further reading
## Recommended extension packages
## Recommended resources

<!--chapter:end:new_pages/shiny_basics.Rmd-->

# (PART) Miscellaneous {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_misc.Rmd-->


# Writing functions  

Placeholder


## Preparation {  }
### Load packages {-}
### Import data {-}
## Functions  
## Why would you use a function? 
## How does R  build functions?
## Basic syntax and structure
## Examples  
### Return proportion tables for several columns {.unnumbered}  
## Using **purrr**: writing functions that can be iteratively applied
### Modify class of multiple columns in a dataset {.unnumbered}  
### Iteratively produce graphs for different levels of a variable {.unnumbered}
### Iteratively produce tables for different levels of a variable {.unnumbered}
## Tips and best Practices for well functioning functions
### Naming and syntax {.unnumbered}
### Column names and tidy evaluation {.unnumbered}  
### Testing and Error handling {.unnumbered}
## Resources

<!--chapter:end:new_pages/writing_functions.Rmd-->


# Directory interactions { }  

Placeholder


## Preparation  
### **fs** package {.unnumbered}  
### Print directory as a dendrogram tree {.unnumbered}  
## List files in a directory  
## File information  
## Check if exists  
### R objects {.unnumbered}  
### Directories {.unnumbered}  
### Files {.unnumbered}  
## Create  
### Directories {.unnumbered}  
### Files {.unnumbered}  
### Create if does not exists {.unnumbered}  
## Delete
### R objects {.unnumbered}  
### Directories {.unnumbered}  
### Files {.unnumbered}  
## Running other files  
### `source()` {.unnumbered}  
### `render()` {.unnumbered}  
### Run files in a directory {.unnumbered}
### Import files in a directory  {.unnumbered}
## **base** R  
## Resources {  }

<!--chapter:end:new_pages/directories.Rmd-->


# Version control and collaboration with Git and Github

Placeholder


## What is Git?
## Why use the combo Git and Github?
### This sounds complicated, I am not a programmer {-}
## Setup
### Install Git {.unnumbered}
### Install an interface (optional but recommended) {.unnumbered}
### Github account {.unnumbered}
## Vocabulary, concepts and basic functions
### Repository {.unnumbered}
### Commits {.unnumbered}
### Branches {.unnumbered}
### Local and remote repositories {.unnumbered}
## Get started: create a new repository
### Start-up files {.unnumbered}
### Create a new repository in Github {.unnumbered}
### Clone from a Github repository {.unnumbered}
#### In Rstudio {.unnumbered}
#### In Github Desktop {.unnumbered}
### New Github repo from existing R project {.unnumbered}
### What does it look like now? {.unnumbered}
#### In RStudio {-}
#### In Github Desktop {-}
## Git + Github workflow
### Process overview {.unnumbered}
## Create a new branch
### In Rstudio Git pane {.unnumbered}
### In Github Desktop {.unnumbered}
### In console {.unnumbered}
## Commit changes
### In Rstudio {.unnumbered}
### In Github Desktop {.unnumbered}
### In console {.unnumbered}
### Amend a previous commit {.unnumbered}
## Pull and push changes up to Github
#### In Rstudio {.unnumbered}
#### In Github Desktop {.unnumbered}
#### Console {.unnumbered}
### I want to pull but I have local work {.unnumbered}
## Merge branch into Main 
### Locally in Github Desktop {.unnumbered}
### In console {.unnumbered}
### In Github: submitting pull requests {.unnumbered}
### Resolving conflicts {.unnumbered}
### Delete your branch {.unnumbered}
#### Github + Rstudio
#### In Github Desktop
### Forking {.unnumbered}
## What we learned
## Git commands {#git}
### Recommended learning {.unnumbered}
### Where to enter commands {.unnumbered}
### Sample commands {.unnumbered}
## Resources

<!--chapter:end:new_pages/collaboration.Rmd-->


# Common errors  

Placeholder


## Interpreting error messages  
## Common errors  
### Typo errors {.unnumbered}  
### Package errors {.unnumbered}  
### Object errors {.unnumbered}  
### Function syntax errors {.unnumbered}
### Logic errors {.unnumbered}  
### Factor errors {.unnumbered}  
### Plotting errors {.unnumbered}  
### R Markdown errors {.unnumbered}  
### Miscellaneous {.unnumbered}  
## Resources { }

<!--chapter:end:new_pages/errors.Rmd-->


# Getting help  

Placeholder


## Github issues  
## Reproducible example  
### The **reprex** package {.unnumbered}  
### Minimal data {.unnumbered}  
## Posting to a forum  
## Resources { }

<!--chapter:end:new_pages/help.Rmd-->


# R on network drives { }  

Placeholder


## Overview {  }
## RStudio as administrator  
## Useful commands 
## Troubleshooting common errors {  }

<!--chapter:end:new_pages/network_drives.Rmd-->


# Data Table { }  

Placeholder


## Intro to data tables {  }
## Load packages and import data { }
### Load packages {.unnumbered}  
### Import data {.unnumbered}
## The i argument: selecting and filtering rows{ }
### Using helper functions for filtering {.unnumbered}  
## The j argument: selecting and computing on columns{ }
### Selecting columns {.unnumbered} 
### Computing on columns {.unnumbered} 
## The by argument: computing by groups{ }
## Adding and updating to data tables { }
## Resources {  }

<!--chapter:end:new_pages/data_table.Rmd-->

