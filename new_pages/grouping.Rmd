
# Датаг бүлэглэх { }  


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```


Энэ хуудсанд дескриптив анализэд зориулж өгөгдлийг хэрхэн бүлэглэх, нэгтгэх талаар тусгасан болно. Үүнийг гүйцэтгэхэд энгийн, хэрэглэхэд хялбар функцуудтэй **tidyverse** багцуудыг ашигладх болно.


Датаг бүлэглэх үйлдэл бол дата менежмент, дата дүн шинжилгээний үндсэн элэмент мөн. Датаг статистикийн үзүүлэлтээр бүлэглэн шинжилж, график зураглалыг бүлгээр нь тус бүр харуулдаг.**dplyr**  багцын (**tidyverse** харьяа ) функцууд бүлэглэх болон үүнтэй холбоотой бусад үйлдлүүдийг гүйцэтгэхэд хялбар болгодог.  

Энэхүү хуудаст дараах сэдвүүдийн талаар оруулсан:  

* `group_by()` функцээр бүлэглэгдсэн дата 
* Датандах бүлгийг задлах 
* бүлэглэсэн датаг функцээр `summarise()` статистикийн үзүүлэлтүүдийг харуулах  
* `count()` болон `tally()` функцуудын ялгаа
* Бүлэглэсэн датанд `arrange()` -ыг хэрэглэх 
*  Бүлэглэсэн датанд `filter()` -ыг хэрэглэх  
*  Бүлэглэсэн датанд `mutate()` -ыг хэрэглэх 
*  Бүлэглэсэн датанд `select()` -ыг хэрэглэх  
* **base** R -ын `aggregate()` коммандыг хэрэглэх



<!-- ======================================================= -->
## Бэтгэл {  }
     
### Багцыг ачааллах {.unnumbered}  
     
Энэ хэсэгт анализ хийхэд шаардлагатай багцуудыг доорхи кодоор ачааллана.**pacman** багцын `p_load()` функцээр шаардлагатай багцыг татаж аваад ачааллана уу. Өмнө татаж авсан багцуудаа **base** R -ын `library()`-аар ачааллаж болно. Багцын талаарх нэмэлт мэдээллийг [R basics] хэсгээс харна уу.  


```{r}
pacman::p_load(
  rio,       # Файлыг импортлох
  here,      # Файлыг байрлуулах
  tidyverse, # датаг цэвэрлэх, янзлах, график байгуулах (dplyr-г орно)
  janitor)   # мөр, баганын нийт дүнг нэмнэ
```




### Импорт дата {.unnumbered}

Энэ хэсэгт Эболагийн дэгдэлтийн үеийн зохиомол датаг ашиглах болно. Дагаж дасгалыг ажиллах бол <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линк дээр дарж "цэвэр" linelist татаж авна уу </a> (as .rds file). Датагаа  **rio** багцын `import()` функцээр импортло (энэ функц .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг [Import and export] хуудаст нэмж тайлбарласан). 

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Эхний 50 мөр `linelist`:  

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Бүлэглэх {  }
     
**dplyr** -ын `group_by()` функц зааж өгсөн багана дах өвөрмөц утгын дагуу мөрүүдийг бүлэглэх болно. Ингэхдээ олон багана зааж өгвөл, мөрүүд эдгээр багануудын хооронд үүссэн өвөрмөц комбинацын дагуу бүлэглэгдэх болно.  Өвөрмөц утга болгон (комбинац болгон) бүлэг бий болгоно. Ингэсний датанд хийгдэх аливаа өөрчлөлт, тооцоо зэрэг нь бүлэг тус бүрээр хийгдэх болно. 

Жишээлбэл дараах коммандаар `linelist` хүснэгтийн  `outcome` баганын утгуудаар мөрүүдийг бүлэглэсэн байна. Үүний дүнд үүсэх хүснэгтийг`ll_by_outcome`-д хадгалсан. Бүлэглэх багануудыг  `group_by()` функцэд хаалтан дотор бичнэ.  

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

`group_by()`коммандыг өгснөөр **датанд мэдэгдэхүйц өөрчлөлт гарахгүй**. Харин энэхүү бүлэглэсэн датанд `mutate()`, `summarise()`, `arrange()` зэрэг **dplyr**-ын бусад функцыг уншуулсны *дараа* өөрчлөлт хийгдэж эхэлдэг болохыг анхаар.

Гэхдээ хүснэгтийг хэвлэснээр бүлэглэсэн датаг *харж* болно. Хэвлээд үзвэл хүснэгт tibble хэлбэрт орсон байх ба [`tibble` class object](https://tibble.tidyverse.org/) ямар бүлгүүд, хэд бүлэглэгдсэн зэрэг мэдээлэл толгой мөрний дээр бичигдсэн байдаг.  

```{r}
# идвэхитэй ямар бүлгүүд байгааг хэвлэж хар
ll_by_outcome
```


### Өвөрмөц бүлгүүд {.unnumbered}  

**Бүлэг үүсгэж багануудын утгууд солбиж нэгдэн бүрдүүлсэн өвөрмөц комбинац болгон бүлэг юм**.

Үүссэн бүлэг *болон бүлэг тус бүрт хамрах мөрийн тоог * харахдаа  `tally()`функцэд баганыг оруул. Хэрэв зөвхөн үүссэн өвөрмөц бүлгүүдийн нэрсийг харах бол `group_keys()` коммандыг өг.  

Доорх жишээнд бүлэг үүсгэж буй `outcome` баганад **гурван** өвөрмөц утга байна: "Death", "Recover", `NA`. Нийт мөрийн тоо нас баралтад (deaths)` nrow(linelist %>% filter(outcome == "Death"))`, эдгэрэлтэд (recoveries)` nrow(linelist %>% filter(outcome == "Recover"))` , эмчилгээний үр дүн бичигдээгүй мөр ` nrow(linelist %>% filter(is.na(outcome)))` байсан.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```


Нэгээс дээш тооны баганыг ашиглаж бүлэглэж болно. Доор жишээнд хүснэгтийг `outcome` болон `gender` баганын дагуу бүлэглээд бүртгэлийг tally() -аар харуулсан байна. Үүнээс `outcome` болон `gender` багануудын утгууд нийлж хичнээн бүлэг үүсгэж буйг хараарай (хоёр баганын дутуу утгуудын комбинацаар үүссэн бүлгүүд мөн орно).

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### Шинэ багана {.unnumbered} 

Мөн `group_by()` *дотор* бүлэглэх шинэ баганыг оруулж бичиж болно. Энэ нь `group_by()`хийхийн өмнө `mutate()` хийхьэй адил үйлдэл юм. Богино хугацаанд бүлэглэсэн хүснэгт үүсгэх үед энэ аргыг хэрэглэх нь хялбар боловч кодоо илүү тодорхой болгох үүднээс шинээр үүсгэх баганаа тусдаа `mutate()` -аар үүсгэж араас нь `group_by()`-ыг pipe хийх нь илүү оновчтой байх болно.

```{r}
# group_by() комманд дотор үүсгэсэн binary баганын дагуу датаг бүлэглэсэн
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### Бүлэглэх баганыг нэмж/хасах {.unnumbered}  

Хэрэв өмнө нь бүлэглэсэн байсан датанд `group_by()` коммандыг уншуулахад хуучин бүлэг арилж шинэ бүлэг үүсдэг. Хэрэв хуучин бүлэг дээр нэмж бүлэг оруулах бол `.add = TRUE` аргументэд нэмж зааж өг.  

````{r, eval=F}
# outcome баганын дагуу бүлэглэгдсэн
by_outcome <- linelist %>% 
  group_by(outcome)

# gender  баганын дагуу нэмж бүлэглэ
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```


** Бүх бүлгийг үлдээх**  

Хэрэв фактор ангилалтай баганаар бүлэг үүсгэж байх явцад тухайн ангиллын аль нэг түвшинд хамрах утга датанд байхгүй байж болно. Энэ үед энэхүү хоосон түвшин хасагдаж, энэ түвшинд бүлэг үүсэхгүй. Хэрэв тухайн утга датанд байхгүй байсан ч гэсэн бүлэг болж орох шаардлагатай бол `.drop = FALSE` гэж `group_by()`-ын аргументийг тохируул. 


## Бүлгийг задлах  

Тусгайлан `ungroup()` гэсэн коммандаар задлахаас нааш бүлэг датанд оршсоор байх болно. Хэрэв бүлгийг буцааж задлахаа мартвал буруу тооцоололд хүрэх аюултай ! Доор жишээнд хэрхэн бүх бүлгийг задлахыг харуулав:  

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

Мөн тодорхой нэг баганыг `ungroup()` дотор оруулж комманд өгснөөр зөвхөн тухайн баганын бүлгийг л арилгаж болно.

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # gender-ын бүлгийг арилгаж, outcome-ын бүлэгүүдийг үлдээ
```


<span style="color: black;">**_ТЭМДЭГЛЭЛ:_**  `count()` функцыг уншуулсны дараа бүлгүүд автоматаар буцаж задардаг .</span>



## Нэгтгэх {#group_summarise} 

[Descriptive tables] хуудсын **dplyr** -ын талаар бичсэн хэсэгт `summarise()` функцээр хэрхэн хураангуй хүснэгт үүсгэх талаар илүү тайлбарласан. Энд гол тайлбарлах зүйл бол бүлэг үүсгэснээр энэ үйлдлйин хэв шинж нь хэрхэн өөрчлөгдөхийг товчхон харуулна.

**dplyr** -ын `summarise()` (эсвэл `summarize()`) функц хүснэгтэндэх датаг янзалж баганууддаа статистик дүнтэй хураагуй хүснэгтийг *шинээр* үүсгэдэг. Бүлэглээгүй датанп статистикийн дүн бүх мөрөнд тооцоолсны дүнд тавигддаг. Харин бүлэглэсэн датанд `summarise()`-ыг оруулбал статистикийн тооцоо *бүлэг тус бүрт* бодогддог.  

`summarise()` -ын синтаксыг бичихдээ эхлээд **шинэ** үүсгэх тооцооны дүнтэй баганын нэрс, тэнцүүгийн тэмдэг, датанд хийх статистикийн бодолт хийх функцыг бичнэ.Жишээ нь `min()`, `max()`, `median()`, `sd()` зэрэг статистик функцууд байж болно. Статистикийн функцууд дотор бодолтод оролцох баганууд болон бусад нэмэнлт аргументуудыг (`na.rm = TRUE` гэх мэт) бичнэ. Мөн `sum()` -ыг хэрэглэж логик шалгуурт тэнцсэн мөрийн тоог гаргаж болно  (давхар тэнцүүгийн тэмдэгтэйгээр `==`).   

Дор жишээнд `summarise()` -ыг  *бүлэглээгүй датанд* хэрэглэсэн байна. Статистикийн дүн нь нийт бүх мөрөнд тооцоолол хийсний дүнд гарсан.

```{r}
# бүлэглээгүй linelist дээр статистикийн хураангуй бодож гаргах
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

Харин удаах жишээнд `summarise()` -ыг бүлэглэсэн дата дээр ашиглаж байна. `outcome` баганын бүлэг тус бүрт статистикийн бодолт хийгдсэн. Note how grouping columns will carry over into the new data frame.    

```{r}
# бүлэглэсэн linelist дээр статистикийн хураангуй бодож гаргах
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

<span style="color: darkgreen;">**_ЗӨВЛӨГӨӨ:_** summarise функцын UK (`summarise()`) болон US (`summarize()`) хувилбарууд ижил. </span>




## Тоолж, бүртгэх  

`count()` болон `tally()` төстэй үйлдэл хийдэг боловч өөр. `tally()` болон `count()`-н лгааны талаар [here](https://dplyr.tidyverse.org/reference/tally.html)-ээс олж уншна уу.    

### `tally()` {.unnumbered}  

`tally()` бол `summarise(n = n())`коммандын богино хувилбар ба датаг *бүлэглэдэггүй*. Тиймээс бүлэглэсэн датанд хэрэглэх бол `group_by()` -ын араас залгуулж хэрэглэдэг. Мөн үүн дээр `sort = TRUE` гэж аргументийг тохируулснаар хамгийн том бүлгийг эхэнд жагсааж болно.   

```{r}
linelist %>% 
  tally()
```


```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```


### `count()`  {.unnumbered}  

Харин `count()` функц дараах үйлдлүүдийг хийдэг:  

1)  тодорхой заасан багануудад `group_by()`-г хэрэглэдэг.
2) `summarise()` хэрэглэсний дүнд `n` баганад бүлэг тус бүр хэдэн мөр агуулагдаж буйг тоолж гаргадаг.
3) мөн `ungroup()` хийгддэг. 

```{r}
linelist %>% 
  count(outcome)
```

`group_by()` -ийн адил  `count()` комманд бас шинэ багана үүсгэдэг:  

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```


`count()` функцыг олон дахин дуудаж болно (өнхрүүлэх байдлаар). Жишээ нь хүйс тус бүрт ноогдох эмнэлэгийн тоог гаргахдаа доорх коммандыг өгнө.  Хамгийн арын багана нь автоматаар "n" гэж нэрлэгдсэн байснаа ( `name  = ` аргументээр) өөрчлөгдөж илүү тодорхой нэртэй болсон байна.  

```{r}
linelist %>% 
  # outcome-gender -ын хавсарч үүссэн бүлгүүдэд ноогдох мөрийг тоолох
  count(gender, hospital) %>% 
  # gather rows by gender (3) and count number of hospitals per gender (6)
  count(gender, name = "hospitals per gender" ) 
```


### Тооллого нэмэх{.unnumbered}  

Мөн `add_count()`-ээр тооллого хийж болох боловч `count()` болон`summarise()`-ээс ялгаатай. Энэ функцыг хэрэглэснээр *хуучин хүснэгт бүхлээрээ өөрчлөгдөхгүй* хэвээр байх ба бүлэг бүрийн тоог гаргасан шинэ `n` гэсэн багана нэмэгддэг. 

Өөрөөр хэлбэл шинэ `n` баганадах бүлэг тус бүрт агуулагдах мөрийн тоо тухайн бүлэгт хамаарах мөр болгонд бичигдэх болно гэсэн үг. Доор жишээнд ойлгомжтой харуулах үүднээс баганыг нэмээд дараа нь эрэмбэнд өөрчлөлт оруулсан болно. Мөн [filter on group size](#group_filter_grp_size) хэсэгт өөр нэгэн жишээ харуулсаныг олж үзнэ үү. 


```{r}
linelist %>% 
  as_tibble() %>%                   # tibble болгож харагдах байдлыг сайжруулна
  add_count(hospital) %>%           # эмнэлэгийн тоотой n баганыг нэм 
  select(hospital, n, everything()) # харахад хялбар болгох үүднээс дахин эрэмбэл
```



### Нийт дүнг нэм {.unnumbered} 

Нийт дүнг хялбар нэмэх арга бол `tally()` эсвэл `count()` хэрэглэсний дараа мөр, баганын *нийлбэрийг* гаргах хэрэгтэй. Үүнийг  [Descriptive tables](#tbl_janitor) хуудасны **janitor** багцыг тайлбарласн хэсгээс үзнэ үү. Энэ багцад `adorn_totals()`, `adorn_percentages()` зэрэг нийт дүнг нэмж, хувь болгох гэх мэт олон функцууд агуулагддаг. Доор товч жишээ харуулья: 

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # хоёр баганыг солбиж-хүснэгтлэн тоолох 
  adorn_totals(where = "row") %>%             # нийт мөрийн нийлбэр
  adorn_percentages(denominator = "col") %>%  # баганын нийлбэрийг деноминатор (хуваариар) тооцож хувийг гаргах
  adorn_pct_formatting() %>%                  # пропорцыг хувь болгож хувиргах
  adorn_ns(position = "front") %>%            # : "тоо (хувь)" гэж харуулах
  adorn_title(                                # гарчигийг янзлах
    row_name = "Age Category",
    col_name = "Gender")
```


*Нийлбэрээс* өөр нарийн статистикийн бодолтыг мөр дагуу бодож гаргах бол  [this section of the Descriptive Tables page](#tbl_dplyr_totals) хэсгээс харна уу.  



## Он сараар бүлэглэх  

Огноогоор бүлэглэхдээ огнооны нэгжийг (өдөр, тархварзүйн долоо хоног, сар гэх мэт) бичих нэг илүү багана байлгах (үүсгэх) хэрэг гардаг. Үүнийг [Working with dates] хуудасны [Epidemiological weeks section](#dates_epi_wks) хэсэгт заасны дагуу **lubridate**-ын `floor_date()` -аар үүсгэж болно. Энэ баганыг үүсгэсний дараа **dplyr**-ын `count()` -аар мөрүүдийг огноогоор бүлэглэж, нэгтгэсэн тоог гаргаж болно.

Огноотой ажиллаж байхад нэмэлтээр хийгддэг өөр нэгэн нийтлэг алхам бол датанд байхгүй ямар нэг огноог дарааллын дагуу "бөглөх" юм.
Нэгтгэгдсэн огнооны дараалалд **tidyr**-ын `complete()` -ыг хэрэглэвэл *тухайн хүрээнд байж болох бүх нэгжийг оруулан* огнооны дараалал*гүйцэд* болддог. Энэ алхмыг хийгэгүй тохиолдолд өвчин илрээгүй долоо хоногууд датанд харагдахгүй!  

Ингэхдээ `complete()` дотор огноотой баганаа `seq.Date()`-ийн багаас ихсэх *дарааллаар* *дахин зааж өгөх* хэрэгтэй бөгөөд, улмаар огнооны дараалал өргөжих болно. Энэхүү өргөжиж нэмэгдсэн шинэ огноонд тохиолдлын тоо `NA` гэж гарч ирдэг. Үүнийг `complete()`-ын  `fill = ` аргументэд 0 гэж зааж өгч засаж болно.  which expects a named list (хэрэв тохиолдлын тоотой баганын нэр `n` гэж нэрлэгдсэн байгаа бол `fill = list(n = 0)` гэж зааж өгнө. Энэ аргументийн өгөдөл нэртэй list байдаг. Энэ талаар `?complete` хуудас болон  [Working with dates](#dates_epi_wks) хуудасны жишээнүүдэд илүү тайлбарласан ).



### Linelist тохиолдлуудыг өдөр бүрээр бүлэглэх {.unnumbered}  

Энд`complete()`функцыг *хэрэглээгүй* байдлаар тохиолдлын тоог өдрөөр бүлэглэх коммандыг харуулав. Тохиолдол илрээгүй эхний өдрүүдийг алгасч харуулсан байгааг анзаарна уу. 

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # date_onset бичигдээгүй тохиолдлуудыг арилгана
  count(date_onset)              # огноо бүрт ноогдох тохиолдлын тоог тоол
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Энд `complete()` коммандыг ашиглаж тодорхой хугацаандах бүх өдрүүдийг гарч ирдэг болгоё.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset бичигдээгүй тохиолдлуудыг арилгана
  count(date_onset) %>%                   # огноо бүрт ноогдох тохиолдлын тоог тоол
  complete(                               # тохиолдол илрээгүй ч бүх өдөр харагдах болно
    date_onset = seq.Date(                # огноотой баганыг өдөр тутмыг харуулсан байдлаар зааж өгнө.
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # n баганын 0 тохиолдолтой мөрүүдийг бөглөх  ( автоматаар гарах NA-ын оронд) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist тохиолдлуудыг долоо хоног бүрээр бүлэглэх {.unnumbered}  


Долоо хоног бүрийн тоог мөн дээрхитэй адил зарчмаар хийнэ. Эхлээд `floor_date()` -ын нэгжийг `unit = "week"`хэмээн тохируулж тохиолдол бүрийн илэрсэн дотоо хоногийн дугаарыг тавьна. Дараа нь`count()` -аар дээрхийн адил долоо хоног бүрт ноогдох тохиолдлын тоог харуулна. Энэ комманд дээрээ `complete()` -ыг нэмбэл тохиолдол илрээгүй ч гэсэн бүх долоо хоног харуулах болно.

```{r}
# Тохиолдлын тоог долоо хоног бүрээр харуулсан хүснэгт байгуул
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # date_onset бичигдээгүй тохиолдлуудыг арилгана
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # өвчин эхлэл бүртгэгдсэн долоо хоногийн дугаартай багана
  count(week) %>%                         # долоо хоног бүрээр датаг бүлэглэж, бүлэг бүрт ноогдох мөрийн тоог тоол
  complete(                               # тохиолдол илрээгүй ч гэсэн бүх долоо хоногууд гарч ирдэг болго 
    week = seq.Date(                      # огноотой баганыг өдөр тутмыг харуулсан байдлаар зааж өгнө.
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # n баганын 0 тохиолдолтой мөрүүдийг бөглөх  ( автоматаар гарах NA-ын оронд)  
```

Шинээр байгуулсан хүснэгтийн эхний 50 мөрийг дор харуулав:  

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Linelist тохиолдлуудыг сар бүрээр бүлэглэх {.unnumbered}

Тохиолдлыг сар бүрээр харуулахад мөн **lubridate**  багцын `floor_date()` -ыг хэрэглэнэ. Гэхдээ нэгжийн аргументэд `unit = "months"` гэж тохируулна. Ингэснээр огноо бүр тухайн сарынхаа эхний өдөрт хураагддаг. Үүний үр дүнд огноо хэлбэрийн дататай багана үүснэ. Энэ үед `complete()` алхмыг хийхдээ `by = "months"` гэж аргументээ тохируулна гэдгийг анхаарна уу.  


```{r}
# Тохиолдлын тоог сар бүрээр харуулсан хүснэгт байгуул
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # шинэ багана, өвчин эхэлсэн сарын эхний өдөр
  count(month) %>%                          # сар бүрт ноогдох тохиолдлын тоо
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # тохиолдол илрээгүй ч гэсэн бүх саруудыг гарч ирдэг болго
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Өдөр тутмын тооллогыг долоо хоногт шилжүүлэх {.unnumbered}

Өдөр тутмын тооллогыг долоо хоног бүрт шилжүүлэхдээ `floor_date()` -ыг дээрхийн адил ашиглана. Харин энэ удаад долоо хоногт ноогдох мөрийн тоо биш харин өдөр тутамд илэрсэн тохиолдлын тооны нийлбэрийг (`sum()`) тогтоох хэрэгтэй учраас `count()`биш оронд`group_by()`, `summarize()` функцуудыг хавсарч хэрэглэх шаардлагатай.



#### Өдөр тутмын тооллогыг сард шилжүүлэх {.unnumbered}

Өдөр тутмын тооллогыг сар бүрт шилжүүлэхдээ `floor_date()` -ыг `unit = "month"` нэгжтэйгээр дээрхийн адил ашиглана. Харин энэ удаад сар бүрт ноогдох мөрийн тоо биш харин өдөр тутамд илэрсэн тохиолдлын тооны нийлбэрийг (`sum()`) тогтоох хэрэгтэй учраас `count()`биш оронд`group_by()`, `summarize()` функцуудыг хавсарч хэрэглэх шаардлагатай. 



## Бүлэглэсэн датаг эрэмбэлэх

Бүлэглэсэн датаг **dplyr** -ын `arrange()` -аар эрэмбэлэх явц бүлэглээгүй linelist хүснэгтийг эрэмбэлэхтэй адил. Харин энэ үед аргументийг тохируулбал `.by_group =TRUE` эхлээд бүлэглэсэн баганууд эрэмбэлэгдэж, дараа нь `arrange()` оруулсан бусад баганууд эрэмбэлэгддэг. 



## Бүлэглэсэн датаг шүүх

### `filter()` {.unnumbered}

Дата хүснэгтийг шүүхдээ (filter) бусад функцтэй (`max()`, `min()`, `mean()`зэрэг ) хавсарч хэрэглэдэг ба бүлэглэсэн хүснэгтэд мөн адил хамт хэрэглэж болно. Жишээ нь медианаас дээш настан агуулсан мөрүүдийг үлдээх үйлдлийг бүлэглэсэн хүснэгтэд хийж болно. Өөрөөр хэлбэл бүлгүүдийн медиан наснаас дээш нас агуулсан мөрийг үлдээнэ гэсэн үг. 




### Бүлгээр хуваах {.unnumbered} 

Хуваахдаа **dplyr** -ын `slice()`-ыг ашиглаж болно. Энэ нь мөрийг байрлалын дагуу шүүгдэг ба бүлэглэсэн датанд адилхан үйлчилнэ [filters rows based on their position](https://dplyr.tidyverse.org/reference/slice.html). Хүссэн хэсгүүдэд хуваахын тулд бүлэг тус бүрийг эхлээд дотор нь эрэмбэлэх хэрэгэтй гэдгийг анхаар.

Жишээ нь эмнэлэг тус бүрд хэвтэгсдийн дундаас хамгйин сүүлийн 5-ыг сугалж авахын тулд:

1) linelist -ыг `hospital` баганын дугуу бүлэглэ
2) *Эмнэлэг/бүлэг тус бүр доторх* эмнэлэгт хэвтсэн огноог  хамгийн сүүлчээс хамгийн эртрүү чиглэлтэйгээр эрэмбэл
3) Эмнэлэг тус бүрийн хамгийн эхний 5 мөрийг сугалж гаргаж ирнэ 

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # харуулах
  select(case_id, hospital, date_hospitalisation)  # харуулах
```

`slice_head()` - n мөрийг дээрээс тоолж сонгоно  
`slice_tail()` - n мөрийг доороос тоолж сонгоно 
`slice_sample()` - n мөрийг санамсаргүй байдлаар сонгоно  
`slice_min()` - `order_by = ` баганадах хамгийн их утгатай n мөрийг сонгоно (`with_ties = TRUE`гэж тохируул) 
`slice_max()` - `order_by = ` баганадах хамгийн бага утгатай n мөрийг сонгоно (`with_ties = TRUE`гэж тохируул)   

[De-duplication] хуудаснаас `slice()`-ын талаар тайлбарласныг уншна уу.  




### Бүлгийн том жижигээр нь шүүх {#group_filter_grp_size .unnumbered} 

`add_count()` функц эх хүснэгтэд шинээр `n` гэсэн баганыг нэмдэг. Энэ баганын утга нь датандах мөр болгоны харьяалах бүлгийн хамрах хэмжээг зааж өгсөн байдаг. 

Доор уишээнд `add_count()` функцыг `hospital` багана дээр хэрэглэсэн байна. Тиймээс `n` багана дах утга бол тухайн мөрөнд бичигдсэн эмнэлэгийн бүлэгт ноогдох мөрний тоо юм. Тиймээс `n` баганын утгууд олон давтагдсан байна. Баганын нэр `n` -ийг  `add_count()`-ын `name = `аргументээр өөрчилж болно. Харуулахад ойлгомжтой болгох үүднээс багануудыг `select()`-ээр эрэмбэлсэн.  


```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # "энэ эмнэлэгтэй адилхан эмнэлэгт хэвтсэн мөрийн тоог" нэм 
  select(hospital, n, everything())
```

Ийм багана нэмэхэд жижиг (жишээ нь 500 аас доош хүн хэвтсэн) эмнэлэгт хэвтсэн тохиолдлуудыг шүүж гаргаж ирэхэд амар боллоо.

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```





##Бүлэглэсэн датаг хувиргах  

Бүх багана мөрийг хэвээр нь байхад (нэгтгэхгүй) *бүлгийн статистикийн тооцоо агуулсан шинэ багана* нэмэх бол `summarise()`-ын оронд `mutate()`-ыг `group_by()` угсруулж хэрэглэ.

Ингэснээр эх дата дээрээ бүлгийн статистикийг *бусад баганын хамтаар* харах боложмтой юм. Тухайлбал нэг мөрний утгыг бүлгийн утгатай нь харьцуулж болно. 

Доор жишээ код эмнэлэгт хожуу хэвтэлттэй мөрүүд болон хожуу хэвтэлтийн медиан үзүүлэлтүүдийг харьцуулж ялгааг харуулсан. Үүнийг хийх алхмууд нь: 

1) Датаг эмнэлэг тус бүрээр бүлэглэ  
2) `days_onset_hosp` (эмнэлэгт хожуу хэвтэх) баганыг ашиглан *тухайн мөрөн дэх* эмнэлэгийн хожуу хэвтэлийн дундаж үзүүлэлтийг тооцож бодсон шинэ багана үүсгэ. 
3) Хоёр баганын ялгааг тооц 

Ойлгомжтой байлгахын тулд зөвхөн тодорхой багануудыг `select()` -ээр сонгож харуулав. 

```{r}
linelist %>% 
  # Датаг эмнэлэг тус бүрээр бүлэглэ (linelist -д өөрчлөлт гарахгүй)
  group_by(hospital) %>% 
  
  # Шинэ баганууд
  mutate(
    # Эмнэлэгт хэвтэх хүртэлх өдрийн дундаж (таслалтын ард нэг орон байхаар хураа)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # Тухайн мөрний хожуу хэвтэлт болон яг тэр мөрний эмнэлэгийн хожуу хэвтэлтийн дундаж хоёрын ялгаа (таслалтын ард нэг орон байхаар хураа)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # Ойлгомжтой байлгахын тулд зөвхөн тодорхой багануудыг л сонго
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```



## Бүлэглэсэн дата  

`select()` функц мөн бүлэглэсэн датанд үйлчилдэг. Гэхдээ бүлэг үүссэн багана нь үргэлж сонгогдох болно (`select()` дотор зааж өгөөгүй байсан ч гэсэн). Бүлэг үүссэн баганыг оруулахгүй байхын тулд эхлээд `ungroup()` хийнэ.  










<!-- ======================================================= -->
## Нэмэлт материал {  }

Нэмэлт хэрэгтэй мэдээллүүдийг дараах линкуудээс үзнэ үү:  

Ямар ч нэгтгэж дүгнэсэн функцыг бүлэглэсэн датанд хийж болно; [RStudio data transformation cheat sheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf) ээс харна уу.  

[**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html)  
The **tidyverse** reference pages on [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) хуудасны The Data Carpentry хэсэг болон [grouping](https://dplyr.tidyverse.org/articles/grouping.html)  

[Data manipulation](https://itsalocke.com/files/DataManipulationinR.pdf) хуудас

[Summarize with conditions in dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)  






