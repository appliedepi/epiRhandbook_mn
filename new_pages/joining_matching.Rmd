
# Датаг холбох { }  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

*Зурагт зүүн холболтыг жишээгээр дүрсэлж харуулав ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))*  


Энэ хуудаст датаг хэрхэн хооронд нь "холбох (join)", "хослуулах (match)", "угсрах (link)" "залгах (bind)" талаар тайлбарлах болно.

Тархвар судлалд дата анализ олон янзын датаг нэтгэж, цуглуулахгүй явагдах нь цөөн.  явцад янз бүрийн эх үүсвэрээс гаралтай датаг нэгтгэж, холбохгүй байх нь бараг үгүй тул эдгээрийг хооронд нь холболт хийх шаардлага байнга гарч байдаг. Үүнд лабораторийнн хариуг өвчтний эмчилгээтэй, Google -ийн шилжих хөдөлгөөнийг халдварт өвчний трендтэй, эсвэл аливаа датаг өөрийнх нь хувирсан хэлбэртэй холбох зэрэг жишээг дурьдаж болно.  

Энэ хуудасны код дараах үйлдлүүдийг хийж үзүүлэх болно:  

* хоёр хүснэгтийн тодорхойлогч (ID) багануудад агуулагдах ижил утгуудыг хослуулж *холбох*
* хослох *магадлал* дээр үндэслэж хоёр хүснэгтийг нэгтгэх  
* аливаа хүснэгтийн мөр, багана дээр өөр нэг хүснэгтийн мөр баганаас шууд *залгах* ("хавсаргах")


<!-- ======================================================= -->
## Бэлтгэл { }

### Багцыг ачааллах {.unnumbered}

This code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  

```{r}
pacman::p_load(
  rio,            # import and export
  here,           # locate files 
  tidyverse,      # data management and visualisation
  RecordLinkage,  # probabilistic matches
  fastLink        # probabilistic matches
)
```



### Import data {.unnumbered}

To begin, we import the cleaned linelist of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> (as .rds file). Import data with the `import()` function from the **rio** package (it handles many file types like .xlsx, .csv, .rds - see the [Import and export] page for details).  

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
### Жишээ дата {.unnumbered}


Дата холбох үйлдэлд хэрэглэх жишээ датанууд:  

1) `linelist` хүснэгтийн богино хэлбэр `case_id`, `date_onset`, `hospital` багануудын эхний 10 мөртэй хүснэгт
2) Эмнэлэгүүдийн талаар мэдээлэлтэй `hosp_info` хүснэгт 

Магадлалаар холболт хийх хэсэгт богино хэмжээний хоёр жишээ хүснэгтийг ашиглах болно. Эдгээр хүснэгтийг байгуулах кодыг тухайн хэсгээс харна уу.


#### linelist -ын "богино" хэлбэр {#joins_llmini .unnumbered}  

linelist -ын `case_id`, `date_onset`, `hospital` багануудын эхний 10 мөртэй богино хувилбарыг дор харуулав.  

```{r}
linelist_mini <- linelist %>%                 # linelist-ийн эхний хувилбар
  select(case_id, date_onset, hospital) %>%   # багануудыг сонгох
  head(10)                                    # зөвхөн эхний 10 мөрүүдийг салгаж авах
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```




#### Эмнэлэгүүдийн мэдээлэлтэй дата {#joins_hosp_info .unnumbered}  

Дараах жишээнд долоон эмнэлэгийн мэдээллийг агуулсан хүсэнгт байгуулах кодыг бичсэн (хамрах хүн ам, үзүүлэх тусламж үйлчилгээний түвшин). Үүнд "Армийн эмнэлэг" гэсэн хоёр эмнэлэг байгааг анхаарна уу: эхнийх нь 10000 хүн амыг хамрах анхан шатны эмнэлэг бол хоёр дах нь 50280 хүнийг хамрах хоёрдугаар шатны эмнэлэг юм. 

```{r}
# эмнэлэгүүдийн мэдээлэлтэй хүснэгтийг байгуул
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

Хүснэгтын харагдах байдал:  

```{r message=FALSE, echo=F}
# эмнэлэгүүдийн датаг хүснэгтээр харуул
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```





<!-- ======================================================= -->
### Цэвэрлэгээний өмнөх шат {.unnumbered}

Уламжлалт аргаар холболт хийхэд (магадлалаар бус) үсгийн жижиг том хамаатай байдаг. Холбож буй хүснэгтүүдийн утга яг ижил тооны тэмдэгттэй байх ёстой. Холболт хийхээс өмнөх цэвэрлэгээг `linelist_mini` болон `hosp_info` хүснэгтүүдийн жишээгээр харуулав. 

**Зөрүүг олох**  

`linelist_mini`-ын `hospital` баганыг `hosp_info` хүснэгтийн `hosp_name` баганатай холбох болно. 

Энд `linelist_mini` хүснэгтийн утгыг **base** R дах `unique()`функцээр хэвлэж харуулав:  

```{r}
unique(linelist_mini$hospital)
```

Харин энд `hosp_info` хүснэгтийн утгыг харуулав:  

```{r}
unique(hosp_info$hosp_name)
```

Эмнэлэгүүдийн нэр хоёр хүснэгтэд хоёуланд нь буй боловч бичиглэлийн хувьд янз бүр байгаа харагдаж байна.



**Утгуудыг ижилсүүлэх**  

Эхлээд `hosp_info` хүснэгт дэх утгыг цэвэрлэе. Ингэхдээ **dplyr** багцдах `case_when()` функцын логик шалгуураар ([Cleaning data and core functions] хуудаст тайлбарласны дагуу) багана дах утгыг өөрчлөх болно. Хоёр хүснэгтэд буй дөрвөн эмнэлэгийн нэрийг `linelist_mini` хүснэгтэд бичигдсэнтэй ижилсүүлээд бусад эмнэлэгийн нэрсийг хэвээр (`TRUE ~ hosp_name`) үлдээе. 

<span style="color: orange;">**_БОЛГООМЖЛОЛ:_** Цэвэрлэгээний үед шинэ багана үүсгэх хэрэгтэй боловч жишээг хялбарчлах үүднээс хуучин багана дээр өөрчлөлт хийлээ.  </span>

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # шалгуур                        # шинэ утга
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

Эмнэлэгийн нэрс хоёр хүснэгтэд ижил бичлэгтэй боллоо. `linelist_mini` -ын дахиад хоёр эмнэлэг `hosp_info`-д байхгүй байна. Үүнийг дараа нь холболт хийхдээ янзална.  

```{r}
unique(hosp_info$hosp_name)
```

Холболт хийхийн өмнө үсгийн том жижигийг жигдрүүлснээр дараагийн үйлдэл хялбарчлагддаг. Аль нэг баганын утгыг бүгдийг томоор эсвэл жижигээр бичих гэж буй тохиолдолд эхлээд `mutate()` -ыг уншуулж, араас нь **stringr** багцын дараах функцуудын аль нэгэнд өөрчлөх баганын нэрийг бичнэ ([Characters and strings] хуудаст тайлбарласан).  

`str_to_upper()`  
`str_to_upper()`  
`str_to_title()`  




<!-- ======================================================= -->
## **dplyr** -ын холболт хийх (join) функцууд { }

**dplyr** багцад хэд хэдэн холболт хийдэг функцууд байдаг. **dplyr** нь **tidyverse** -ын харьяа багц. Эдгээр холболт хийх функц тус бүрийг энгийн жишээгээр дор тайлбарлалаа.  

Ойлгомжтой gif дүрслэл хэрэглэхийг зөвшөөрсөн [https://github.com/gadenbuie](https://github.com/gadenbuie/tidyexplain/tree/master/images)-д талархаж байна !  




<!-- ======================================================= -->
### Ерөнхий синтакс {.unnumbered}

Хоёр хүснэгт холбоход холболтын функцуудыг дангаар нь хэрэглэж болно. Эсвэл pipe холбоост (`%>%`) шууд залгаж цэвэрлэгээ хийж байх явцдаа холболт хийж бас болно.

Доор `left_join()` (зүүн холболт) -ыг дангаар нь хэрэглэж `joined_data` хүснэгт үүсгэх жишээг харуулсан. Ингэхдээ хүснэгт 1, хүснэгт 2 (`df1` ба `df2`)-ыг ашигласан. Эхлээд үндсэн хүснэгт, дараа нь туслах буюу үндсэн хүснэгтэд холбогдож буй хүснэгтийг бичнэ.

Хоёр хүснэгтийн ижилсүүлэх гэж буй баганыг дараагийн аргумент `by = ` -д бичнэ.  Хэрэв баганын нэрс хүснэгт тус бүрт өөрөөр бичигдсэн байвал вектор хэлбэрээр жагсааж `c()`дотор (дор жишээнд харуулсны дагуу) оруулж бичнэ. Доорхиос харахад `df1`-ын `ID` болон `df2`-ын `identifier` багануудыг сонгож эдгээрт агуулагдах ижил утгатай мөрүүдийг хослуулсан байна.   

```{r, eval=F}
# "ID" (үндсэн хүснэгтийн) болон "identifier" (туслах дах хүснэгтийн) баганууддах ижил утгуудыг хослуулж холболт хийх
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

Хослуулах баганын нэрс хоёр хүснэгтэд ижил бичигдсэн бол `by` аргументэд зөвхөн энэ нэрийг хашилттайгаар өгөхөд хангалттай.  

```{r, eval=F}
# Хоёр хүснэгтийн "ID" багануудын ижил утгуудыг хослуулж холболт хийх
joined_data <- left_join(df1, df2, by = "ID")
```

Хэрэв олон баганыг ижилсүүлж холболт хийх гэж буй бол `c()` дотор вектор хэлбэрээр баганын нэрсийг жагсааж болно. Доорх жишээнд гурван баганадах утгууд хосолсон мөрүүдээр холболт хийж байна. 

```{r, eval=F}
# Нэр, овог, нас хосолсон тохиолдолд холбоно. 
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```


Мөн холбох (join) коммандуудыг pipe холбоосонд залгаж болно. Ингэснээр pipe -аар дамжиж буй хүснгтийг шууд өөрчилж болно. 

Доорх жишээнд `df1` хүснэгт pipe -аар дамжиж буй бөгөөд үүн дээр `df2` хүснэгтийг холбож байна. ТҮр дүнд `df` хувирах болно.

```{r eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # цэвэрлэгээний хэсэг
  left_join(df2, by = c("ID" = "identifier"))    # df2 -ыг df1 -т залга
```


<span style="color: orange;">**_АНХААРУУЛГА:_** Холболт хийх (join) коммандуудад үсгийн том жижиг хамаатай! Тиймээс нэгтгэхийн өмнө бүх үсгийг жижиг эсвэл том болгож жигдрүүлэх хэрэгтэй. Энэ талаар characters/strings хэсэгт илүү тайлбарласан.</span>





<!-- ======================================================= -->
### Зүүн болон баруун холболт {.unnumbered}  

**хүснэгтэд дата нэмэхэд зүүн (left join) болон баруун холболтыг (right join) нийтлэг ашигладаг** -Үүгээр зөвхөн үндсэн датаны мөрүүдэд шинэ мэдээлэл ордог гэсэн үг юм. Ингэж нэг хүснэгтийн мэдээллийг нөгөөд нэмж оруулах шаардлага ялангуяа тархварзүйн ажилд өдөр тутам тулгарч байдаг тул нэн элбэг хэрэглэдэг үйлдэл юм. 

Холболт хийх коммандуудад хүснэгтийн дараалал чухал *.  

* *зүүн холболт* -д үндсэн хүснэгтийг *эхэлж* бичнэ.
* *баруун холболт* -д үндсэн хүснэгтийг *хоёрдугаарт* бичнэ.

**Үндсэн датаны бүх мэдээлэл хэвээр үлдэх болно.** Харин туслах (хоёрдогч) хүснэгтийн *зөвхөн үндсэн хүснэгтийн тодорхойлогч баганатай хосолсон* мөрүүдийн мэдээлэл л орох болно. Анхаарах зүйлс:  

* Туслах (хоёрдогч) хүснэгтээс үндсэн хүснэгттэй хослоогүй мөрүүд устгагдах болно.
* Туслах хүснэгтийн нэг мөр үндсэн хүснэгтийн олон мөртэй хосолж таарвал (many-to-one) *үндсэн хүснэгтийн мөр болгонд* туслах хүснэгтийн мэдээлэл нэмэгдэж орно. 
* Туслах хүснэгтийн олон мөр үндсэн хүснэгтийн нэг мөртэй таарвал (one-to-many) хосолж болох бүх хувилбарууд нэмэлт мөр болж ордог. Улмаар үндсэн хүснэгтийн мөрийн тоо нэмэгдэх магадлалтй!* 

Зүүн, баруун холболтын жишээг энимэйшнээр харуулав ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images)).

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**Жишээ**  

Дараах жишээнд `left_join()` -ыг ашиглаж `hosp_info`-г (туслах хүснэгт, [view here](#joins_hosp_info)) `linelist_mini` (үндсэн хүснэгт, [view here](#joins_llmini))-д хэрхэн нэгтгэхийг харуулав. Эхлээд `linelist_mini` хүснэгт` nrow(linelist_mini)` тэй байсан.   `linelist_mini` -д хувиргалт хийсний дараа дараах байдлаар харагдаж байна. Анхаарах зүйлс:  

* `linelist_mini` хүснэгтийн зүүн талд `catchment_pop`, `level` гэсэн хоёр багана шинээр нэмэгдсэн. 
* `linelist_mini` хүснэгтийн анхны мөрүүд бүгд байна. 
* `linelist_mini` хүснэгтийн "Military Hospital" -ын мөрүүд хоёр хувилагдсан. Учир нь туслах хүснэгтэд *хоёр* мөр байсан тул хоёр хувилбар үүсч, хоёулаа нэмэгдэж орсон гэсэн үг.
* Үүссэн шинэ хүснэгтэд үндсэн хүснэгтийн тодорхойлогч (identifier) багана (`hospital`) үлдэж, туслах хүснэгтийн тодорхойлогч багана (`hosp_name`) ороогүй байна. 
* Үндсэн хүснэгтийн мөрүүдээс туслах хүснэгтийн мөртэй таараагүй тохиолдлуудад (жишээ нь `hospital`-ын "Other" эсвэл "Missing" утгууд) туслах хүснэгтээс нэмэгдэн багануудын зай `NA`(хоосон) -аар бөглөгдөх болно.
* Хэрэв туслах хүснэгтэд үндсэн хүснэгттэй таарахгүй мөр буй бол шууд гээгдэх болно ( жишээ нь "sisters" болон "ignace" эмнэлэгийн мөрүүд).  


```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```





#### "Баруун уу зүүнийг үү?" {.unnumbered}  

Энэ асуултанд хариулахын тулд "аль хүснэгтийн мэдээллийг бүтнээр нь үлдээх шаардлагатай вэ" гэж эхлээд асуух хэрэгтэй ба энэ нь үндсэн хүснэгт болно. Ингээд *left join* -г хэрэглэх гэж буй бол үндсэн хүснэгтийг коммандын эхэнд,  *right join* -ыг хэрэглэх бол хоёрдугаарт жагсааж бичих хэрэгтэй.  

Доор бичсэн хоёр комманд ижил үр дүнтэй. Хоёр өөр комманд хэрэглэсэн ч эцсийн үр дүнд `hosp_info` -ын 10 мөр `linelist_mini` -дээр нэмэгдсэн байна. `hosp_info` -ын баганууд үндсэн хүснэгт дээр аль талаасаа нэмэгдэж (зүүн холболт хийхэд баруун талд, баруун холболт хийхэд зүүн талд нэмэгддэг) орж байгаагаас хамаараад эцсийн хүснэгтэд баганын дараалал ялгаатай байдаг. Мөн мөрүүдйин дараалалд өөрчлөлт орж болно. Үүнийг `select()` (баганын дараалал) эсвэл `arrange()` (мөрийн дараалал) функцуудээр янзалж болно.  

```{r, eval=F}
# Доорх хоёр коммнадаар ижил мэдээлэл үүсэх боловч мөр, баганын дараалал ялгаатай байна.
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

Зүүн холболтоор `hosp_info` -г нэмэхэд `linelist_mini` -д нэмэх (шинэ багана баруун талаас нэмэгднэ) :

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Баруун холболтоор `hosp_info` -г нэмэхэд `linelist_mini` -д нэмэх (шинэ багана зүүн талаас нэмэгднэ) :

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Харин pipe дотор (`%>%`) холболт (join) хийж буй үед аль коммандын сонголт чухал. Үндсэн хүснэгт pipe -аар дамжиж цэвэрлэгдэж байгаа бол ихэвчлэн зүүн холболтоор дата нэмдэг. 


<!-- ======================================================= -->
### Бүтэн холболт (full join) {.unnumbered} 

**Холбох коммандуудаас мэдээллийг хамгийн их *хамруулдаг* нь бүтэн холболт (full join) юм**. Учир нь холбогдож буй хоёр хүснэгтийн бүх мөрийг хамруулдаг.  

Нэг хүснэгтийн мөр нөгөө хүснэгтийн ямар ч мөртэй тохироогүй (хослох мөр олдоогүй) тохиолдолд шинээр үүсэх хүснэгтэд шинэ мөр болж нэмэгдэж ордог ба ингэснээр хүснэгт уртасдаг. Ингэж холбогдход үүссэн хоосон нүднүүдэд  `NA`  бичигддэг. Холбож байх явцад мөр, баганын тоог watch the number of columns and rows carefully to troubleshoot case-sensitivity and exact character matches. 

Коммандын эхэнд бичигдсэн хүснэгт бол "үндсэн" хүснэгт юм.  Энэ дарааллыг өөрчилснөөр шинэ үүсэх хүснэгтийн мөрөнд нөлөө гарахгүй, зөвхөн баганын дараалалд өөрчлөлт ордог. Мөн үндсэн хүснэгтийг зааж өгснөөр хоёр хүснэгтийн алиных нь тодорхойлогч баганыг үлдээхийг тогтоож өгдөг.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

Бүтэн холболтын жишээг дүрсэлж харуулав  ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Жишээ**  

Жишээнд `hosp_info` (анхны мөрийн тоо ` nrow(hosp_info)`, [view here](#joins_hosp_info)) -г `linelist_mini` -д (анхны мөрийн тоо ` nrow(linelist_mini)`, [view here](#joins_llmini)) нэгтгэхдээ `full_join()` -г ашигласан:  

* Үндсэн хүснэгтийн (`linelist_mini`) бүх мөрүүд хэвээр үлдсэн.   
* Туслах (хоёрдох) хүснэгтийн хос мөр олдоогүй мөрүүд ("ignace" болон "sisters") шинээр үүсэх хүснэгтэд нэмэгдэж орох ба тухайн мөрний харалдаах үндсэн хүснэгтийн багануудад ( `case_id` болон `onset`) дутуу утга (missing) болж бичигдэх болно.
* Үндсэн хүснэгтэд хос мөр олдоогүй мөрүүд ("Other" and "Missing") шинээр үүсэх хүснэтгэд нэмэгдэж орох ба тухайн мөрний харалдаах туслах хүснэгтийн багануудад ( ` catchment_pop`, `level`) дутуу утга (missing) болж бичигдэх болно.
* Нэг мөр олон мөртэй (one-to-many), эсвэл олон мөр нэг мөртэй (many-to-one) тохирч байгаа бол бол (тухайлбал "Military Hospital") боломжит бүх тохироонууд үүсч шинэ мөр болж орно (ингэснээр шинээр үүсэх хүснэгтийн хэмжээ урт болдог).
* Зөвхөн үндсэн хүснэгтийн тодорхойлогч багана шинэ хүснэгтэд үлднэ (`hospital`).


```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```





<!-- ======================================================= -->
### Дотоод холболт (inner join) {.unnumbered} 

**Дотоод холболт бол хамгийн *хязгаардагдмал* холболт**. Холбогдож буй Хоёр хүснэгтийн зөвхөн хоёуланд нь таарч буй мөрүүд л шинэ хүснэгтэд үлддэг. Тиймээс шинэ хүснэгтийн мөрийн тоо өмнөхөөс *багасах* магадлалтай. Үндсэн хүснэгтийн сонголт (функц дотор эхэнд бичигдэж буй) хүснэгтийн уртад нөлөөлөлхгүй. Харин мөр, баганын дараалал болон тодорхойлогч баганын сонголтод нөлөөтэй. 

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

Дотоод холболтын жишээг дүрсээр харуулав ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))


**Жишээ**  

Жишээнд `linelist_mini` (baseline) -г `hosp_info` (secondary)-тэй  `inner_join()` -оор хэрхэн холбохыг харуулав. Үүнд анхаарах зүйлс:  

* Үндсэн хүснэгтийн туслах хүснэгттэй тохироогүй мөрүүд хасагдсан байна (`hospital` баганын "Missing" болон "Other" мөрүүд)  
* Туслах хүснэгтийн үндсэн хүснэгттэй тохироогүй мөрүүд хасагдсан байна (`hosp_name`  баганын "sisters", "ignace" мөрүүд)
* Зөвхөн үндсэн хүснэгтийн тодорхойлогч багана шинэ хүснэгтэд орсон (`hospital`)  


```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```


```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```






<!-- ======================================================= -->
### Хагас холболт (semi join) {.unnumbered} 

Хагас холболтыг "шүүлтүүр холболт" гэж болно. Учир нь энэ функцээр мөр нэмж хасах биш харин *өөр хүснэгтийн утгыг ашиглан шүүлтүүр үүсгэдэг*.

**Хагас холболтоор үндсэн хүснэгтийн туслах хүснэгттэй хосолсон мөрүүд үлддэг ** (давхардалт байвал шинээр мөр нэмэгддэггүй). Энэхүү "шүүлтүүр" холболтын талаар [here](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0) -линкээс нэмж уншна уу.  

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

Хагас холболтын жишээг дүрсээр харуулав ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))

Доорх жишээнд `hosp_info` хүснэгтийн мөрүүдээс `linelist_mini` хүснэгтийн hospital name баганын мөрүүдтэй тохирсон мөрүүд шүүгдэж байна. 

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```



<!-- ======================================================= -->
### Эсрэг холболт (anti join) {.unnumbered} 

**Эсрэг холболтыг мөн "шүүлтүүр холболт" гэж болох бөгөөд үндсэн хүснэгтийн мөрүүдээс туслах хүснэгттэй зөвхөн *тохироогүйг* нь үлдээж тохирсныг арилгадаг**  

Шүүлтүүр холболтуудын талаар [here](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0)-линкээс нэмж уншна уу.  

Энэ функцыг аливаа хүснэгтэнд байхгүй тохиолдлыг илрүүлэх, холболт хийж байх үеийн үг үсгийн алдааг олох (тохирч *байх ёстой* тохиолдлууд), холболт хийх явцад хасагдсан тохиолдлыг шалгах зэрэг үйлдлүүдэд хэрэглэхэд тохиромжтой. 

**Үндсэн* хүснэгтийн (эхэнд бичигдих) коммандад бичигдэх байрлал чухал (`right_join()` болон `left_join()`-ын адил)** . Учир нь шинэ хүснэгтийн мөрүүд зөвхөн үндсэн хүснэгтээс гаралтай байх болно. Доорх gif -д харуулснаар туслах хүснэгтийн мөр (хөх ягаан мөр 4) үндсэн хүснэгтийн мөртэй тохироогүй ч гэсэн шинэ хүснэгтэд бичигдээгүй байна.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

Эсрэг холболтыг жишээгээр дүрсэлж харуулав ([image source](https://github.com/gadenbuie/tidyexplain/tree/master/images))


#### `anti_join()` -ын энгийн жишээ {.unnumbered}  

Дараах жишээнд `hosp_info`-оос `linelist_mini`-д байхгүй эмнэлэгүүийг олох болно. Эхлээд үндсэн хүснэгтээр `hosp_info`-г сонгоно. Ингэсний үр дүнд `linelist_mini` хүснэгтээс олдоогүй эмнэлэгийн тохиолдлууд гарч ирэх болно.  

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```


#### `anti_join()` -ын комплекс жишээ {.unnumbered}  

Энд `linelist_mini` болон `hosp_info` хүснэгтүүдийг `inner_join()` -оор нэтгэх болно. `linelist_mini` -ын зарим тохиолдол  `hosp_info`-д байхгүй тул `linelist_mini`-ын нэг хэсгээр л хүснэгт үүссэн байна. 

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

Энэхүү `linelist_mini`гээгдсэн мөрүүдийг шалгахад эсрэг холболтыг ашиглах боломжтой (`linelist_mini` -г үндсэн хүснэгт болгоно).  

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```


Дотоод холболт хийж байхад гээгдсэн `hosp_info` -ын мөрүүдийг шалгахдаа эсрэг холболт функцэд `hosp_info` -г үндсэн хүснэгтээр өгч шалгах боломжтой.



<!-- ======================================================= -->
## Магадлалаар холбох (probabilistic join) { }

Хэрэв тодорхойлогч багана агуулаагүй хүснэгтүүдийг холбох шаардлагатай бол магадлалт алгоритм ашиглаж холбох боломжтой. Өөрөөр хэлбэл төстэй тохиолдлуудыг олно гэсэн үг юм.  (тухайлбал Jaro–Winkler -ын стринг зай (string distance), эсвэл тоон зай (numeric distance)).  Доор  **fastLink** багцыг энгийн жишээн дээр тайлбарлаж харуулав .  

**Багцыг ачааллах**  

```{r}
pacman::p_load(
  tidyverse,      # Дата янзлах, график байгуулах
  fastLink        # тохиолдлуудыг тохируулах
  )
```


Магадлалаар холболт хийх дасгалд хоёр жижиг хүснэгтийг ашиглана (`cases` болон `test_results`):  

Эдгээр хүснэгтийг үүсгэх код:  


```{r}
# Датаг үүсгэ

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```


**`cases` гэсэн датанд 9 тохиолдол байна**. Эдгээр нь шинжилгээний хариу хүлээж буй өвчтөнүүдийн тохиолдол.

```{r message=FALSE, echo=F}
# Эмнэлэгийн датаг хүснэгтээр харуулах
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```



**`test_results` дата нь 14 тохиолдолтой** ба үүний `result`гэсэн баганыг `cases` -ын тохиолдлууд дээр магадлал ашиглаж нэмэх болно.  

```{r message=FALSE, echo=F}
# Эмнэлэгийн датаг хүснэгтээр харуул
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### Магадлалаар ижилсүүлэх {.unnumbered}  

**fastLink** багцын `fastLink()` функцыг ашиглаж ижилсүүлэх алгоритмыг тохируулж болно. Энд зөвхөн ерөнхий байдлаар харуулсан. Илүү дэлгэрэнгүй мэдээлэл `?fastLink` коммандыг уншуулахад гарч ирнэ. 

* `dfA = ` болон `dfB = `  аргументүүдэд харьцуулах хоёр хүснэгтийг тус тус зааж өгнө.
* `varnames = ` аргументэд ижилсүүлэх баганын нэрсийг жагсаана. Энд заасан баганууд `dfA`, `dfB`-д заасан хүснэгтүүдэд бас агуулагдаж байх ёстой.
* `stringdist.match = ` аргументэд `varnames`аргументэд оруулсан багануудын стринг "зайг" (string distance) ижилсүүлэх баганыг сонгож оруулна. 
* `numeric.match = ` аргументэд `varnames` аргументэд оруулсан багануудын тоон зайгаар (numeric distance) шалгах багануудыг сонгож оруулна.
* Дутуу утгуудыг үл тооцно.
* Дефаултаар хүснэгт тус бүрийн мөр болгон нөгөө хүснэгтийн дор хаяж нэг мөртэй хослох болно. Таарсан бүх хослолыг харах бол  `dedupe.matches = FALSE` гэж тохируулна. Winkler-ын шугаман оноох аргачлалаар (Winkler`s linear assignment) давхардалт засч болно.

*Зөвлөгөө: огноотой нэг баганыг **lubridate** багцын `day()`, `month()`, `year()` функцуудээр гурван тусдаа тоон багана болгодж болно.

Ижилсүүлэх босго оноо 0.94 (`threshold.match = `) дээр тохируулагдсан байдаг. Үүнийг багасгаж, ихэсгэх зэргээр тохируулга хийж болно. Хэрэв хэт өндөр босго оноо өгвөл false-иegative (хос болох ёстой мөрүүд хосолж орохгүй) гарах магадлал, хэт багасгавал false-positive хос үүсэх магадлал нэмэгдэж ирдэг.  

Доор жишээнд нэр, дүүрэг багануудад стрингс зайны дагуу, төрсөн өдрийн жил, сар, өдөр багануудад тоон зайны дагуу ижилсүүлэх үйлдэл хийж харуулав. Магадалын босгыг 95% -дээр тохируулсан.


```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Хослолыг шалгах**  

Дараах жишээнд `fastLink()` коммандаар үүссэн обьектийг `fl_output` гэж нэрлэсэн. Үүний дата төрөл нь `list` буюу ижилсэлтийг харуулсан олон хүснэгттэй list юм. Эдгээрийн дунд `matches` гэх хүснэгт бол `cases`,`results` хүснэгтүүдийг харьцуулахад хамгийн олон хос мөр үүссэн хүснэгт юм. Үүнийг `fl_output$matches` коммандаар харж болно. Энэ жишээнд дахин дуудахад хялбар болгох үүднээс `my_matches` гэж хадгалав.

`my_matches`-ийг дуудаж үзвэл хоёр вектор багана агуулсан байгааг харж байна: `cases`  болон `results`  хүснэгтүүдийн хамгийн сайн хослолыг харуулсан мөрийн дугаарууд (индекс) "inds.a" болон "inds.b" баганад тус тус жагссан байх болно (өөрөөр "rownames" гэж нэрлэж болно). Хэрэв дугаар дутуу байвал тухайн мөрөнд нөгөө хүснэгтээс ттухайн мөрөнд аарсан хос олдоогүй (босго онооны стандартад нийцсэн) гэсэн үг. 

```{r}
# Хослолуудыг хэвлэ
my_matches <- fl_output$matches
my_matches
```

Тэмдэглэх зүйлс:  

* Нэр болон төрсөн өдөрт бага зэрэг ялгаа бий боловч тохироо үүсч, хос болсон зарим тохиолдлууд:  
  * "Tony B. Smith"  нь "Anthony B Smith"  -той тохирсон
  * "Maria Rodriguez" нь "Marialisa Rodrigues"- той тохирсон  
  * "Betty Chase" нь "Elizabeth Chase"  -той тохирсон
  * "Olivier Laurent De Bordeaux" нь "Oliver Laurent De Bordow" (төрсөн өдөр дутуу байсныг үл тооцсон) - той тохирсон
*  `cases` -ийн нэг мөр ("Blessing Adebayo", мөрийн дугаар 9 ) -д `results` хүснэгтэд таарах мөр олдоогүй тул `my_matches` хүснэгтэд гарч ирээгүй.  




**Магадлалаар үүссэн хос мөрүүдэд холболт хийх**  

Үүссэн хос мөрүүдийг ашиглаж `results`, `cases` хүснэгтүүдийг холбохын тулд дараах дарааллаар үйлдлийг гүйцэтгэнэ: 

1) `left_join()` -оор `my_matches`-ыг `cases`-д холбо (`cases` -ын rownames (мөрийн дугаар)-ыг `my_matches`-ийн "inds.a"-тэй хослуулна)  
2) Үүний дараа дахин `left_join()` -оор `results` -ыг `cases` -тэй холбо (`cases` -д шинээр нэмэгдсэн  "inds.b" -ыг `results` -ын rownames-тэй хослуулна)  


Дээрх холболтуудыг хийхийн өмнө гурван хүснэгтээ цэвэрлэх хэрэгтэй :  

* `dfA` болон `dfB` хүснэгтүүдийн мөр болгон ("rownames") дугаартай байх ба биеэ даасан багана болж орсон байх шаардлагатай. 
* `my_matches`-ын хоёр багана карактер хэлбэрт хувирсан байх шаардлагатай. Ингэснээр карактер rownames -тэй холбогдож чадна.

```{r}
# Холболтын өмнөх датаг цэвэрлэгээ
#############################

# cases хүснэгтийн мөрийн дугаарыг багана болгох
cases_clean <- cases %>% rownames_to_column()

# test_results хүснэгтийн мөрийн дугаарыг багана болго
results_clean <- results %>% rownames_to_column()  

# matches датаны бүх баганыг карактер болго. Ингэснээр мөрийн дугаарт холбогдох боломжтой.
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# matches-ыг dfA-д нэгтгээд, дараа нь dfB-д нэгтгэх
###################################
# "inds.b" баганыг dfA-д нэмэх
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# dfB -ын багана нэмэх
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

Дээрх кодны үр дүнд үүсэх `complete` хүснэгт `cases`, `results` хоёрын *бүх* мөрийг агуулна. Нэрний давхардалт үүсэхээс сэргийлж ихэнх баганын нэрс".x" эсвэл ".y" гэсэн өргөтгөлтэй болсон байна.

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Хэрэв `cases` -ын зөвхөн анхны 9 тохиолдлыг `results`-ын баганатайгаар гаргаж ирэхийг хүсвэл холболт хийхийн өмнө `select()` -ийг `results` хүснэгтэд хэрэглэж болно. Ингэхдээ `cases` дээр нэмэхийг хүссэн мөрийн дугаар, баганыг `results` хүснэгтээс `select()` ээр сонгох юм (`result` багана гэх мэт).  

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # тодорхой багануудыг л сонгох 

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# холбох
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```


```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Хэрэв хоёр хүснэгтийн зөвхөн хосолсон мөрүүдийг авч үлдэхийг хүсвэл дараах кодыг хэрэглэж болно: 

```{r}
cases_matched <- cases[my_matches$inds.a,]  # results-ын мөртэй хосолсон cases-ийн мөрүүд
results_matched <- results[my_matches$inds.b,]  # cases -ын мөртэй хосолсон results-ийн мөрүүд
```

Эсвэл зөвхөн хослол **болоогүй** мөрүүдийг харж бас болно:  

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # results-ын мөрүүдтэй тохироогүй cases -ын мөрүүд 
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # cases-ын мөрүүдтэй тохироогүй results-ын мөрүүд
```


### Магадлалаар давхардалтыг арилгах {.unnumbered}  

Магадлалаар ижилсүүлсж давхардалт арилгаж бас болно. Давхардалтыг арилгах бусад аргуудын талаар deduplication хэсгээс нэмж уншна уу.
Өмнө нь `cases`гэсэн хүснэгт дээр ажиллаж байсан бол одоо `cases_dup` гэсэн хүснэгттэй ажиллах болно. Үүнд өмнөх хүснэгтээс гаралтай хоёр мөр давхардаж орсноос хоёр мөр илүү бичигдсэн:
"Tony" -г "Anthony"-тай "Marialisa Rodrigues" -г "Maria Rodriguez"-тэй харьцуулж харна уу.  

```{r, echo=F}
## Давхардалдсан мөрүүдийг нэм
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```


Өмнөх жишээний адил `fastLink()` -ийг уншуул. Харин энэ удаа `cases_dup` хүснэгтийг өөртэй нь эргүүлээд харьцуулаарай. Хэрэв хоёр хүснэгт яг адилхан байвал `fastLink()` функц давхардалтыг арилгах ёстой гэж ойлгоно. Нэмж анхааруулахад өмнөх жишээнд `stringdist.match = `,  `numeric.match = ` зэрэг аргументүүдийг хэрэглэж байсан бол энэ удаа хэрэглэхгүй.  

```{r, message = F, warning = F}
## fastlink -ыг ижилхэн хүснэгт дээр дахин уншуул
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

Үүний дараа давхардалт байх магадлалуудыг `getMatches()`-аар шалгаж болно. Хүснэгтээ `dfA = ` болон `dfB = `-д хоёуланд нь оноогоод `fastLink()` -ээс гарах үр дүнг `fl.out = ` аргументэд оруулж өг.  `fl.out` нь `fastLink.dedupe` төрөл буюу `fastLink()` -ын үр дүн байх юм.  


```{r}
## getMatches() -ыг уншуул
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

Үүнээс хамгийн баруун баганыг харвал ID -ын давхардалтыг олох болно. Энд сүүлийн хоёр мөр 2,3 дугаар мөрний давхардалт байх магадлалтай. 

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

Үүний дараа `dedupe.ids` баганад бичигдсэн мөрийн дугаар бүрт ноогдох мөрийн тоог шалгаж давхардалттай мөрүүдийн дугаарыг илрүүлж болно. Ингэхдээ нэгээс их тоотой мөрийг шүүж үзнэ. Жишээнд 2 болон 3 дугаар мөр шүүлтээр гарч ирж байна.  

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

Аль нэг мөртэй давхардсан байж болох мөрүүдийг бүгдийг харах бол дараах командад шалгах мөрийн дугаарыг зааж өгнө:  

```{r}
# 2 дугаар мөрт болон давхардсан байж болох бүх мөрүүүдийг харуулна
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```



## Залгах ба зэрэгцүүлэх 

Хүснэгтүүдийг мөн "залгаж/bind" болно. Үүнийг аливаа хүснэгтэд нэмэлтээр мөр, багана "хавсаргах" гэж ойлгож болно.

Залгахыг тайлбарласны дараа мөрний эрэмбийг өөр нэг хүснэгтийн мөрний эрэмбэтэй "зэрэгцүүлэх" талаар бас энэ  хэсэгт тайлбарлах болно. 



### Мөрийг залгах {.unnumbered}

Нэг хүснэгтийн мөрийг өөр нэг хүснэгтийн доороос залгахдаа **dplyr**-ын `bind_rows()`-ыг хэрэглэж болно. Үүний үр дүнд шинээр үүсэх хүснэгтэд хоёр хүснэгтийн бүх багана орсон байдаг онцлогтой. Анхааруулах зүйлс: 

* **dplyr**-ын `bind_rows()` -ын base R-ын `row.bind()` функцээс гол ялгаагдах онцлог бол залгаж буй хүснэгтүүдийн баганын дараалал ижил байх шаардлагагүй явдал юм. Баганын нэр адилхан нэрлэгдсэн л бол зөв таньж залгаж чаддаг онцлогтой. 
* Мөн `.id = `аргументэд шинэ баганын нэр (карактер нэр) зааж өгснөөр мөр болгонд аль хүснэгтээс гаралтайг харуулсан шинэ багана үүсдэг.
* `bind_rows()` on a `list` of similarly-structured data frames to combine them into one data frame. See an example in the [Iteration, loops, and lists] page involving the import of multiple linelists with **purrr**.  

Мөн  **dplyr**-ын `summarise()`-аар бүтсэн хураангуй хүснэгтэд *нийт* гэсэн мөр залгахад энэ функцыг элбэг хэрэглэдэг.  Дараах жишээнд  тохиодлын тоо болон CT шинжилгээний медиан утгуудыг эмнэлэг тус бүрээр харуулсан хураангуй хүснэгтийг *нийт* гэсэн мөртэйгээр хэрхэн бүтээхийг харуулав.  

Датаг эмнэлэг тус бүрээр бүлэглэж харахын тулд `summarise()` функц ашиглаж хураангуй хүснэгт үүсгэнэ. Энэ үед `summarise()` функц нийт гэсэн мөрийг үүсгэдэхгүй тул датаг дахин `summarise()` коммандад бүлэглэхгүйгээр өгнө. Ингэснээр зөвхөн нэг мөртэй хоёрдах хүснэгт үүснэ. Энэхүү шинээр үүсгэсэн хоёр хүснэгтийг хооронд нь залгаж эцсийн үр дүнд хүрнэ. 

Дээрхитэй төстэй жишээг [Descriptive tables] болон [Tables for presentation] хуудсуудаас үзэж болно.


```{r}
# Үндсэн хүснэгтийг байгуул
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # Датаг эмнэлэг тус бүрээр бүлэглэх
  summarise(                                    # Сонирхсон индикаторуудаар нэтгэсэн хүснэгт байгуул
    cases = n(),                                  # эмнэлэг тус бүрт ноогдох мөрийн тоо     
    ct_value_med = median(ct_blood, na.rm=T))     # бүлэг тус бүрийн CT -ийн медиан утга
```

`hosp_summary` хураангуй хүснэгт:  

```{r message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

*totals* гэсэн хүснэгт байгуул (*эмнэлэг тус бүрээр бүлэглээгүй*). Үүний үр дүнд зөвхөн нэг мөрөөс бүтсэн хүснэгт үүснэ.  

```{r}
# Нийт дүнг бодож гарга
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # Нийт датан дах мөрийн тоо    
    ct_value_med = median(ct_blood, na.rm=T))  # Нийт датаны CT шинжилгээний медиан утга 
```

Доор `totals` мөртэй хүснэгтийг харуулав. Энд зөвхөн хоёр багана байна. Энэ баганууд `hosp_summary` хүснэгтэд мөн байгаа. Харин `totals`-д байхгүй нэг багана `hosp_summary` -д байна (`hospital` багана).  

```{r message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Одоо хүснэгтүүдийг `bind_rows()`-аар залгаж болохоор боллоо.  

```{r}
# Хүснэгтүүдийг залга
combined <- bind_rows(hosp_summary, totals)
```

Үр дүнг харцгаая. `hosp_summary` -д байгаагүй багана болох `hospital` -ын сүүлийн хоосон нүднүүдэд `NA` утга орсон байгааг анзаараарай.  [Tables for presentation] хуудаст тайлбарсанчлан, энэ нүднүүдийг `replace_na()`-г ашиглаж "Нийт" дүнгээр "бөглөх" боломжтой.

```{r message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```


### Баганыг залгах {.unnumbered}

Хоёр хүснэгтийг хажуу талаас нь залгадаг **dplyr** - ын өөр нэг функцыг `bind_cols()` гэдэг. Мөрүүд зөвхөн *байрлалын дагуу* ( *join* -аас ялгаатай) залгагдах болно. Жишээ нь нэг хүснэгтийн 12 дугаар мөр нөгөө хүснэгтийн 12 дугаар мөртэй зэрэгцэж залгагдна. 

Олон хураангуй хүснэгтүүдийг хооронд нь залгахыг жишээгээр дор харууллаа. Юуны түрүүнд зэрэгцэж залгагдах мөрүүдийг зөв тааруулах үүднээс `match()` функцыг хэрхэн ашиглахыг тайлбарлая.    

Доор linelist хүснэгтийн нас баралт, тохиолдлын тоог эмнэлэг тус бүрээр бүлэглэж  `case_info` гэсэн хураангуй хүснэгт болгосон байна.


```{r}
# Тохиолдлын мэдээлэл
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Харин халдварт өртсөн хавьтлуудын шалгагдсан хувийг эмнэлэг тус бүрээр бүлэглэж `contact_fu` гэсэн хураангуй хүснэгт үүсгэсэн. 

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Энд хоёр хүснэгтийн эмнэлэгийн нэрс ижил боловч эрэмбэ, дараалал өөр байгааг анхаарах хэрэгтэй. Хамгийн хялбар арга бол `hospital` баганыг ашиглаж `left_join()` хийх явдал юм. Харин `bind_cols()` -ыг ашиглах бол нэмэлт нэг алхам хийх шаардлагатай. 

#### `match()`-аар эрэмбийг зэрэгцүүлэх {.unnumbered}  

Мөрийн дараалал ялгаатай тул хүснэгтүүдийг шууд `bind_cols()` к-аар залгавал мөрийн үл тохироо (mismatch) үүснэ. Тиймээс **base** R -ын `match()` функцээр мөрүүдийг ижил дараалалд эхлээд оруулах хэрэгтэй. Ингэхдээ хоёр хүснэгтэд давхардсан мөр байхгүй гэж тооцно.  

`match()`-ын синтакс нь `match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE)` юм. Эхний аргументээр зорилтот дараалал (дан вектор, эсвэл хүснэгтийн багана), хоёр дах аргументээр эрэмбийг өөрчлөхөөр сонгосон хүснэгтийн багана байх болно. Үүний үр дүнд зөв эрэмбийн байрлалыг заасан тоон вектор үүсдэг. Энэ талаар `?match` комманд өгч илүү танилцаж болно.  

```{r}
match(case_info$hospital, contact_fu$hospital)
```

Энэхүү тоон векторын дугаарыг ашиглан эрэмбийг өөрчилж болно. Ингэхдээ `[ ]` хаалтанд векторыг оруулж,*таслал* ард нь тавьна.  Үүний нэмэлт тайлбарыг **base** R -ын таслалаар хэрхэн датаг тасалж авах [R basics] хуудаст тайлбарласнаас харна уу. The command below creates a new data frame, defined as the old one in which the rows are ordered in the numeric vector above.  

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```


```{r message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Одоо хүснэгтүүдийн эрэмбэ тохирч буй тул хооронд нь залгахад бэлэн боллоо. Зарим багана давхарддаг тул `rename()`-ээр цэвэрлэх шаардлага гарч болно. `bind_rows()`-ын талаар [here](https://dplyr.tidyverse.org/reference/bind.html) -т илүү нарийн тайлбарласан.  

```{r}
bind_cols(case_info, contact_fu)
```

Үүнээс гадна `bind_cols` тэй ижил үйлдэлтэй **base** R функц `cbind()` -ыг хэрэглэж болно.



<!-- ======================================================= -->
## Эх сурвалж материалууд { }

[tidyverse page on joins](https://dplyr.tidyverse.org/reference/join.html)  

[R for Data Science page on relational data](https://r4ds.had.co.nz/relational-data.html)  

[tidyverse page on dplyr](https://dplyr.tidyverse.org/reference/bind.html) -аас холбох талаарх мэдээлэл

[fastLink](https://github.com/kosukeimai/fastLink) -ын виннетийг Github хуудаснаас 

[fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf) -ын аргачлалын талаарх эрдэм шинжилгээний өгүүлэл

[RecordLinkage package](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)-ын аргачлалын талаарх эрдэм шинжилгээний өгүүлэл




