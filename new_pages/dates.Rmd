# Огноотой ажиллах нь

```{r, out.width=c('50%'), fig.align='center', echo=F, message=F}
knitr::include_graphics(here::here("images", "Dates_500x500.png"))
```

R дээр огноог ашиглах нь бусад объектын төрлүүдтэй ажиллахаас илүү анхаарал шаарддаг. Доор бид энэ үйл явцыг арай хялбар болгохын тулд зарим хэрэгсэл, жишээг санал болгож байна. Аз болоход **lubridate** гэх мэт багцуудын тусламжтайгаар, практик дадлагын үр дүнд огноог хялбархан янзалж чаддаг болно.

Боловсруулаагүй өгөгдлийг R руу импортлох үед огноог ихэвчлэн тэмдэгт (character) обьект хэмээн таньж оруулдаг бөгөөд энэ обьектыг цагийн цуврал хийх, хугацааны интервалыг тооцоолох гэх мэт огнооны ерөнхий үйлдлүүдэд ашиглах боломжгүй байдаг. Дээрээс нь огноог форматлах олон арга байдаг тул та огнооны аль хэсэг нь юу болохыг (сар, өдөр, цаг гэх мэт) танихад нь R-д туслах шаардлагатай болдог нь огноотой ажиллах процессыг улам төвөгтэй болгодог.

R дахь огноо нь өөрсдийн гэсэн объектын ангитай буюу `Date` анги юм. Энд огноо, цаг хоёуланг нь агуулсан объектуудыг хадгалдаг тусгай анги бас байдаг гэдгийг тэмдэглэх нь зүйтэй. Огноо, цагийн объектуудыг албан ёсоор `POSIXt`, `POSIXct` ба/эсвэл `POSIXlt` анги гэж нэрлэдэг (ялгаа нь чухал биш). Эдгээр объектыг албан бусаар *datetime* ангид оруулдаг.

-   Багана нь огноог агуулсан бол R-д тухайн баганыг огноо гэдгийг таниулах нь чухал.

-   Огноо бол объектын ангилал бөгөөд түүнтэй ажиллахад төвөгтэй байдаг.

-   Энд бид огноо агуулсан багануудыг `Date` анги руу хөрвүүлэх хэд хэдэн аргыг танилцуулж байна.

    <!-- ======================================================= -->

## Бэлтгэл

### Багцуудыг ачаалах {.unnumbered}

Доорх кодын хэсэг нь энэ хуудсанд шаардлагатай багцуудын ачааллыг харуулж байна. Энэхүү гарын авлагад бид **pacman** багцаас `p_load()` функцыг онцлон ашиглаж буй бөгөөд энэ функц нь шаардлагатай бол тухайн багцыг шууд суулгаж, ашиглахаар ачаалдаг. Мөн та аль хэдийн суулгасан багцуудыг **base** R-ын `library()` функц ашиглан ачаалж болно. R багцуудын талаар дэлгэрэнгүй мэдээллийг \[R суурь ойлголтууд\] хуудаснаас үзнэ үү.

```{r dates_packages, warning=F, message=F}
# Багц суулгасан эсэхийг шалгаж, шаардлагатай бол суулгаж, одоогийн сесс рүү багцыг ачаална

pacman::p_load(
  lubridate,  # огноог зохицуулах, хөрвүүлэх ерөнхий багц
  linelist,   # замбараагүй огноог "таах" функцтэй 
  aweek,      # огноог долоо хоног, долоо хоногийг огноо болгон хөрвүүлэх өөр сонголт
  zoo,        # нэмэлт огноо/цаг функцүүд
  tidyverse,  # дата менежмент болон дүрслэл
  rio)        # дата импорт/экспорт
```

### Дата импортлох {.unnumbered}

Бид Эбола тахлын зохиомол тохиолдлын датасетийг импортолж байна. Хэрэв та датаг татаж аван алхам алхмаар дагахыг хүсвэл \[Гарын авлага, дата татаж авах\] хуудасны зааврыг харна уу. Бид энэ файлыг ажлын директор дотор байгаа гэж үзэж байгаа тул энэ файлын замд дэд хавтас заагаагүй болно.

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")

```

<!-- ======================================================= -->

## Одоогийн огноо

Та **base** R дээр дараах зүйлийг хийснээр таны компьютерийн одоогийн "систем" огноо эсвэл системийн огнооцагийг авах боломжтой.

```{r}
# системийн огноог авах - энэ бол DATE анги юм
Sys.Date()

# системийн цагийг авах - энэ бол DATETIME анги юм 
Sys.time()
```

**lubridate** багцын тусламжтайгаар эдгээрийг `today()` болон `now()` функцүүдээр тус тус авах боломжтой. `date()` функц нь өдөр, сарын нэрийн хамт одоогийн огноо, цагийг харуулна.

<!-- ======================================================= -->

## Огноо руу хөрвүүлэх

Датасетийг R руу импортлосны дараа огнооны баганын утгууд "1989/12/30", "05/06/2014", эсвэл "2020 оны 1-р сарын 13" гэх мэтээр харагдаж болно. Эдгээр тохиолдолд R нь эдгээр утгуудыг тэмдэгт утга гэж оруулсан байх магадлалтай. Эдгээр утгууд нь огноо мөн... бөгөөд огнооны формат ямар байхыг R-д *хэлж өгөх* шаардлагатай (аль хэсэг нь Өдөр, аль нь Сар, аль нь Жил гэх мэт).

Ингээд хэлээд өгөхөд R эдгээр утгыг `Date` анги руу хөрвүүлдэг. Харин хөшигний цаана R огноог тоогоор хадгална (1970 оны 1-р сарын 1-ний "эх" өдрөөс хойшхи өдрийн тоо). Та огнооны энэхүү тоотой бараг харьцахгүй боловч R огноог ингэж хадгалснаар огноог үргэлжилсэн (continuous) хувьсагч гэж үзэн огноо хоорондын зайг тооцоолох зэрэг тусгай үйлдлүүдийг хийх боломжийг олгодог.

Өгөгдмөлөөр, R дахь `Date` ангийн утгууд нь YYYY-MM-DD хэлбэрээр харагдана. Энэ бүлэгт бид огнооны утгын харагдах байдлыг хэрхэн өөрчлөх талаар харуулах болно.

Доор бид баганыг тэмдэгтийн утгаас `Date` анги руу хөрвүүлэх хоёр аргыг танилцуулж байна.

[***ЗӨВЛӨМЖ:*** Та баганын одоогийн ангийг `class(linelist$date_onset)` зэргээр **base** R-ын `class()`функц ашиглан шалгаж болно. ]{style="color: darkgreen;"}

### **base** R {.unnumbered}

`as.Date()` нь объект эсвэл баганыг `Date` анги руу хөрвүүлдэг стандарт, **base** R функц юм ("D"-н том үсгийг анхаарна уу).

`as.Date()`-г ашиглахад дараахь зүйлийг шаарддаг:

-   Хэрэв та огноог тоогоор оруулж буй бол эх огноог эсвэл огноог *тэмдэгт хэлбэрээр оруулж буй бол **одоо байгаа** форматыг зааж өгнө* (Excel огнооны хэсгийг үзнэ үү)

-   Хэрэв тэмдэгтийн баганад ашигласан бол бүх огнооны утгууд яг ижил форматтай байх ёстой (хэрэв тийм биш бол **linelist** багцын `guess_dates()` функцыг ашиглаж үзнэ үү)

**Эхлээд** баганыхаа ангийг **base** R-ын `class()` функцээр шалгана уу. Хэрэв та датаныхаа ангийн талаар эргэлзэж байвал (жишээ нь "POSIXct" зэрэг анги гараад ирэх үед) эхлээд тухайн баганыг `as.character()` функц ашиглан тэмдэгт анги руу хөрвүүлээд дараа нь Date анги руу хөрвүүлэх нь хамгийн хялбар арга юм.

**Хоёрдугаарт**, `as.Date()` функц дотор `format =` аргументыг ашиглан R-д тэмдэгтийн огнооны бүрэлдэхүүн хэсгүүдийн *одоогийн* форматыг хэлж болно - аль тэмдэгтүүд нь сар, өдөр, жилийг зааж буй болон, тэдгээрийг хэрхэн тусгаарласан зэргийг. Хэрэв таны утгууд аль хэдийн R-ын стандарт огнооны форматын аль нэгэнд байгаа бол ("YYYY-MM-DD" эсвэл "YYYY/MM/DD") `format =` аргумент шаардлагагүй.

Форматлахын (`format =`) тулд доорх тусгай "strptime" товчлолуудыг ашиглан *одоогийн* огнооны форматыг илэрхийлэх тэмдэгтийн стрингийг (ишлэл дотор) оруулна. Жишээлбэл, хэрэв таны тэмдэгтийн огноо "24/04/1968" гэх мэт "DD/MM/YYYY" форматтай байгаа бол `format = "%d/%m/%Y"` ашиглан утгуудыг огноо руу хөрвүүлнэ. **Форматыг ишлэл дотор оруулах шаардлагатай. Мөн ташуу зураас, зураасыг бүү мартаарай!**

```{r eval=F}
# Date анги руу хөрвүүлэх
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

Ихэнх strptime товчиллуудыг доор жагсаав. Та `?strptime` командыг ажиллуулан бүрэн жагсаалтыг харах боломжтой.

%d = Сарын өдрийн дугаар (5, 17, 28 гэх мэт)\
%j = Жилийн өдрийн дугаар (Жулиан өдөр 001-366)\
%a = Товчилсон ажлын өдөр (Mon, Tue, Wed гэх мэт)\
%A = Бүтэн ажлын өдөр (Monday, Tuesday гэх мэт)

%w = Ажлын өдрийн дугаар (0-6, Ням гараг 0)\
%u = Ажлын өдрийн дугаар (1-7, Даваа гараг 1)\
%W = Долоо хоногийн дугаар (00-53, Даваа гараг долоо хоногийн эхлэл)\
%U = Долоо хоногийн дугаар (01-53, Ням гараг долоо хоногийн эхлэл)\
%m = Сарын дугаар (жишээ нь 01, 02, 03, 04)\
%b = Товчилсон сар (Jan, Feb гэх мэт)\
%B = Бүтэн сар (January, February гэх мэт)\
%y = 2-оронтой жил (жишээ нь 89)\
%Y = 4-оронтой жил (жишээ нь 1989)\
%h = цаг (24 цагийн цаг)\
%m = минут\
%s = секунд

%z = GMT-ээс офсет\
%Z = Цагийн бүс (тэмдэгт)

[***ЗӨВЛӨМЖ:*** `as.Date()`-ын `format =` аргумент нь таны хүсэж буй огнооны форматыг R-д хэлж буй биш бөгөөд харин командыг ажиллуулахын *өмнө* огнооны ямар хэсгүүд байгааг R-д зааж өгч буйг хэлж байгаа юм.]{style="color: darkgreen;"}

[***ЗӨВЛӨМЖ:*** `format =` аргументад таны оруулж буй огноонд байгаа *огнооны-хэсэг тусгаарлагчийг* (жишээ нь, /, -, эсвэл зай) ашиглахаа мартаж болохгүй. ]{style="color: darkgreen;"}

Утгууд нь Date ангид орсны дараа R нь тэдгээрийг стандарт формат болох YYYY-MM-DD байдлаар харуулах болно.

### **lubridate** {.unnumbered}

**lubridate** багцыг ашигласнаар тэмдэгтийн объектуудыг огноо руу хөрвүүлэх нь илүү хялбар болно. Энэ багц нь огноо, цагтай ажиллах явцыг **base** R-аас илүү энгийн бөгөөд тогтвортой болгоход зориулагдсан **tidyverse**-ийн багц юм. Эдгээр шалтгааны улмаас **lubridate**-г ихэвчлэн огноо, цагийн хувьд алтан стандартын багц гэж үздэг бөгөөд тэдэнтэй ажиллах бүрт хэрэглэхийг зөвлөдөг.

**lubridate** багц тэмдэгтийн объектуудыг огноо руу хөрвүүлэхэд зориулсан хэд хэдэн туслах функцээр хангадаг бөгөөд эдгээр нь `as.Date()`-д форматыг зааж өгөхөөс илүү хялбар бөгөөд ойлгомжтой байдаг. Эдгээр функцууд нь огнооны форматуудын товчлолын нэрээр нэрлэгдсэн бөгөөд тэдгээр нь тухайн огнооны форматтай тусгай холбоотой боловч төрөл бүрийн ялгагч, огнооны синоним (жишээ нь, 01 vs Jan vs January гэх мэт) ашиглах боломж олгодог.

```{r, }
# lubridate суулгах/ачаалах
pacman::p_load(lubridate)
```

`ymd()` функц нь огнооны утгыг **жил, сар, өдөр** гэсэн дараалалтай болгон хувиргадаг.

```{r}
# огноог жил-сар-өдөр хэлбэрээр унших
ymd("2020-10-11")
ymd("20201011")
```

`mdy()` функц нь **сар, өдөр, жил** гэсэн дарааллаар өгсөн огнооны утгыг уян хатан байдлаар хөрвүүлдэг.

```{r}
# огноог сар-өдөр-жил форматаар унших
mdy("10/11/2020")
mdy("Oct 11 20")
```

`dmy()` функц нь **өдөр, сар, жил** гэсэн дарааллаар өгсөн огнооны утгыг уян хатан байдлаар хөрвүүлдэг.

```{r}
# огноог өдөр-сар-жил форматаар унших
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- The `as.character()` and `as.Date()` commands can optionally be combined as:   -->

<!-- ```{r eval=F} -->

<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->

<!-- ``` -->

Хэрэв пайп ашиглаж байгаа бол тэмдэгтийн баганыг **lubridate** ашиглан огноо руу хөрвүүлэх нь дараах байдалтай байж болно:

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

Дууссаны дараа та баганын ангийг шалгахын тулд `class()` ажиллуулж болно.

```{r, eval=F}
# Баганын ангийг шалгах
class(linelist$date_onset)  
```

Утгууд нь Date ангид орсны дараа R нь тэдгээрийг стандарт формат болох YYYY-MM-DD байдлаар харуулах болно.

Дээрх функцууд 4 оронтой жил бүхий форматтай хамгийн сайн ажилладаг гэдгийг анхаарна уу. 2 оронтой жил ашиглахад **lubridate** зууныг нь таах гэж оролддог тул төсөөлөөгүй үр дүнд хүргэж болзошгүй.

2 оронтой жилийг 4 оронтой жил (нэг зууны) болгон хөрвүүлэхийн тулд та эхлээд тэмдэгт анги руу хөрвүүлж, дараа нь **stringr** багцын `str_glue()` функц ашиглан одоо байгаа цифрүүдийн өмнө pre-fix нэмэн нэгтгэж болно (\[Тэмдэгтүүд болон стрингүүд бүлгийг харна уу\]). Үүний дараа нь огноо руу хөрвүүлнэ.

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```

### Багануудыг нэгтгэх {.unnumbered}

Та олон тоон багануудыг нэг огнооны баганад нэгтгэхийн тулд **lubridate** багцын `make_date()` болон `make_datetime()` функцуудыг ашиглаж болно. Жишээлбэл, хэрэв таны `linelist` датафрэймд `onset_day`, `onset_month`, `onset_year` гэсэн тоон баганууд байгаа бол:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```

<!-- ======================================================= -->

## Excel огноо

Ихэнх программ хангамжууд огноог тоогоор хадгалдаг. R нь 1970 оны 1-р сарын 1-нийг эх өдөр болгон түүнээс хойш тоолон огноог хадгалдаг. Тиймээс хэрэв та `as.numeric(as.Date("1970-01-01))` гэж ажиллуулбал `0` гарах болно.

Microsoft Excel нь таны үйлдлийн системээс хамааран 1899 оны 12-р сарын 30 (Windows) эсвэл 1904 оны 1-р сарын 1-нээр (Mac) эх болгон огноог хадгалдаг. Дэлгэрэнгүй мэдээллийг энэхүү [Microsoft-ын заавраас](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system) үзнэ үү.

Excel-ийн огноо нь ихэвчлэн R руу орохдоо тэмдэгтийн оронд эдгээр тоон утгууд байдлаар импортлогддог. Хэрэв таны Excel-ээс импортолсон датасетийн огноог "41369" гэх мэт тоо эсвэл тэмдэгтээр харуулсан бол хөрвүүлэхийн тулд `as.Date()` (эсвэл **lubridate**-ийн `as_date()` функцийг) ашиглана уу. Гэхдээ **дээрх шиг "формат" өгөхийн оронд `origin =` аргументэд Excel-ийн эх огноог өгнө**.

Хэрэв Excel-ийн огноог R-д тэмдэгтийн хэлбэрээр хадгалсан бол энэ нь ажиллахгүй тул огнооны тоо нь Тоон анги эсэхийг шалгаарай!

[***ТЭМДЭГЛЭЛ:*** Та R-ийн анхдагч огнооны форматаар ("YYYY-MM-DD") эх огноог оруулах шаардлагатай.]{style="color: black;"}

```{r, eval = FALSE}
# Excel-ийн тоон огноог хөрвүүлэхдээ Excel-ийн "эх огноо"-г өгөх жишээ
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # тоон ангитай байхыг бататгах
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # Excel эх огноо ашиглан огноо руу хөрвүүлэх
```

<!-- ======================================================= -->

## Эмх цэгцгүй огноо

**linelist** багцын `guess_dates()` функц нь олон янзын форматтай огноог агуулсан "замбараагүй" огнооны баганыг уншиж, огноог стандарт формат руу хөрвүүлэхийг оролддог. Та [онлайнаар `guess_dates()`-ын талаар илүү ихийг уншиж](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html) болно. Хэрэв `guess_dates()` функцын R 4.0.2-д зориулсан хувилбар CRAN дээр байхгүй бол `pacman::p_load_gh("reconhub/linelist")` командаар суулгаж ашиглана уу.

Жишээлбэл, `guess_dates` нь "2018 оны 1-р сарын 03", "07/03/1982", "08/20/85" гэсэн тэмдэгтийн огнооны векторыг хараад дараах Огноо ангилал руу хөрвүүлнэ: `2018-01-03`, `1982-03-07`, `1985-08-20`.

```{r, }
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

Таны `guess_dates()` функцэд оруулж болох нэмэлт аргументууд:

-   `error_tolerance` - Огноог тодорхойлох боломжгүй оруулгуудын эзлэх хувийн зөвшөөрөгдөх хэмжээ (өгөгдмөл нь 0.1 эсвэл 10%)

-   `last_date` - сүүлчийн хүчинтэй огноо (өгөгдмөл нь одоогийн огноо)

-   `first_date` - эхний хүчинтэй огноо. Өгөгдмөл нь `last_date`-ээс тавин жилийн өмнөх огноо.

```{r eval = FALSE}
# guess_dates-г date_onset багана дээр ашигласан жишээ
linelist <- linelist %>%                 # linelist датасет
  mutate(
    date_onset = linelist::guess_dates(  # "linelist" багцын guess_dates() функц
      date_onset,
      error_tolerance = 0.1,
      first_date = "2016-01-01"
    )
```

<!-- ======================================================= -->

## date-time ангитай ажиллах

Өмнө дурьдсанчлан, R нь огноо болон цагийн мэдээллийг агуулсан `datetime` ангийг дэмждэг. Date ангийн нэгэн адил эдгээрийг ихэвчлэн тэмдэгтийн объектоос `datetime` объект руу хөрвүүлэх шаардлагатай болдог.

### Цаг агуулсан огноог хөрвүүлэх {.unnumbered}

Стандарт `datetime` объект нь эхлээд огноогоор форматлагдсан бөгөөд дараа нь цагийн бүрэлдэхүүн хэсэг орно - жишээлбэл *2020 оны 1-р сарын 01, 16:30*. Огнооны нэгэн адил үүнийг форматлах олон арга байдаг бөгөөд мөн олон түвшний нарийвчлал (цаг, минут, секунд) байдаг.

Аз болоход эдгээр стрингүүдийг `datetime` объект руу хөрвүүлэх **lubridate**-ийн туслах функцууд бас байдаг. Эдгээр функцууд нь төгсгөлд нь `_h` (зөвхөн цаг), `_hm` (цаг, минут) эсвэл `_hms` (цаг, минут, секунд) нэмж хавсаргасан огнооны туслах функцүүдийн өргөтгөлүүд юм (жишээ нь, `dmy_hms()`). Эдгээрийг дараах байдлаар ашиглаж болно:

Зөвхөн цаг агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

Цаг, минут агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
dmy_hm("01 January 2020 16:20")
```

Цаг, минут, секунд агуулсан огноо, цагийг datetime объект руу хөрвүүлэх

```{r}
mdy_hms("01 January 2020, 16:20:40")
```

Та цагийн бүсийг өгч болно, гэхдээ үүнийг ашигладаггүй. Цагийн бүсийн талаар энэ бүлгийн сүүл хэсгийг үзнэ үү.

```{r}
mdy_hms("01 January 2020, 16:20:40 PST")

```

Датафрэймтэй ажиллахдаа **stringr** багцын `str_glue()` функц ба тохирох **lubridate** функцийг ашиглан цаг, огнооны баганыг нэгтгэн datetime багана үүсгэж болно. **stringr** багцын талаарх дэлгэрэнгүй мэдээллийг \[Тэмдэгтүүд болон стрингүүд\] хуудаснаас үзнэ үү.

Энэ жишээнд `linelist` датафрэйм нь "цаг:минут" формат бүхий баганатай байна. Үүнийг datetime болгон хөрвүүлэхийн тулд бид хэд хэдэн алхмуудыг дагана:

Тухайн баганын голч утга ашиглан хоосон утгыг дүүргэсэн эмнэлэгт хэвтэлтийн "цэвэр" цагийн багана үүсгэнэ. **lubridate** багц хоосон утгууд дээр ажиллахгүй тул бид үүнийг хийж буй юм. Үүнийг `date_hospitalisation` баганатай нэгтгээд `ymd_hm()` функцийг ашиглан хөрвүүлнэ.

```{r, eval = FALSE}
# багцууд
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission багана нь цаг:минут бүхий форматтай
linelist <- linelist %>%
  
  # эмнэлэгт хэвтэлтийн цаг байхгүй тохиолдолд хэвтэлтийн голч хугацааг онооно
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # цаг хоосон байгаа үед
      median(time_admission),        # голч утгыг онооно
      time_admission                 # хоосон биш байвал хэвээр үлдээнэ
  ) %>%
  
    # str_glue() ашиглан огноо, цагийн багануудыг нэгтгэж нэг тэмдэгт багана үүсгэнэ 
    # дараа нь ymd_hm()-г ашиглан datetime руу хөрвүүлнэ
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```

### Зөвхөн цагийг хөрвүүлэх {.unnumbered}

Хэрэв таны датанд зөвхөн хугацаа (цаг, минут) тэмдэгт байдлаар агуулагдаж байвал та **base** R-ын `strptime()`-г ашиглан тэдгээрийг цаг болгон хувиргаж, өөрчлөх боломжтой. Жишээлбэл, эдгээр хоёр цагийн зөрүүг олж авахын тулд:

```{r}
# тэмдэгт ангийн цагууд
time1 <- "13:45" 
time2 <- "15:20"

# Цагуудыг datetime анги руу хөрвүүлнэ
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# Ялгаа нь "difftime" анги бөгөөд энд тоон цаг руу хөрвүүлж байна 
as.numeric(time2_clean - time1_clean)   # цагийн зөрүү

```

Гэхдээ огнооны утгыг заагаагүй бол огноог өнөөдөр гэж тооцдог гэдгийг анхаарна уу. **stringr** багцыг ашиглан стринг огноо болон стринг цагийг хэрхэн нэгтгэх талаар дээрх хэсгээс харна уу. `strptime()`-ийн талаар [эндээс](https://rdrr.io/r/base/strptime.html) уншина уу.

Нэг оронтой тоог хоёр оронтой тоонд хөрвүүлэхийн тулд (жишээ нь, 2 оронтой болохын тулд цаг эсвэл минутын урд тэг оруулж дэвсэх) ["Тэмдэгтүүд болон стрингүүд" хуудасны "Дэвсэх урт" хэсгийг](#str_pad) үзнэ үү.

### Цагийг гаргаж авах {.unnumbered}

Та **lubridate** багцын `hour()`, `minute()`, `second()` функцүүдийг ашиглан цагийн элементүүдийг гаргаж авч болно.

Цагийг гаргаж аваад өдрийн нэг хэсгээр нь ангилах жишээ энд байна. Бид "HH:MM" форматтай Тэмдэгт ангийн `time_admission` баганаас эхэлнэ. Нэгдүгээрт, тэмдэгтүүдийг datetime анги руу хөрвүүлэхийн тулд дээр дурдсанчлан `strptime()` ашигладаг. Дараа нь цагийг `hour()` функцээр гаргаж авахад 0-24 хүртэлх тооны аль нэг гарч ирнэ. Эцэст нь, эмнэлэгт хэвтсэн цагийг логик мэдэгдлүүд ашиглан `case_when()` функцын тусламжтайгаар Өглөө/Үдээс/Орой/Шөнө гэж ангилсан `time_period` хэмээх шинэ багана үүсгэж байна.

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

`case_when()` функцын талаар илүү ихийг мэдэхийг хүсвэл \[Дата цэвэрлэх болон үндсэн функцууд\] хуудаснаас үзнэ үү.

<!-- ======================================================= -->

## Огноотой ажиллах

**lubridate** багцыг **date/datetime** **багануудын хэсгийг гаргаж авах, огноон дээр арифметик хийх, огнооны интервалыг тооцоолох** зэрэг олон төрлийн функцэд ашиглаж болно.

Энд бид жишээнүүдэд ашиглах огноог тодорхойллоо:

```{r, }
# Date ангийн объект үүсгэх
example_date <- ymd("2020-03-01")
```

### Огнооны бүрэлдэхүүн хэсгүүдийг гаргаж авах {.unnumbered}

Та сар, өдөр, ажлын өдөр гэх мэт нийтлэг талуудыг гаргаж авч болно:

```{r}
month(example_date)  # сарын дугаар
day(example_date)    # сарын өдөр (дугаар)
wday(example_date)   # долоо хоногийн өдрийн дугаар (1-7)
```

Та мөн `datetime` объект эсвэл баганаас цагийн бүрэлдэхүүн хэсгүүдийг гаргаж авах боломжтой. Хэрэв та эмнэлэгт хэвтсэн цагийн тархалтыг харахыг хүсвэл энэ нь хэрэг болно.

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # цаг гаргаж авах
minute(example_datetime)   # минут гаргаж авах
second(example_datetime)   # секунд гаргаж авах
```

Долоо хоногуудыг харах хэд хэдэн сонголт байдаг. Доорх Эпидемиологийн долоо хоногийн хэсгийг үзнэ үү.

Хэрэв та огноог тодорхой байдлаар *харуулахыг* хүсч байгаа бол (жишээ нь "2020 оны 1-р сар" эсвэл "3-р сары 20-ны Пүрэв гараг" эсвэл "1977 оны 20-р долоо хоног") үүнийг Огноо харуулах хэсэгт тайлбарласны дагуу илүү уян хатан байдлаар хийж болно.

### Огнооны математик {.unnumbered}

Та **lubridate** багцаас тус тусын функцийг ашиглан тодорхой тооны өдөр, долоо хоног нэмж болно.

```{r}
# энэхүү огноо руу 3 өдөр нэмэх
example_date + days(3)
  
# энэ огноо дээр 7 долоо хоног нэмж, хоёр өдрийг хас
example_date + weeks(7) - days(2)
```

### Огнооны интервал {.unnumbered}

Огноо хоорондын зөрүүг дараах байдлаар тооцоолж болно:

1.  Хоёр огноо нь хоёулаа `date` анги мөн эсэхийг шалгана

2.  Хоёр огнооны хоорондох "difftime" зөрүүг гаргахын тулд хасаж болно

3.  Шаардлагатай бол дараагийн математик тооцооллыг хийхийн тулд гарсан үр дүнг тоон анги руу хөрвүүлнэ

Доор хоёр огнооны хоорондох интервалыг тооцон харуулж байна. Огноо ангийн утгууд дээр "хасах" тэмдгийг ашиглан интервалыг олох боломжтой. Гэсэн хэдий ч буцаасан утгын анги нь доор үзүүлсэн шиг "difftime" бөгөөд тоон хэлбэрт хөрвүүлэх ёстой гэдгийг анхаарна уу.

```{r}
# Жишээ огнооноос 2020 оны 2-р сарын 20-ны хоорондох зайг ол 
output <- example_date - ymd("2020-02-20")
output    # хэвлэ
class(output)
```

"Dfftime" дээр дараагийн үйлдлүүдийг хийхийн тулд үүнийг `as.numeric()` ашиглан тоон хэлбэрт хөрвүүлнэ.

Дата ажиллах үед энэ бүгдийг нэгтгэж болно - жишээлбэл:

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # багцууд ачааллах

linelist <- linelist %>%
  
  # dmy форматыг зааж өгснөөр шинж тэмдэг эхэлсэн огноог тэмдэгтээс огноо болгон хувиргана 
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # Гуравдугаар сард шинж тэмдэг нь эхлээгүй бүх тохиолдлыг шүүж хасна
  filter(month(date_onset) == 3) %>%
    
  # шинж тэмдэг эхэлсэн ба эмнэлэгт хэвтсэн өдрүүдийн хоорондох зөрүүг ол
  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)
```

Датафрэймтэй ажиллах үед тодорхой мөр дээр дээрх огнооны аль нэг нь байхгүй бол тухайн мөрийн хувьд энэхүү үйл ажиллагаа амжилтгүй болно. Үүний үр дүнд тоон утгын оронд `NA` гарч ирнэ. Тиймээс энэ баганыг тооцоололд ашиглахдаа `na.rm =` аргументыг `TRUE` гэж тохируулахаа мартуузай. Жишээлбэл:

```{r, eval = FALSE}
# Дата байгаа бүх тохиолдлын хувьд эмнэлэгт хэвтэх хоногийн голч утгыг тооцоол
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```

<!-- ======================================================= -->

## Огноо харуулах

Огноог зөв ангид хөрвүүлсний дараа та тэдгээрийг зарим тохиолдолд өөрөөр жишээлбэл "2018-01-05"-ны оронд "1-р сарын 05-ны Даваа" гэж харуулахыг хүсдэг. Та мөн харагдаж буй огнооны элементүүдээр мөрүүдийг бүлэглэхийн тулд харагдах байдлыг өөрчлөх хэрэгтэй болж магадгүй - жишээлбэл сар жилээр бүлэглэх.

### `format()` {.unnumbered}

**base** R-ын `format()` функцээр огнооны харагдах байдлыг тохируулж болно. Энэ функц нь "%" strptime товчлол (`as.Date()`-д ашигласантай ижил синтакс) бүхий хүсэж буй форматыг зааж өгсөн тэмдэгтийн стрингийг (ишлэлд) хүлээн авдаг. Хамгийн түгээмэл товчлолуудыг доор харуулав.

Тэмдэглэл: `format()`-ыг ашигласнаар утгуудыг Тэмдэгт анги руу хөрвүүлэх тул үүнийг ерөнхийдөө дүн шинжилгээний төгсгөлд эсвэл зөвхөн харуулах зорилгоор ашигладаг! Та `?strptime`-г ажиллуулснаар бүрэн жагсаалтыг харах боломжтой.

%d = Сарын өдрийн дугаар (5, 17, 28 гэх мэт)\
%j = Жилийн өдрийн дугаар (Жулиан өдөр 001-366)\
%a = Товчилсон ажлын өдөр (Mon, Tue, Wed гэх мэт)\
%A = Бүтэн ажлын өдөр (Monday, Tuesday гэх мэт)

%w = Ажлын өдрийн дугаар (0-6, Ням гараг 0)\
%u = Ажлын өдрийн дугаар (1-7, Даваа гараг 1)\
%W = Долоо хоногийн дугаар (00-53, Даваа гараг долоо хоногийн эхлэл)\
%U = Долоо хоногийн дугаар (01-53, Ням гараг долоо хоногийн эхлэл)\
%m = Сарын дугаар (жишээ нь 01, 02, 03, 04)\
%b = Товчилсон сар (Jan, Feb гэх мэт)\
%B = Бүтэн сар (January, February гэх мэт)\
%y = 2-оронтой жил (жишээ нь 89)\
%Y = 4-оронтой жил (жишээ нь 1989)\
%h = цаг (24 цагийн цаг)\
%m = минут\
%s = секунд

%z = GMT-ээс офсет\
%Z = Цагийн бүс (тэмдэгт)

Өнөөдрийн огноог форматлах жишээ:

```{r}
# форматтай өнөөдрийн огноо
format(Sys.Date(), format = "%d %B %Y")

# огноо, цагийг бүрэн авах хялбар арга (өгөгдмөл формат)
date()

# str_glue() функцийг ашиглан форматласан нэгтгэсэн огноо, цаг, цагийн бүс
str_glue("{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}")

# Долоо хоногуудыг харуулах форматыг ашиглах
format(Sys.Date(), "%Y Week %W")
```

Хэрэв `str_glue()` ашиглаж байгаа бол давхар ишлэл " дотор зөвхөн ганц ишлэл ' (дээрх шиг) ашиглах ёстойг анхаарна уу.

### Сар-жил {.unnumbered}

Огноо баганыг Сар-жил формат руу хөрвүүлэхийн тулд **zoo** багцаас `as.yearmon()` функцийг ашиглахыг зөвлөж байна. Энэ нь огноог "yearmon" анги руу хувиргаж, зохих дарааллыг хадгална. Үүнтэй харьцуулахад, `format(column, "%Y %B")` ашиглавал Тэмдэгт анги руу хөрвүүлэх ба утгуудыг цагаан толгойн дарааллаар (буруу) дараалуулна.

Доор, `date_onset` баганаас `as.yearmon()` функцийг ашиглан `yearmonth` шинэ багана үүсгэсэн байна. Үр дүнгийн утгуудын анхдагч (зөв) дарааллыг хүснэгтэд үзүүлэв.

```{r}
# шинэ багана үүсгэх
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# хүснэгт хэвлэх
table(test_zoo$yearmon)
```

Үүнтэй харьцуулахад, та зөвхөн `format()`-ыг ашигласнаар хэрхэн хүссэн харагдах байдлын форматтай болж буй боловч зөв дараалалгүй болохыг харж болно.

```{r}
# шинэ багана үүсгэх
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# хүснэгт хэвлэх
table(test_format$yearmon)
```

Тэмдэглэл: Хэрэв та `ggplot()` дээр ажиллаж байгаа бөгөөд зөвхөн огноог хэрхэн харуулахыг тохируулахыг хүсвэл `scale_x_date()` функцийн `date_labels =` аргументад strptime формат оруулахад хангалттай. Жишээ нь та `"%b %Y"` эсвэл `"%Y %b"` ашиглаж болно. \[ggplot зөвлөмж\] хуудсыг үзнэ үү.

**zoo** нь мөн `as.yearqtr()` функцийг санал болгодог бөгөөд та `ggplot()` ашиглахдаа `scale_x_yearmon()`-г ашиглаж болно.

<!-- ======================================================= -->

## Эпидемиологийн долоо хоног {#dates_epi_wks}

### **lubridate** {.unnumbered}

Датаг огноогоор нь бүлэглэх илүү өргөн хүрээний жишээнүүдийг \[Дата бүлэглэх\] хуудаснаас үзнэ үү. Доор бид өгөгдлийг долоо хоногоор бүлэглэх талаар товч тайлбарлав.

Бид ерөнхийдөө `lubridate`-ын `floor_date()` функцийг `unit = "week"` аргументын хамт ашиглахыг зөвлөж байна. Энэ нь `week_start =` аргументаар тодорхойлогдсоны дагуу огноог долоо хоногийн "эхлэл" хүртэл доош нь бүхэлддэг. Долоо хоногийн өгөгдмөл эхлэл нь 1 (Даваа гаригт) гэхдээ та долоо хоногийн аль ч өдрийг эхлэл гэж зааж өгч болно (жишээ нь, Ням гарагт 7). `floor_date()` нь олон талтай бөгөөд `unit =` аргументыг "second", "minute", "hour", "day", "month" эсвэл "year" болгон тохируулснаар төрөл бүрийн хугацааны нэгж рүү бүхэлдэхэд ашиглаж болно.

Буцаасан утга нь Date анги бүхий долоо хоногийн эхлэх огноо юм. Date анги нь `ggplot()`-д амархан танигдаж, зөв ​​эрэмбэлэгддэг тул дата зураглахад тун хэрэгтэй байдаг.

Хэрэв та зөвхөн график дотор огноог долоо хоногоор *харуулахыг* сонирхож байгаа бол энэ хуудасны Огноо харуулах хэсгийг үзнэ үү. Жишээлбэл, тархварзүйн муруйг зурахдаа та хүссэн strptime "%" товчлолоо өгснөөр огнооны харагдах байдлыг форматлаж болно. Жишээ нь, "%Y-%W" эсвэл "%Y-%U"-г ашиглан жил, долоо хоногийн дугаарыг буцаана (Даваа эсвэл Ням гарагийн долоо хоногийн эхлэлүүд тус бүрт).

### Долоо хоног тутмын тоо {.unnumbered}

`count()`, `group_by()` болон `summarise()` ашиглан дата бүлэглэх талаар дэлгэрэнгүй тайлбарыг \[Дата бүлэглэх\] хуудаснаас үзнэ үү. Товч жишээг доор харуулав.

1.  Шинэ "week" баганыг `floor_date()`-ыг `unit = "week"` аргументын хамт `mutate()` ашиглан үүсгэнэ.

2.  `count()` функцээр долоо хоног тутмын мөрийн (тохиолдлын) тоог авна; хоосон огноотой тохиолдлуудыг шүүн хасна

3.  *Бүх* долоо хоногууд мөр/тохиолдолгүй байсан ч гэсэн датанд гарч ирэхийг баталгаажуулахын тулд **tidyr** багцын `complete()` функцийг ашиглан дуусгана. Анхдагч байдлаар аливаа "шинэ" мөрүүдийн тоон утгууд нь `NA` байна, гэхдээ та тэдгээрийг нэрлэсэн лист хүлээж авдаг `fill =` аргументын тусламжтайгаар 0 болгож болно (доор, `n` нь тооны баганын нэр).

```{r}
# Долоо хоног тутмын тохиолдлын тооны нэгдсэн датасет үүсгэх
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # хоосон шинж тэмдэг эхэлсэн огноо бүхий тохиолдлуудыг хасах
  mutate(weekly_cases = floor_date(   #  шинж тэмдэг эхэлсэн долоо хоног хэмээх шинэ багана үүсгэх
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # датаг долоо хоногоор бүлэглэж, бүлэг бүрт мөр тоолох ('n' багана үүсгэх) 
  tidyr::complete(                  # тохиолдол бүртгэгдээгүй байсан ч гэсэн бүх долоо хоногууд байгааг хангах
    weekly_cases = seq.Date(          # "weekly_cases" баганыг бүрэн дараалал болгон дахин тодорхойлох
      from = min(weekly_cases),       # хамгийн бага огнооноос
      to = max(weekly_cases),         # хамгийн дээд огноо хүртэл
      by = "week"),                   # 7 хоногоор
    fill = list(n = 0))             # n тооны баганад NA-г 0-ээр бөглөх
```

Энд шинээр үүссэн датафрэймийн эхний мөрүүд байна:

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Epiweek хувилбарууд {.unnumbered}

**lubridate** нь мөн `week()`, `epiweek()`, `isoweek()` гэсэн тус бүр нь бага зэрэг өөр эхлэх огноо болон бусад нюансууд бүхий функцуудтай болно. Гэхдээ ихэнх тохиолдолд `floor_date()` нь танд хэрэг болох ганц функц байдаг. Эдгээр функцүүдийн дэлгэрэнгүйг консол руу `?week` гэж оруулснаар эсвэл [эндээс](https://www.rdocumentation.org/packages/lubridate/versions/1.7.4/topics/week) баримт бичгийг уншина уу.

Та эпидемиологийн долоо хоногийг тогтоохын тулд **aweek** багцыг мөн ашиглаж болно. Та энэ талаар [RECON вэбсайтаас](https://www.repidemicsconsortium.org/aweek/) илүү ихийг уншиж болно. Энэ нь `date2week()` болон `week2date()` функцтэй бөгөөд долоо хоногийн эхлэх өдрийг `week_start = "Monday"` аргументээр тохируулах боломжтой. Хэрэв та "долоо хоног" маягийн гаралтыг (жишээ нь "2020-W12") авахыг хүсвэл энэ багц хамгийн хялбар юм. **aweek** багцын өөр нэг давуу тал нь `date2week()`-г огнооны баганад хэрэглэх үед буцаасан багана (долоо хоногийн формат) автоматаар Фактор анги болон тухайн хугацааны бүх долоо хоногийн түвшнийг багтаадаг (ингэснээр дээр үзүүлсэн `complete()` функцын нэмэлт алхамаас зайлсхийдэг). Гэсэн хэдий ч **aweek** багцад огноог сар, жил гэх мэт бусад цагийн нэгж рүү бүхэлдэх функц байхгүй.

"Долоо хоног" форматыг ("2020 W12") харуулахад тохиромжтой цаг хугацааны цувралын өөр нэг хувилбар бол \[Цагийн цуваа ба дэгдэлт илрүүлэх\] хуудсанд үзүүлсэн шиг **tsibble** багцын `yearweek()` функц юм.

<!-- ======================================================= -->

## Огноо/цагийн бүсийг хөрвүүлэх

Өөр өөр цагийн бүсийн дата байгаа үед энэ датаг нэгдсэн цагийн бүсэд оруулан стандартчилах нь ихэвчлэн чухал байдаг. Ихэнх тохиолдолд датаны цагийн бүсийн бүрэлдэхүүн хэсгийг гараар кодлох шаардлагатай байдаг тул энэ нь нэмэлт бэрхшээл учруулдаг.

R-д *datetime* объект бүр цагийн бүсийн бүрэлдэхүүнтэй байна. Бүх огнооны объектууд нь өгөгдмөл байдлаар ашиглаж буй компьютерийн орон нутгийн цагийн бүсийг агуулдаг бөгөөд цагийн бүсүүд ихэвчлэн зуны цагаар өөрчлөгддөг тул энэ нь ерөнхийдөө нэрлэсэн цагийн бүсээс илүү *тухайн байршилд* зориулагдсан байдаг. Огнооны баганыг харуулсан үйл явдлыг тодорхой цаг хугацаанд хамааруулах боломжгүй тул огнооны цагийн бүрэлдэхүүн хэсэггүйгээр цагийн бүсийг үнэн зөвөөр нөхөх боломжгүй бөгөөд тийм учир цагаар хэмжигдэх хугацааны шилжилтийг үндэслэлтэй тооцож чаддаггүй.

Цагийн бүстэй харьцахын тулд **lubridate**-д хэд хэдэн туслах функцууд байдаг бөгөөд эдгээрийг огнооны объектын цагийн бүсийг орон нутгийн цагийн бүсээс өөр цагийн бүс болгон өөрчлөхөд ашиглаж болно. Datetime объектод tz өгөгдлийн сангийн хүчинтэй цагийн бүсийг өгөх замаар цагийн бүсийг тохируулдаг. Эдгээрийн жагсаалтыг доорх линкээс олж болно - хэрэв таны ашиглаж байгаа байршил энэ жагсаалтад байхгүй бол цагийн бүсийн ойролцоох томоохон хотуудын цагийн бүсийг ашиглаж болно.

<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>

```{r}
# баганад одоогийн цагийг оноох
time_now <- Sys.time()
time_now

# with_tz()-г ашиглан цагийг ӨӨРЧЛӨХИЙН зэрэгцээ баганад шинэ цагийн бүс оноох
time_london_real <- with_tz(time_now, "Europe/London")

# force_tz()-г ашиглан цагийг хэвээр ХАДГАЛАХЫН зэрэгцээ баганад шинэ цагийн бүс оноох
time_london_local <- force_tz(time_now, "Europe/London")


# Энэ кодыг ажиллуулахад ашигласан компьютерийг Лондонгийн цагаар тохируулаагүй тохиолдолд цагийн зөрүү (компьютерийн цагийн бүсээс Лондон хүртэлх цагийн зөрүү) байх болно гэдгийг анхаарна уу.
time_london_real - time_london_local

```

Энэ нь хийсвэр мэт санагдаж болох бөгөөд хэрэв хэрэглэгч өөр цагийн бүстэй датан дээр ажиллахгүй тохиолдолд ихэвчлэн шаардлагагүй байдаг.

<!-- ======================================================= -->

## Хоцрох болон түрүүлэх тооцоолол

`lead()` болон `lag()` нь **dplyr** багцын функцууд бөгөөд ихэвчлэн тоон эсвэл огнооны векторын өмнөх (хоцорсон) эсвэл дараагийн (түрүүлсэн) утгуудыг олоход тусалдаг. Энэ нь цаг хугацааны нэгж хоорондын өөрчлөлт/ялгааг тооцоолоход хэрэг болно.

```{r, echo=F}
counts <- import(here("data", "example", "district_weekly_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm=T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"), fill = list(cases_wk = 0))
```

Та одоогийн болон өмнөх долоо хоногийн тохиолдлын зөрүүг тооцоолохыг хүсч байна гэж бодъё. Датаг доор үзүүлсэн шиг долоо хоног бүрийн тоогоор эхний байдлаар өгсөн байна.

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**`lag()` эсвэл `lead()`-ийг ашиглах үед датафрэймийн мөрүүдийн дараалал нь маш чухал юм! - Таны огноо/тоо өсөх эсвэл буурах дараалалтай эсэхийг анхаарч үзээрэй**

Эхлээд өмнөх (хоцорсон) долоо хоногийн утгыг агуулсан шинэ багана үүсгэ.

-   `n =` (сөрөг бус бүхэл тоо байх ёстой) аргумент ашиглан ухрах/урагшлах нэгжийн тоог тохируулна

-   Байхгүй мөрүүдэд (жишээ нь, хоцорсон утга байх боломжгүй эхний мөр) байршуулсан утгыг тодорхойлохын тулд `default =` аргументыг ашиглана уу. Анхдагч байдлаар энэ нь `NA` байна.

-   Хэрэв датаны мөрүүд таны лавлах баганаар эрэмбэлэгдээгүй бол `order_by = TRUE` аргументыг ашиглана.

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Дараа нь хоёр тохиолдлын баганын ялгаа болох шинэ багана үүсгэ:

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Та `lead()` болон `lag()`-ын талаар [эндээс](https://dplyr.tidyverse.org/reference/lead-lag.html) эсвэл консол дээрээ `?lag` гэж оруулснаар дэлгэрэнгүй уншиж болно.

<!-- ======================================================= -->

## Нэмэлт материалууд

lubridate багцын [tidyverse хуудас](https://lubridate.tidyverse.org/)

lubridate багцын RStudio [cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)

R for Data Science номын [огноо, цагийн тухай хэсэг](https://r4ds.had.co.nz/dates-and-times.html)

[Онлайн хичээл](https://www.statmethods.net/input/dates.html) [Огнооны форматууд](https://www.r-bloggers.com/2013/08/date-formats-in-r/)
