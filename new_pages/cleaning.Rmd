# Дата цэвэрлэгээ ба үндсэн функцууд

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Энэ бүлэгт датаг "цэвэрлэхэд" хэрэглэгддэг нийтлэг аргууд болон R-ын дата менежментийн үндсэн функцуудыг сурах болно.

Дата цэвэрлэгээ хийх алхам бүрийг "raw" (түүхий) дата (linelist) импортлохоос авахуулаад хийгдэх үйлдэл бүрийг нэг бүрчлэн тайлбарлах болно. R- дата цэвэрлэгээ "pipe" (хоолой) холбоосоор дамжин хийгддэг бөгөөд "pipe" `%>%` буюу холбогч оператор дамжуулах үйлдлийг гүйцэтгэдэг.

### Үндсэн функцууд {.unnumbered}

Энэхүү номонд [**tidyverse**](https://www.tidyverse.org/) -ын харъяа багцууд, тэдний функцуудыг голчлон тайлбарлна. Гол хэрэглэгдэх функцуудыг дор жагсаав.

**tidyverse** багцын нэг [**dplyr**](https://dplyr.tidyverse.org/) багцын дата засаж, янзалдаг "үйл үгэн" функцууд түлхүү орсон (**dplyr** багцын нэр "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)(хүснэгтийг%20засах)%22%20гэсэн%20утгатай) буюу "хүснэгт засагч" гэсэн утгатай).( **tidyverse** --ын бусад багцуудад **ggplot2**,**tidyr**,**stringr**,**tibble**,**purrr**,**magrittr**,**forcats** ордог).

+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| Function                                            | Utility                                                             | Package                       |
+=====================================================+=====================================================================+===============================+
| `%>%`                                               | "pipe" (хоолой) нь датаг нэг функцээс нөгөөд дамжуулна              |     | **magrittr**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `mutate()`                                          | Баганыг үүсгэж, хувиргаж, өөрчилдөг \| \*\*dp                       | lyr\*\*                       |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `select()`                                          | Баганыг үлдээж, арилгаж, шинээр нэр өгдөг                           | \| **dplyr**                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rename()`                                          | Баганыг шинээр нэрлэдэг                                             |       | **dplyr**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_names()`                                     | Баганын нэрсийг жигд болгодог \| \*\*janit                          | or\*\*                        |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | Баганадах дата төрлийг өөрчилнө. \| \| \*                           | \*base\*\* R                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `across()`                                          | Олон баганыг зэрэг хувиргана \| **dplyr**                           |                               |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| **tidyselect** functions                            | Баганыг сонгохдоо logic ашиглана \|                                 | \| **tidyselect**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `filter()`                                          | Тодорхой мөрүүдийг авч үлдэх                                        |          | **dplyr**          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `distinct()`                                        | Мөрүүдийг давхардалтыг арилгах                                      |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rowwise()`                                         | Мөр дагуу үйлдэл хийх \| \*\*dplyr                                  | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `add_row()`                                         | Мөрийг гараар нэмэх \| \|                                           | **tibble**                    |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `arrange()`                                         | Мөрийг эрэмбэлэх                                                    |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `recode()`                                          | Баганадах утгыг дахин өгөх \|                                       | **dplyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `case_when()`                                       | Баганад илүү нарийвчилсэн логик шалгуураар утга оруулна\| \*\*dplyr | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | Баганад утга өгөх тусгай функцууд                                   | **tidyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `age_categories()` and `cut()`                      | Тоон утгатай баганаас ангилал үүсгэ \| \* \| \*epikit               | **and** base\*\* R            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_variable_spelling()`                         | Датаны тайлбар толийг ашиглан баганын утгыг өөрчлөх, арилг          | ах \| **linelist**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `which()`                                           | Логик шалгуур ашиглах; Индексийг харуулах (return indices)          |                  | **base** R |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+

Эдгээр функцууд Stata болон SAS программ дээр хэрхэн бичигддэг талаар [Transition to R] -линкээс үзэж болно.

Датаг янзалж байхад R-ын **data.table** багцын операторууд болох `:=`,`[ ]` гарч ирж болно. **data.table** багцын хэрэглэгддэг синтакс, аргачлалыг [Data Table] хуудаст товч оруулсан.

### Нэр томьёо {.unnumbered}

Энэхүү номонд хувьсагч (variable) -ийг багана, ажиглалт (observations) -ийг мөр гэж нэрших болно. Тархвар судлалын ихэнх датаг гол бүрдүүлдэг зүйлс бол багана, мөр, доторх утга гэж ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) -д тайлбарласан байдаг.

*Variables* (Хувьсагч) нь ижил хэв шинжтэй утгуудыг агуулсан байдаг (насны бүлэг, өвчин эхэлсэн огноо, эмчилгээний үр дүн гэх мэт). *Observations* (Ажиглалт) гэж тухайн нэгжид хийгдсэн бүх хэмжилтүүдийг хэлнэ (хүн, газар, лабораторийн дээж материал). Эдгээр шинж талуудыг бодитоор, барьцтай илэрхийлэх нь бэрхшээлтэй.

"Tidy" (цэгцтэй) датанд багана болгон хувьсагч, мөр болгон ажиглалт, нэг нүд болгон нэг утгыг зааж байдаг. Цэгцтэй загварт хэлбэржээгүй дата зарим тохиолдол бий. Тухайлбал "wide"(өргөн) дата гэхэд хувьсагч нь хэд хэдэн баганад хуваагдан байрладаг. Үүний жишээг [Pivoting data]-т хэсэгт харуулсан. Ажиглалт ч гэсэн хэд хэдэн мөрөнд хуваагдан байрласан байх тохиолдол бий.

Энэ номонд бид датаг хэрхэн хувиргаж, янзлаж, менежмент хийд талаар харуулахыг илүү эрмэлзсэн. Тийм ч учраас хувьсагч, ажиглалт зэрэг хийсвэр ойлголт хэрэглэхийн оронд мөр, багана зэрэг бодитой бүтэц заасан нэршилийг хэрэглэхээр шийдсэн. Харин статистик дүн шинжилгээний талаар тайлбарласан хэсгүүдэд хувьсагч, ажиглалт гэсэн нэршил илүү хэрэглэгдсэн.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Цэвэрлэх холбоос

**Энэ хэсэгт дата цэвэрлэгээг үе шат тус бүрээр нь тайлбарласан. Цэвэрлэгээний явцыг "pipe" цэвэрлэх холбоост нэг бүрчлэн залгаж үзүүлсэн.**

Тархвар судлалд датаг янзлах, цэвэрлэх нь хоорондоо холбоотой дараалласан үйлдлүүдээс бүрддэг. R программ дээр цэвэрлэгээг хийхдээ мөн адил *датаг нэг цэвэрлэх шатнаас нөгөөд угсруулан үйлддэг.*

Ийм угсруулсан үйлдлүүдийг **dplyr** -ын "үйл үгт" функцуууд болон **magrittr**-ын pipe`%>%` холбогч оператор хамтран гүйцэтгэдэг. Цэвэрлэгээ түүхий датагаар ("linelist_raw.xlsx") эхлээд R -ын "цэвэрхэн" хүснэгт (`linelist`) болж гардаг. Үүнийг шууд ашиглаж, хадгалж, экспортлож болно.

Цэвэрлэгээ хийж байхад үйлдлийн дараалал чухал. Нийтлэг хийгддэг үйлдлийн дараалалд:

-   Датаг оруулж ирэх\
-   Баганын нэрсийг өөрчлөх, арилгах\
-   Давхардсан утгуудыг арилгах\
-   Багана нэмж, хувиргах (утгыг дахин кодлох, стандардчилах гэх мэт)\
-   Мөрүүдийг шүүж, хасаж, нэмэх

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багцуудыг ачааллах

Дараах кодыг уншуулж шаардлагатай багцуудыг ачааллана. Энэ номонд багцыг ачааллахад **pacman** -ны `p_load()`-ыг голчлон хэрэглэнэ. Учир нь энэ функц шаардлагатай багцыг автоматаар татаж авч, ачааллаад ажиллахад бэлэн болгодог. **base** R-ын багцыг `library()`-аар та өөрөө шууд (татаж авалгүйгээр ) ачааллаж бас болно. [R basics] хэсгээс энэ талаар нэмж үзнэ үү.

```{r, message = F}
pacman::p_load(
  rio,        # дата оруулах  
  here,       # файлын холбоотой замыг тогтоох 
  janitor,    # дата, хүснэгт цэвэрлэх
  lubridate,  # огноотой ажиллах
  epikit,     # age_categories() функц
  tidyverse   # дата менежмент ба график зураглал
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Датаг импортлох

### Импорт хийх {.unnumbered}

Түүхий дата агуулсан Excel файлыг **rio**-ын `import()` функцээр импортлоно. **rio** нь файлын олон янзын төрөлтэй ажиллаж чаддагаараа давуу (.xlsx, .csv, .tsv, .rds. гэх мэт). [Import and export] хэсгээс дэлгэрүүлж үзнэ үү.

Энэ бүлгийн дасгалыг хамт хийх бол датаг дараах линкээс татаж авна уу. <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>линк дээр дарж "түүхий" linelist -ыг татаж ав</a> ( .xlsx файл).

Хэмжээ том датасетийн хувьд импортлоход хугацаа их шаарддаг учраас импорт хийх коммандаа pipe залгааснаас салангид уншуулж, түүхий датагаа тусдаа файлаар хадгалах нь тохиромжтой. Ингэснээр мөн анхны болон цэвэрлэгдсэн дата хувилбаруудыг харьцуулахад хялбар болдог.

Дорх жишээнд бид Excel-ийн түүхий файлыг импортлоод `linelist_raw` гэсэн хүснэгт болгож хадгаллаа.Энэхүү файлыг та өөрийн ажлын хавтас эсвэл R төслийн үндсэн хавтастаа байрлуулна гэж тооцсон учир файлын замыг бичихэд дэд хавтсыг оруулсангүй.

```{r, echo=F, message=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# here()-ийг ашиглаж датаг ачааллана
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Үүссэн хүснэгтийн эхний 50 мөрийг дараахаас харж болно. Тэмдэглэл: **base** R"-ын `head(n)` функцээр эхний `n` мөрийг R console дээр шууд харж болдог.

```{r message=FALSE, echo=F}
# linelist датаг хүснэгт хэлбэрээр харуул
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Тоймлон үзэх {.unnumbered}

Дата хүснэгтийн талаарх ерөнхий тойм мэдээг авахдаа **skimr** -ын `skim()` функцыг хэрэглэж болно. ([Descriptive tables] хэсгээс нэмж харна уу). Баганууд numeric (тоон), character (үсгэн) зэргээр төрөл төрлөөрөө тоймлогддог. Тэмдэглэл: "POSIXct" гэдэг нь нэг төрлийн боловсруулагдаагүй огноо датаны төрөл ([Working with dates] хэсгээс харна уу).

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганын нэрс

Хүснэгт импортлоход хамгийн эхний, толгой мөрийг баганын *нэр* гэж R уншдаг. Синтакст мөн энэ нэр хэрэгдэгднэ.

SAS, STATA зэрэг бусад статистик программд баганын толгой дох товчилсон нэрнээс гадна *"labels" (дэлгэрэнгүй нэр)* гэж байдаг. R дээр багана тус бүрт label өгөх боломжтой ч өргөн хэрэглэдэггүй. График дээр баганын нэрийг хэвлэлд үзэмжтэй харагдахуйцаар болгоход график хэвлэх комманддаа дэлгэцийн тохируулгад нь зааж өгч болно (тэнхлэгийн (axis) нэрс, ялгах тэмдгийн (legends), нэрс, багана толгой гэх мэт. [scales section of the ggplot tips page](https://epirhandbook.com/ggplot-tips.html#ggplot_tips_scales) болон [Tables for presentation](https://epirhandbook.com/tables-for-presentation.html#tables-for-presentation) хуудсаас нэмж уншна уу). Баганад label өгөх талаар [here](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) болон [here](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) линкүүдээс үзэж болно.

Баганын нэрс R дээр байнга хэрэглэгдэх тул "цэвэр" синтакстай байх нь чухал. Дараах аргаар нэрлэвэл тохиромжтой:

-   Богино
-   Зай авахгүй, доогуур зураас \_ хэрэглэх
-   Өвөрмөц тэмдэглэгээ оруулахгүй (&, \#, \<, \>, ...)
-   Төстэй нэрлэх ( жишээ нь бүх огноотой баганыг **date\_**onset, **date\_**report, **date\_**death гэж нэрлэх)

**base** R --ын `names()` функцээр `linelist_raw`--дах баганын нэрсийг хэвлэж харахад:

-   Зарим нэрс зай авсан (жишээ нь `infection date`)\
-   Огноотой баганууд жигд бус нэрлэгдсэн (жишээ нь `date onset` багана `infection date` ээс өөр)\
-   .xlsx файл дээр нь сүүлийн хоёр баганын толгой нэгтгэгдсэн (merged) байсан нь харагдаж байна. Учир нь нэгтгэгдсэн баганын эхний баганын нэр R -т "merged_header" гэж импортлогдоод хоёр дах баганын нэр "...28" гэж импортлогдсон байна ( хоосон 28 -р багана байсан).

```{r}
names(linelist_raw)
```

[***ТЭМДЭГЛЭЛ:*** зай авсан баганы нэрийг хойшоо харсан дан хашилтад хийдэг. Жишээ нь: linelist\$`` ` '\x60infection date\x60'` ``. Ингэхдээ компьютерийн гаран дээрх хойшоо харсан дан хашилт (\`) бичгийн дан хашилтаас ( ' ) өөр гэдгйиг анхаарна уу.]{style="color: black;"}

### Автомат цэвэрлэгээ {.unnumbered}

**janitor** багцын `clean_names()` функц баганын нэрсийн өвөрмөц байдлыг алдуулалгүйгээр жигдрүүлдэг. Ингэхдээ:

-   Бүх баганыг зөвхөн доогуур зураас, тоо, үсгээс бүрдсэн нэртэй болгож хувиргана.\
-   Өргөгдсөн эгшгүүд ASCII хэлрүү галиглагдна (Герман хэлний ö --г "o"-руу, Испани хэлний "enye" -г "n" болгох гэх мэт)\
-   Үсгийн том жижгийг `case =` аргументэд зааж өгч болно ("snake" хэлбэр default сонголт, "sentence", "title", "small_camel" гэх мэт өөр сонголтууд буй)\
-   Нэр өөрчлөх, орлуулахдаа `replace =` аргументийг ашиглаж болно (ж: `replace = c(onset = "date_of_onset")`)\
-   Онлайн [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) --г эндээс харж болно

Цэвэрлэх процесс `clean_names()` -эд түүхий linelist --ийг оруулснаар эхэлнэ:

```{r clean_names}
# түүхий датагаа clean_names() –д холбоод, үр дүнг нь "linelist" -доноо
linelist <- linelist_raw %>% 
  janitor::clean_names()

# баганын шинэ нэрс
names(linelist)
```

[***ТЭМДЭГЛЭЛ:*** сүүлийн баганын нэр "...28" байснаа "x28" болж хувирсан".]{style="color: black;"}

### Баганын нэрийг гараар цэвэрлэх {.unnumbered}

Баганын нэрсийг дээрх байдлаар жигдрүүлсний дараа гараар цэвэрлэх хэрэг заавал гардаг. Дорх кодонд **dplyr** --ын `rename()` -ыг pipe холбоост залгаж зарим баганын нэрийг янзалсан. `rename()` функц `NEW = OLD`-- гэсэн дарааллаар аргументээ авдаг. Эхлээд шинэ, дараа нь хуучин нэрийг бичнэ.

Дараах цэвэрлэгээний процесст нэр өгөх комманд нэмэгдэж орсныг ажиглаарай. Уншихад амар болгож зарим газар зай авсан.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
    
```

Баганын нэрс өөрчлөгдсөн байна:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Баганын байрлалаар нь нэр өгөх {.unnumbered}

Баганыг нэрийг солихдоо нэрээр нь дуудахаас гадна байрлалыг нь дуудаж болдог. Жишээ нь:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()`болон `summarise()` ашиглан нэр өгөх {.unnumbered}

Нэр өгөхдөө **dplyr** -ын `select()`болон `summarise()` функцуудыг хавсран ашиглавал арай түргэн. `select()`--ээр ажиллах гэж буй багануудаа сонгож авахад хэрэглэдэг (дараагийн хэсгүүдэд дахин дурьдна).`summarise()`--ын талаар [Grouping data] болон [Descriptive tables] хэсгүүдэд тайлбарласан. Эдгээр функц мөн адил `new_name = old_name` гэсэн дарааллаар аргументээ авна. Жишээ:

```{r, eval=F}
linelist_raw %>% 
  select(# ШИНЭ нэр              # ХУУЧИН нэр
         date_infection       = `infection date`, # нэрийг солиод, ЗӨВХӨН тухайн багануудыг л авч үлднэ
         date_hospitalisation = `hosp date`)
```

### Бусад {.unnumbered}

#### Excel дээрх баганын нэр хоосон байх {.unnumbered}

R-т баганын нэргүй дата байх боломжгүй. Тухайлбал Excel --ийн хүснэгт хоосон толгойтой баганатай R --луу импортлогдвол баганын байрлалаас нь хамаарч R автоматаар "...1", "...2" гэх мэтээр нэр өгдөг (жишээ нь хүснэгтийн 4 дэх багана нэргүй хоосон орж ирсэн бол R тэр баганыг "...4" гэж нэрлэнэ).

Энэ автоматаар өгөгдсөн нэрсийг байрлалынх нь дугаараар (дээр дурьдсан жишээний дагуу), эсвэл оноосон нэрээр нь дуудаж гараар цэвэрлэх боломжтой (`linelist_raw$...1`.

#### Excel багана, нүднүүд нэтгэгдсэн (merged) байх {.unnumbered}

Заримдаа Excel --ийн файл ыг хүлээж аваад харахад хүснэгтийн нүднүүд нэтгэгдсэн (merged) байдаг. Нэгтгэгдсэн нүдтэй хүснэгт хүн уншихад амар боловч, "цэгцтэй дата/tidy data" хэлбэрт ороогүй учраас компьютерт сайн уншигддаггүй ([Transition to R] хэсэгт тайлбарласан). R --дээр нэгтгэгдсэн нүднүүд уншигдахгүй.

Дата оруулж буй хүмүүстээ **хүнд уншигддаг дата машинд уншигддаг дата хоёр өөр** гэдгийг сайн ойлгуулах хэрэгтэй. Цэгцтэй датаны [**tidy data**](https://r4ds.had.co.nz/tidy-data.html) зарчмыг ойлгуулахыг мөн эрмэлз. Болж өгвөл дата оруулах аргачлалд нь өөрчлөлт хийж аль болох цэгцэрсэн, ямар нэг нэгтгэсэн нүдгүй дата хүлээж авахаар зохицуулбал сайн.

-   Хувьсагч тус бүр баганатай байна.\
-   Ажиглалт тус бүр мөртэй байна\
-   Утга тус бүр өөрийн нүдэнд байна.

**rio-ын** `import()` -ээр дата импортлож байхад нэтгэгдсэн нүд датанд байх тохиолдолд тухайн нүд задарч, доторх утга эхний нүдэнд бичигдээд дараах нүднүүд нь хоосон орхигддог.

Нэтгэгдсэн нүдний асуудлыг **openxlsx** багцын `readWorkbook()`функцээр шийдвэрлэх боломжтой. Үүний `fillMergedCells =` аргументийг TRUE гэж тохируулбал нэтгэгдсэн нүднүүд задрахад доторх утга бүгдэд нь зэрэг хуваарилагдан ордог онцлогтой.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***АЮУЛТАЙ:*** `readWorkbook()` -өөр баганын нэрс нэгтгэгдсэн бол давхардсан нэртэй багануудтай болчихдог. Үүнийг гараар цэвэрлэх шаардлагатай. R давхардсан нэртэй ажиллахдаа муу! Давхар нэртэй багануудын нэрийг байршлаар нь дуудаж янзалж болно (баганын нэрийг гараар цэвэрлэх хэсэгт тайлбарласан)]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана сонгох болон эрэмбэлэх

**dplyr**-ын `select()` --д баганыг дуудаж оруулахдаа дэс дарааг нь зааж өгч болно.

[***БОЛГООМЖЛОЛ:*** `linelist`- датаг `select()` --ээр янзалсан байгааг жишээ болгож харуулсан боловч хадгалаагүй. Pipe холбоостоо `names()-ыг` залгаснаар баганы нэр хэрхэн өөрчлөгдсөнийг харж болно.]{style="color: orange;"}

Цэвэрлэх холбоосонд [linelist --ын БҮХ нэрс цэвэрлэгдсэн байх үеийг энд харуулав]{style="color: orange;"}:

```{r}
names(linelist)
```

### Баганыг үлдээх {.unnumbered}

**Зөвхөн үлдээх шаардлагатай багануудаа л сонго.**

Шаардлагатай багануудаа `select()`коммандад хашилтгүйгээр оруул. Таны оруулсан дарааллаар хүснэгтийн багана эрэмбэлэгднэ. Байхгүй баганыг `select()`--д бичвэл R алдаа заана. (алдаа заахгүйгээр үргэлжлүүлэх талаар `any_of()`--ын тайлбараас үзнэ үү).

```{r}
# linelist датаг select() коммандаар цэвэрлээд names() -ээр баганын нэрсийг хэвлэсэн
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # баганын нэрсийг хэвлэж харуулах
```

### "tidyselect" туслах функцууд {#clean_tidyselect .unnumbered}

Багана үлдээх, хасах, хувиргах үйлдэл хийхдээ туслах функц ашиглавал хялбар болдог. Эдгээр туслах функцууд **tidyverse**-ын харьяа **tidyselect** багцыннх ба **dplyr** -ын багана сонгох үйлдэлтэй хавсарч хийгддэг.

Жишээ нь `everything()` функцээр "бичигдсэнээс бусад баганыг" сонгодог бөгөөд ингэх нь баганын дарааллыг өөрчлөхөд их хэрэгтэй. Дараах код `date_onset` болон `date_hospitalisation` багануудыг хамгийн эхэнд (зүүн талд) авчраад, үлдсэн багануудыг ард нь хэвээр нь үлдээсэн. `everything()` комманд хоосон хаалттай байгааг анхаар:

```{r}
# date_onset болон date_hospitalisation -г хамгийн урд зөөж авчрах
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

**dplyr** багцын `select()`, `across()`, `summarise()` нартай хамтран хэрэглэддэг **tidyselect** -ын функцуудыг дор жагсаав :

-   `everything()` - бичсэнээс бусад бүх багануудыг сонгоно\

-   `last_col()` - сүүлийн багана\

-   `where()` - аливаа функцыг бүх баганад уншуулж үзээд, TRUE тохиодлуудыг сонгоно\

-   `contains()` - заасан үсэг, тэмдэгт (character) агуулсан баганыг сонгох

    -   жишээ: `select(contains("time"))`\

-   `starts_with()` - баганын нэрийн эхлэл хэсгийг тааруулж сонгох

    -   жишээ: `select(starts_with("date_"))`\

-   `ends_with()` - баганын нэрийн төгсгөл хэсгийг тааруулж сонгох

    -   жишээ: `select(ends_with("_post"))`\

-   `matches()` -заасан regular expression (regex) тэй таарсан баганыг сонгох

    -   жишээ: `select(matches("[pt]al"))`\

-   `num_range()` - x01, x02, x03 зэрэг тоо, дугаараар тааруулж сонгох\

-   `any_of()` - аль нэг багана байхгүй тохиолдолд алдаа заахгүйгээр үйлдлийг гүйцэтгэнэ.

    -   жишээ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Үүнээс гадна ердийн операторуудыг ашиглаж болно. Жишээ нь `c()`-аар хэд хэдэн баганыг жагсааж, `:` тэмдэгтээр дарааллаж байрласан багануудыг сонгож болно. `!` (эсрэг),`&` (БА), `|` (ЭСВЭЛ) зэрэг тэмдэгтүүдээр багана сонгохдоо туслуулж болно.

Баганыг логик шалгуураар сонгох бол `where()`-ийг хэрэглэ. Хэрэв `where()`-ийг функцын дотор бичихээр бол хаалтыг нь хоосон байлгаж болохгүй. Дорх жишээнд зөвхөн тоон утгатай баганууд сонгохыг харууллаа.

```{r}
# Тоон утгатай багануудыг сонгох
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Нэрэндээ зөвхөн заасан character -ыг агуулагсан багануудыг сонгох бол `contains()` -ыг хэрэглэ. Мөн`ends_with()` болон `starts_with()` strings -ын байрлалыг илүү тодорхой зааж өгч болно.

```{r}
# тодорхой үг, үсэг нэрэндээ агуулсан багануудыг сонгох
linelist %>% 
  select(contains("date")) %>% 
  names()
```

`matches()` функц `contains()` -тай төстэй үүрэгтэй боловч regular expression ашигладгаараа онцлог ([Characters and strings]) хэсгээс нэмж харна уу. Энэ функцыг хэрэглэхдээ олон strings -үүдээ (ЭСВЭЛ) хооронд нь босоо зураасаар тусгаарлаад хашилтанд хийнэ :

```{r}
# олон strings-ийг эрэг хайж, тааруулах
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***БОЛГООМЖИЛ:*** Датанд байхгүй баганын нэрийг эдгээр функцэд өгвөл код алдаа зааж үйлдэл тэр дороо зогсчихдог. Тиймээс заасан strings байхгүй байх магадлалтай тохиолдолд `any_of()` -ийг хэрэглэвэл тохиромжтой. Ялангуяа багана хасахад их хэрэг болдог.]{style="color: orange;"}

Дор жишээнд бичсэн багануудын нэг нь л датанд буй боловч дорх код алдаа заахгүйгүээр үргэлжилж, цэвэрлэх холбоосын йлдлүүд зогсолтгүйгээр гүйцэтгэлээ хийж байна.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Баганыг хасах {.unnumbered}

Хасах ("-") тэмдэг (ж:`select(-outcome)`) эсвэл баганын нэрс жагсаасан вектороор (дор жишээнд үзүүлсэн) **аль баганыг хасахаа зааж өг**. Бусад баганууд хэвээр үлдэх болно.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # date_onset багана, fever-ээс vomit хүртэлх багануудыг хасах
  names()
```

**base** R -ын синтакс `NULL`-ыг ашиглаж баганыг хасч бас болно. Жишээ нь:

```{r, eval=F}
linelist$date_onset <- NULL   # base R -ын синтаксаар date_onset баганыг хасах
```

### Дангаараа үйлдэх коммандууд {.unnumbered}

`select()` -ийг дангаар нь хэрэглэж болдог (pipe холбоостой залгаа биш). Энэ тохиолдолд эхний аргумент нь янзлах гэж буй хүснэгтийн нэр байна.

```{r}
#  id болон насыг харуулсан шинэ linelist үүсгэх
linelist_age <- select(linelist, case_id, contains("age"))

# үүсгэсэн linelist-ийн баганын нэрсийг харуул
names(linelist_age)
```

#### Pipe холбоосонд нэмж залгах {.unnumbered}

`linelist_raw`-хүснэгт дэх дараах баганууд бидэнд шаардлагагүй: `row_num`, `merged_header`, `x28`. Эдгээрийг хасахдаа `select()` коммандыг pipe холбоосонд залгаж хасдаг:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################

    # баганыг хас
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Давхардалтыг арилгах

Энэхүү номын [De-duplication] хэсгээс давхардалтыг арилгах нэмэлт аргатай танилцаж болно. Энэ хэсэгт бид зөвхөн мөрний энгийн давхардалтыг арилгахыг харуулна.

**dplyr** багц `distinct()` гэсэн функцтэй. Энэ функц датан дах бүх мөрний давхардалтыг шалгасны дараа датаг зөвхөн өвөрмөц мөртэй болгож хувиргадаг. Энэ үйлдлээр зөвхөн 100% адилхан мөрүүдийн давхардалт арилдаг.

Давхардсан мөрийг хайхдаа мөрүүдийг хэсэгчилэн шалгаж болно (default аар бүх мөрийг зэрэг шалгана). Хэдий хэмжээний мөрүүдэд хайгуул хийхээ өөрөө тохируулж болно (давхардалтыг арилгах хэсэгт мөн тайлбарласан). Энэ тохиолдолд зөвхөн тухайн хайлт хийсэн хэсэгт л өвөрмөц мөртэй болдог.

Жишээнд хоосон `distinct()` цэвэрлэх холбоосонд залгасан байна. Ингэснээр 100% ижилхэн мөрүүдийн давхардал датанаас цэвэрлэгдсэн гэсэн үг (бүх мөр зэрэг шалгагдсан).

Жишээнд `linelist` -ийн мөрний тоо `nrow(linelist)` -оор эхэлж байна.

```{r}
linelist <- linelist %>% 
  distinct()
```

Давхардалтыг арилгасны дараа үлдсэн мөрийн тоог `nrow(linelist)` -ээр уншуулж шалгана. Хэрэв мөрийн тоо багассан бол 100% ижил давхардсан мөрнүүд арилсан гэсэн үг.

Pipe холбоосондоо `distinct()` -ийг залгаж өгөв:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################
    
    # давхардлыг арилгах
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багана үүсгэх ба хувиргах

**Шинэ багана нэмэх эсвэл багана хувиргахдаа dplyr-ын `mutate()` функцыг ашиглахыг зөвлөж байна.**

Дараах жишээнд `mutate()`-аар хэрхэн шинэ багана нэмэхийг харуулав. Синтакс нь: `mutate(new_column_name = value or transformation)`

R-ын `mutate()` Stata-ын `generate`коммандтай төстэй боловч хуучин баганыг хувиргадаж болдгоороо онцлог.

### Шинэ багана {.unnumbered}

`mutate()` -ээр шинэ багана үүсгэх энгийн жишээг дор харуулав. Бүх мөрөндөө 10 гэсэн утгатай `new_col` хэмээх багана нэмж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Өөр баганын утгыг оролцуулан тооцоолол хийж бас болно. Дор жишээнд `ht_cm`, `wt_kg` гэсэн хуучин хоёр баганы утгыг оролцуулан тооцоолол хийж `bmi` (Биеийн Жингийн Индекс-БЖИ) -гэсэн шинэ багана үүсгэв (БЖИ = кг/жин\^2) .

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Олон багана зэрэг шинээр үүсгэх бол багана тус бүрийг таслалаар тусгаарлаж шинэ мөрөнд бичнэ. Үүнийг дор жишээгээр харуулав. Хуучин баганыг нэтгэхдээ **stringr** -ын `str_glue()`-эийг бас ашиглаж болдог. ([Characters and strings] -аас харж болно.

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # шинэ багана = хуучин баганыг хувилах
    new_var_static = 7,                   # шинэ багана = бүх утга ижилхэн
    new_var_static = new_var_static + 5,  # хуучин багана дээр шинэ багана үүсгэж болох ба ингэхдээ өөр баганын утгыг оролцуулан тооцоолол хийж болно. 
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") #  бусад баганын утгыг хооронд нь нийлүүлж (paste) шинэ баганаү үсгэж болно.
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # жишээ үзүүлэх зорилгоор зөвхөн шинэ багануудыг харуулсан
```

Үүссэн шинэ багануудыг шалга. Жишээ болгож шинээр үүссэн багана, эдгээрий үүсгэхэд оролцсон хуучин багануудыг дор хэвлэлээ :

```{r message=FALSE, echo=F}
# linelist датаг хүснэгтээр харуулав
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ЗӨВЛӨГӨӨ:*** `mutate()` -ын өөр нэгэн хувилбар нь `transmute()` юм. Энэ функц `mutate()` шиг шинэ багана нэмэхээс гадна функц дотор бичигдээгүй бүх баганыг хасдаг.]{style="color: darkgreen;"}

```{r, eval=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# дээр үүсгэсэн баганыг хасна
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Багана дах дата төрлийг хувиргах {.unnumbered}

Огноо, тоо, логик (TRUE/FALSE) утгатай баганын дата төрлийг зөв тодорхойлж оруулбал цаашид ажиллахад хялбар байдаг. Жишээ нь хашилттай "2" character гэж уншигддаг бол хашилтгүй 2 -ыг тоо гэж уншина!

Импорт хийж байхдаа баганын дата төрлийг тохируулж болдог ч олон үйлдэлтэй. [R Basics] хэсэгт обьектийн дата төрөл, үүнийг хэрхэн хувиргах талаар дэлгэрүүлж уншиж болно.

Дараах кодоор багануудын төрөл зөв танигдсан эсэхийг шалгана. Мөн `skim()` -ээр багана дах дата төрлийг харж болно.

Энд харуулснаар `age` баганын дата төрөл character байна. Энэ багананд математик тооцоолол хийхийн тулд дата төрөл нь тоо байх шаардлагатай!

```{r}
class(linelist$age)
```

`date_onset` баганын төрөл нь мөн character байна! Анализ хийхийн тулд эдгээр багана огноо гэж танигдсан байх шаардлагатай!

```{r}
class(linelist$date_onset)
```

Эдгээр тохиолдолд `mutate()`-аар баганыг дахин тодорхойлж зөв төрөлд нь хувиргаж болно. Ингэхэд багана дах утга өөрчлөгдөхгүй зөвхөн дата төрөл өөрчлөгддөг. Дорх жишээнд `age` баганын дата төрлийг тоо болгож хувиргаж байна:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Мөн `as.character()`, `as.logical()` функцуудыг дээрхийн адил хэрэглэж болно. Factor төрөлрүү хувиргахдаа **base** R -ын `factor()` эсвэл **forcats**-ын `as_factor()`-г хэрэглэдэг. Энэ талаар [Factors] хэсгээс нэмж уншна уу.

Огноог болгоомжтой хувиргах шаардлагатай. [Working with dates] хэсэгт хэд хэдэн аргуудыг дурьдсан. Түүхий дата дах огноонууд бүгд ижилхэн форматтай байвал цаашид Date төрөлд хувиргахад хялбар ( "MM/DD/YYYY", эсвэл "DD MM YYYY" гэх мэт). Огноог Date төрөлд хувиргасны дараа зөв хувирсан эсэхийг заавал шалгаж бай.

### Бүлэглэсэн дата {.unnumbered}

`mutate()` функц *бүлэглэгдсэн* датанд ( [Grouping data] хэсгийг хар) арай өөр байдлаар хэрэглэдэг. Ихэнх статистикийн `mean()`, `median()`, `max()` зэрэг тооцооллыг нийт датанд биш бүлэглэсэн хэсгүүдэд тооцоолдог.

```{r, eval=F}
# насыг бүх мөрний дунджаар хуваах
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# насыг эмнэлэгт хэвтсэн бүлгийн дунджаар хуваах
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Бүлэглэсэн хүснэгтэд `mutate ()` -г хэрхэн хэрэглэх талаар [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) хэсгээс нэмж уншна уу.

### Олон баганыг хувиргах {#clean_across .unnumbered}

Кодыг богино болгох үүднээс багануудыг зэрэг хувиргах шаардлага гардаг. Үүнийг **dplyr** -ын ( **tidyverse** багцуудын нэг) `across()`-оор хийж болно. **dplyr** -ын фүх функцийг `across()` -тай хавсарч хэрэглэх боломжтой ч `select()`, `mutate()`, `filter()`, `summarise()` зэрэгтэй илүү хамт хэрэглэдэг.[Descriptive tables] хэсгээс `summarise()` -тай хэрхэн хавсарч хэрэглэж болох талаар харна уу.

`across()`-ын`.cols =` аргументэд сонгосон багануудаа оруулаад, `.fns =` аргументэд гүйцэтгэх функцээ зааж өгнө. `.fns` -д заагдсан функц өөрийн аргументтэй бол таслал аваад `across()` хаалт дотроо нэмж оруулна.

#### `across()` багана сонгох {.unnumbered}

Хувиргах багануудаа `.cols =` -д зааж өг. Баганыг нэг бүрчлэн нэрлэж оруул. Эсвэл "tidyselect" -ын туслах функцээс ашиглаж болно. Сонгосон функцээ `.fns =`-д зааж өг. Оруулсан функц **хаалтгүйгээр** бичигдсэн байгааг дор жишээнээс харна уу.

`Дор жишээнд across()` дотор бичигдсэн багануудад `as.character()` хувиргалт зэрэг хийгдэж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Багана сонгох үйлдлийг "tidyselect" -ын туслах функцууд ашиглаж хялбарчилдаг. Энэ функцуудын талаар Багана сонгох болон эрэмбэлэх хэсэгт дэлгэрүүлж тайлбарласан. Эдгээр туслах функцэд : `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` `any_of()` орно.

Энд **бүх баганыг** хэрхэн зэрэг character төрөлд хувиргахыг харуулав:

```{r, eval=F}
#бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Дор зөвхөн нэрэндээ "date" гэсэн үг агуулсан багануудыг character -руу хувиргаж байна (таслал, хаалтны байрлалыг ажигла):

```{r, eval=F}
#"date" -гэсэн үг нэрэнд нь бичигдсэн бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Дор POSIXct хэлбэрт (цаг хугацааг харуулсан түүхий датаны хэлбэр) байсан багануудыг хэрхэн хувиргахыг харуулав. Ингэхдээ `is.POSIXct()` функцээр багануудыг шалгаад `TRUE` хариу өгсөн багана болгоныг `as.Date()`-руу хувиргаснаар зөв Date хэлбэрт оруулах болно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Дээр бичсэнээр `across()` доторх `where()` функцээр `is.POSIXct` функц үнэн (TRUE), худал (FALSE) эсэхийг шалгаж байна.\
-   Энэхүү `is.POSIXct()` нь **lubridate** багцын функц. Бусад төстэй "is"-ээр эхэлдэг функцууд `is.character()`, `is.numeric()`, `is.logical()` нар **base R** багцын функцууд.

#### `across()` функцууд {.unnumbered}

`?across()` коммандаар зааврыг гаргаж ирж танилцаж `across` -коммандад функц хэрхэн оруулах талаар дэлгэрэнгүйтэй танилцаж болно . Функц гэдэг ойлголтод хэд хэдэн тодорхойлолт байдаг ба таны зохиосон функц ч бас үүнд ордог.

-   Функцын нэрийг дангаар нь өгч болно (ж:`mean` эсвэл `as.character`)\

-   Функцыг **purrr**-багцын форматаар уншуулж (ж:`~ mean(.x, na.rm = TRUE)`) ( [this page][Iteration, loops, and lists]-ээс хар)\

-   Олон функцуудыг list -д жагсааж оруулж болно (ж: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Олон функц зэрэг оруулж буй үед , multiple transformed columns will be returned per input column, with unique names in the format `col_fn`. Шинээр үүсэх багануудын нэрийг **glue** -ын `.names =` аргументээр тохируулж болно ( [Characters and strings]-ээс нэмж хар) `{.col}` болон `{.fn}` are shorthand for the input column and function.

`across()`-ын талаарх нэмэлт онлайн эх сурвалжууд: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### `coalesce()` {.unnumbered}

Энэхүү **dplyr** багцын функц хамгийн эхний дутуу биш утгыг байрлал бүрт олж тогтоодог. Ингэснээр хамгийн эхний боломжит дутуу биш утгыг дутуу утгатай газар таны заавраар "нөхдөг".

Үүнийг дараах байдлаар тайлбарлая: Таньд хоёр вектор дата байна гэж бодъё. Нэг нь өвчтөний оношлогдсон тосгонууд, нөгөө нь өвчтөний амьдардаг хотууд. Үүний эхний дутуу биш утгыг coalesce-г ашиглаж индекс бүрт олж болно:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # хэвлэ
```

Хүснэгтэд мөн адил хэрэглэгднэ: таны заасан багана дах эхний дутуу биш утгыг мөрийн дагуу өөр баганад оноож өгнө (таны заасан дарааллын дагуу ).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Энэ жишээнд "мөр - дагуух" гүйцэтгэлийг харуулав. Энэ үйлдлийг хэрхэн хийх талаар Мөр-дагуу тооцоолол хэсгээс харна уу.

### Cumulative математик {.unnumbered}

Мөрний утгыг өмнөх мөрний утгатай нэгтгэж sum/mean/min/max зэрэг функцуудээр бодолт хийж үр дүнг cumulative байдлаар харуулах бол дараах функцыг хэрэглэнэ:

`cumsum()` -аар cumulative нийлбэрийг олно:

```{r}
sum(c(2,4,15,10))     # нийлбэр нэг утга бодогдно
cumsum(c(2,4,15,10))  # энэхүү векторын утга тус бүрт cumulative нийлбэр бодогдно
```

Хүснэгтийн хувьд мөн адилхан. Дэгдэлтийн үеийн тохиолдлын сumulative нийлбэрийг дараах кодоор бодно.

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # linelist-ээс эхэл
  count(date_onset) %>%                 # Огноог тоолох ('n')   
  mutate(cumulative_cases = cumsum(n))  # Мөр бүрт cumulative нийлбэртэй шинэ багана үүсгэ
```

Дээрх коммандаар хийсэн хүснэгтийн эхний 10 мөрийг харах:

```{r}
head(cumulative_case_counts, 10)
```

Cumulative тохиолдлын тоогоор график хийх тухай [Epidemic curves] хэсгээс уншина уу.

Мөн дараах функцуудын талаар харна уу:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### **base** R -г ашиглах {.unnumbered}

**base** R-аар шинэ багана үүсгэх (эсвэл хуучин баганыг өөрчлөх) бол хүснэгтийн нэрийн ард `$` тэмдэгт тавьж *шинэ* үүсгэх (эсвэл өөрчлөх) баганын нэрийг шууд ардаас нь залгаж бичдэг. Шинэ баганад утга оруулахдаа оноох оператор `<-` ашиглана. **base** R -т хүснэгтийн нэрийг баганын нэрний өмнө бичдэг болохыг анхаарна уу (ж: `dataframe$column`). Дараах жишээнд `bmi` баганыг **base** R ашиглаж үүсгэж буйг харуулав:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Pipe холбоосонд залгах {.unnumbered}

**Дараах кодны төгсгөлд шинэ мөр үүсгэх болон зарим багануудын төрөл хувиргах үйлдлүүдийг pipe холбоосонд залгаж үзүүлэв.**

```{r }
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    ###################################################
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Утга өөрчлөх

Дараах тохиолдлуудад датаны утгыг өөрчлөх шаардлага гардаг:

-   аливаа нэг утгыг янзлах (ж: аль нэг огнооны жил буруу эсвэл буруу форматтай орсон байх)
-   янз бүрээр галиглагдаж бичигдсэн утгуудыг жигд болгох
-   categorical утгатай шинэ багана үүсгэх
-   numerical утгыг бүлэглэж шинэ багана нэмэх (ж: насны бүлэглэл)

### Өвөрмөц утгууд {.unnumbered}

Утгыг гараар өөрчлөхийн тулд `mutate()` дотор `recode()` -ыг оруулдаг.

Жишээ нь буруу бичигдсэн огноо өөрчлөхдөө (ж: "2014-14-15") шууд эх дата дээрээ (боловсруулалт хийхийн өмнө) гараар янзалж болно. Эсвэл `mutate()`, `recode()`-функцуудыг pipe холбоост залгаж огноог өөрчилж болно. Сүүлийн аргыг хэрэглэх нь бусдад нээлттэй (transparent), дахин боловсруулалт хийх боломж олгодгоороо ач холбогдолтой.

```{r, eval=F}
# алдаатай утгыг засах                   # хуучин утга  # шинэ утга
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Дээр бичигдсэн `mutate()` үйлдлийг дараах байдлаар уншина: "`date_onset` баганыг шинэчлэгдсэн `date_onset` тай тэнцүүлж бичих ба ингэснээр ХУУЧИН УТГА нь ШИНЭ УТГА-аар солигдно". `recode()` функцын энэ дараалал (ХУУЧИН = ШИНЭ) R -ын ихэнх функцэд эсрэгээрээ байдаг (шинэ = хуучин). R хөгжлийн нийгэмлэг үүнийг сайжруулахаар ажиллаж байна.

**Нэг баганад олон утгыг зэрэг өөрчлөх жишээг дор харуулав.**

`linelist` -ын "hospital" баганыг цэвэрлэх шаардлагатай боллоо. Учир нь хэд хэдэн газар алдаатай бичигдэж, дутуу утгууд болж уншигдсан байна.

```{r}
table(linelist$hospital, useNA = "always")  # бүх өвөрмөц утгыг (дутуу утгатайгаар) хэвлэ  
```

Энэ жишээнд "hospital" багана хэвээр боловч `recode()` комманд ашиглаж зарим утгад өөрчлөлт оруулж байна. Тус бүр ардаа таслалтай байгааг анхаар!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # лавлагаа: ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Одоо `hospital` баганын галиглал хэрхэн засагдсаныг харья:

```{r}
table(linelist$hospital, useNA = "always")
```

[***ЗӨВЛӨГӨӨ:*** тэнцүүгийн тэмдгийн ард, урд авах зайн урт чухал биш. Бичсэн кодоо уншихад хялбар байлгах үүднээс = тэмдгийг мөр болгонд тэгшхэн тааруулж бичсэн. Мөн хүмүүст ойлгомжтой болгохын тулд "хэш" (\#) тэмдэгтээр аль нь хуучин, шинэ утгаболохыг зааж өгсөн.]{style="color: darkgreen;"}

[***ЗӨВЛӨГӨӨ:*** заримдаа *хоосон* утга датанд орж ирсэн байдаг ( R-ын дутуу утга (`NA)` болж танигдааuшй). Хоосон утгыг тодорхойлохдоо дундаа зайгүй давхар хашилтан бичдэг ("").]{style="color: darkgreen;"}

### Логик үйлдлүүд {.unnumbered}

Энэ хэсэгт логик болон нөхцөл (conditions) ашиглаж баганын утгыг хэрхэн өөрчилдгийг харуулав:

-   `replace()`, `ifelse()`, `if_else()` функцыг энгийн логик үйлдэлд хэрэглэнэ.
-   `case_when()` функцыг нарийн логик үйлдэлд хэрэглэнэ.

### Энгийн логик үйлдэл {.unnumbered}

#### `replace()` {.unnumbered}

Энгийн логик шалгуурыг үүгэхдээ `mutate()` дотор **base** R-ын `replace()` функцыг оруулаад үүн дотор шаардлагатай логик нөхцөлөө оруулж өгнө. Синтаксын ерөнхий формат:

`mutate(col_to_change = replace(col_to_change, мөрний шалгуур үзүүлэлт, шинэ утга))`.

Мөн датан дах **аль нэг утгыг өвөрмөц дугаараар нь дуудаж өөрчлөх** үйлдэлд `replace()` -ийг их хэрэглэдэг. Дорх кодоор `case_id` баганад 2195 гэсэн утга байвал үүнтэй харалдаа орших мөрний gender баганын утгыг "Female" болгож өөрчлөх комманд өгсөн.

```{r, eval=F}
# Жишээ: заасан ганц ажиглалтыг "Female" болгож өөрчлөх
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

**base** R -т дээрхитэй ижил үйлдлийг индекслэх тэмдэг буюу дөрвөлжин хаалт `[ ]` гүйцэтгэдэг (дор жишээнд харуулав). Дор кодыг дараах байдлаар уншина: "`linelist` хүснэгтийн `gender` баганыг (`case_id` баганадаа '2195' гэсэн утгатай тохиолдолд) 'Female' болго ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` болон `if_else()` {.unnumbered}

Энгийн логик үйлдэл хийдэг `ifelse()`, `if_else()` хэмээх функцууд байдаг ч оронд нь `case_when()` функцыг хэрэглэвэл илүү ойлгомжтой (дэлгэрэнгүйг доор бичсэн). Эдгээр "if else" коммандууд нь `if` болон `else` программчлалын хялбаршуулсан хэлбэр. Синтаксын ерөнхий формат:\
`ifelse(нөхцөл, хэрэв нөхцөл TRUE бол дуудах утга, нөхцөл FALSE бол дуудах утга)`

Дор `source_known` баганыг тодорхойлсон байна. Энэхүү кодоор `source` баганын мөр бүрт үзлэг хийж дутуу утга *байхгүй* бол харалдаа мөрний `source_known` баганын утгыг "known" болгоод, харин `source` мөрөнд дутуу утга *байвал* харалдаа мөрний `source_known` баганын утгыг "unknown" болгох болно.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

**dplyr** багцын `if_else()` -ээр огноо их янзалдаг. Үүнийг хэрэглэж байхад FALSE нөхцөлд таарсан утгыг `NA` гэлгүй `NA_real_` гэж оруулдаг. Учир нь `TRUE` огноо бол `FALSE` бас огноо байх болно.

```{r, eval=F}
# Нас баралтын огноотой багана үүсгэ. Өвчтөн нас бараагүй бол `NA`-аар бич.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**Олон зэрэг ifelse -ийг бичихэээс зайлсхий. Оронд нь `case_when()` -ийг хэрэглэ!** Ингэснээр хялбар уншигдаж, алдаа бага гаргадаг.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Outside of the context of a data frame, if you want to have an object used in your code switch its value, consider using [`switch()`](https://rdrr.io/r/base/switch.html) from **base** R {style="color: red;"}

### Комплекс логик үйлдлүүд {#clean_case_when .unnumbered}

Бүлэг үүсгэсэн утгуудад өөрчлөлт оруулах эсвэл комплекс логик үйлдэл хийх бол **dplyr** -ын `case_when()` -ийг хэрэглэвал оновчтой. Энэхүү функц хүснэгтийн мөр болгоныг шалгаад, шалгуурт нийцсэн утгыг заасны дагуу өөрчилдөг.

`case_when()` комманд нь Баруун-Тал/Right-Hand Side (RHS) болон Зүүн-Тал/Left-Hand Side (LHS) -ын зарчмаар бичигдэж "тилда" `~` тэмдэгээр хуваагддаг. Логик шалгуур нь зүүн талдаа, харин нийцүүлэх утга нь баруун талдаа бичигдэж, тус бүр таслалаар зааглагдна.

Энэ жишээнд `age` болон `age_unit` баганыг ашиглаж `age_years` баганыг үүсгэсэн:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # хэрэв age жилээр бичигдсэн бол
            age_unit == "months" ~ age/12,    # хэрэв age сараар бичигдсэн бол
            is.na(age_unit)      ~ age,       # хэрэв age_unit-д дутуу утга байвал (age жилээр)
            TRUE                 ~ NA_real_)) # бусад бүх тохиолдолд дутуу утгаар оруул
```

As each row in the data is evaluated, the criteria are applied/evaluated in the order the `case_when()` statements are written - from top-to-bottom. If the top criteria evaluates to `TRUE` for a given row, the RHS value is assigned, and the remaining criteria are not even tested for that row. Thus, it is best to write the most specific criteria first, and the most general last.

Along those lines, in your final statement, place `TRUE` on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like "check me!" or missing.

[***DANGER:*** **Vvalues on the right-side must all be the same class** - either numeric, character, date, logical, etc. To assign missing (`NA`), you may need to use special variations of `NA` such as `NA_character_`, `NA_real_` (for numeric or POSIX), and `as.Date(NA)`. Read more in [Working with dates].]{style="color: red;"}

### Дутуу утга {.unnumbered}

Дата цэвэрлэгээний үед дутуу утгыг янзалдаг функцуудыг энд тайлбарлав.

Дутуу утгыг олж, янзлах талаар [Missing data] хэсгээс нэмж үзэж болно. Тухайлбал логик шалгуураар дутуу утгыг олдог функцыг `is.na()` гэдэг.

**`replace_na()`**

`NA` дутуу утгыг өөрөөр тэмдэглэсэн дутуу утгаар (жишээ нь "Missing") солихдоо **dplyr** -ын `replace_na()` функцыг `mutate()` дотор оруулж бичнэ. `recode` функцын адил баганын нэрийг `replace_na()` -ын дотор оруулж бичихийг анхаар.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

Энэ **forcats** багцын функц. **forcats** багц factor төрлийн датаг янзалхад зориулагдсан. Factor утга нь *дараалалтай* ( жишээ нь `c("First", "Second", "Third")` ) утга болон аливаа шатлал заагдсэн ( жишээ нь: эмнэлэгүүд) утгын R хэлэнд хөрвүүлсэн хэлбэр. [Factors] хэсгээс нэмж харна уу.

Factor датаны `NA` -г "Missing" болгож өөрчлөхөөр `replace_na()` комманд өгвөл `invalid factor level, NA generated` гэсэн алдаа гарч ирдэг. You have tried to add "Missing" as a value, when it was not defined as a possible level of the factor, and it was rejected.

Ийм тохиолдолд **forcats** багцад байдаг `fct_explicit_na()` функцыг ашиглах нь тохиромжтой ба энэ функц баганыг factor болгож, `NA` -г character "(Missing)" хэлбэрт хувиргадаг.

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Өөр нэгэн хувилбар бол `fct_expand()` функцээр factor -ын шатлалыг нэмж оруулсны дараа дутуу утгаруу өөрчлөх юм.

**`na_if()`**

*Тодорхой нэг утгыг* `NA`- болгохын тулд **dplyr**'s-ын `na_if()` -г хэрэглэдэг. Доорх комманд нь `replace_na()-`ын эсрэг үйлдэл хийгднэ. Дараах жишээнд `hospital` багана дах "Missing" утга болгон `NA` болж хувирсан байна.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Тэмдэглэл `na_if()` **-г логик шалгуурт хэрэглэх боломжгүй** (жишээ нь "бүх утга \> 99"). Оронд нь `replace()` эсвэл `case_when()` -ыг хэрэглэ:

```{r, eval=F}
# 40 -өөс дээш градусыг NA  болго
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# 1 Jan 2000 -аас өмнөх огноог дутуу утга болго
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Цэвэрлэгээний толь бичиг {.unnumbered}

**linelist** болон түүний `clean_variable_spelling()` функцээр цэвэрэлэгээний тольтой (cleaning dictionary) хүснэгтийг янзалдаг. **linelist** багцыг R Epidemics Consortium [RECON](https://github.com/reconhub/linelist) боловсруулж гаргасан.

1)  Цэвэрлэгээний толийг дараах гурван баганатайгаар байгуул:

    -   алдаатай утгуудыг заасан багана\
    -   зөв утгуудыг заасан багана\
    -   өөрчлөлт оруулах баганууд (жишээ нь ".global" гэвэл бүх баганыг өөрчлөх)

Тэмдэглэл: аль нэг баганад зориулсан өвөрмөц өөрчлөлтийг .global өөрчлөлт давамгайлж гүйцэтгэгддэг.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Цэвэрлэгээний толь бичсэн хүснэгтээ R луу импортло. Энэ жишээг [Download handbook and data] хуудсанд заасны дагуу татаж авч болно.

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Түүхий linelist -ийг `clean_variable_spelling()` функцэд оруулаад `wordlists =` аргументэд цэвэрлэгээний тольтой хүснэгтээ зааж өгнө. Энэ хүснэгтийн өөрчлөх гэж буй баганын нэрстэй баганыг `spelling_vars =` аргументэд зааж өгнө ( default)-аар гуравдах багана) . Хэрэв factor болон character бүх баганыг хамруулья гэвэл `spelling_vars =` аргументийг `NULL` гэж заана. Энэ функц удаан уншигдаж болохыг анхаар.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # өөрчлөх баганын нэрстэй багана. default-аар гуравдах багана
  )
```

Одоо (баруун тийш нь гүйлгээд) датанд хэрхэн өөрчлөлт орсныг харж болно. Энд `gender` багана жижгээс том үсэгрүү, шинж тэмдэг агуулсан бүх багана yes/no -өөс 1/0 болж хувирсан байна.

```{r message=FALSE, echo=F}
#  linelist -ийг хүснэгтээр харуул
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Цэвэрлэгээний тольтой хүснэгтийн баганын нэрс таны одоо бичиж буй коммандны скрипттэй яг таарч байх шаардлагатайг анхаарна уу. Энэ талаар [online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) -ээс харна уу.

#### Цэвэрлэх pipe холбоосонд залгах {.unnumbered}

**Доорхи pipe холбоосонд багана нэмэх, баганын хувиргах үйлдлүүд залгагдсан.**

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ###################################################

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Тоог ангилах {#num_cats}

Энэ хэсэгт numeric баганаас хэрхэн categorical (ангилсан) утгатай багана үүсгэх талаар үзнэ. Тоон (numeric) ангилалын жишээнд насны ангилал, шинжилгээний үзүүлэлтийн ангилал зэрэг орно. Гол хэрэглэгдэх функцууд:

-   **epikit** багцын `age_categories()`\
-   **base R -ын** `cut()`\
-   `case_when()`\
-   `quantile()`, `ntile()`зэрэг кванталууд

### Тархалтыг шалгах  {.unnumbered}

Жишээнд `age_years` баганыг ашиглаж `age_cat` баганыг үүсгэх болно.

```{r}
# linelist -хүснэгт дэх нас заасан баганын дата төрлийг тогтоох
class(linelist$age_years)
```

Эхлээд датаны тархалтын дүрсийг шалгаж хуваах цэгүүдээ (cut-points) тогтооно. [ggplot basics] хэсгээс дэлгэрүүлж харна уу.

```{r, out.height='50%'}
# тархалтын дүрсийг шалга
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***АНХААРУУЛГА*** Заримдаа тоон хувьсагч нар "character" хэлбэрээр импортлогдох тохиолдол байдаг. Энэ нь тухайн хувьсагчын аль нэг утганд тоон биш тэмдэгт агуулагдсан байснаас болдог. Жишээ нь нас заасан баганад "2 сар" (2 months) гэж бичигдэх, бутархай тоонд цэг биш таслал тавигдах тохиолдлууд байдаг ("4,5" -аар дөрөв аравны тав гэсэн санаа илэрхийлсэн байх).]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

Тоон баганын утгад ангилалал үүсгэх бол **epikit** багцын `age_categories()` -ыг хэрэглэвэл хялбар (тэмдэглэл: энэхүү функцыг тоон биш хувьсагчид хэрэглэж бас болдог ). Ингэснээр үүссэн багана нь автоматаар эрэмбэлэгдсэн (ordered) factor болдог ач холбогдолтой.

Шаардлагатай оролтууд:

-   Тоон вектор (багана)\
-   `breakers =` аргумент - шинэ үүсэх ангиллын хуваагдах цэгүүдийг заасан тоон векторуудыг оруулна.

Эхлээд энгийн жишээ авч үзье:

```{r}
# Энгийн жишээ
################
pacman::p_load(epikit)                    # багцыг ачаалла

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # багана үүсгэ
      age_years,                            # шинэ багана үүсгэхэд ашиглах numeric багана
      breakers = c(0, 5, 10, 15, 20,        # хуваагдах цэгүүд
                   30, 40, 50, 60, 70)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

The break values you specify are by default the lower bounds - that is, they are included in the "higher" group / the groups are "open" on the lower/left side. As shown below, you can add 1 to each break value to achieve groups that are open at the top/right.

```{r}
# дээд хязгаарыг ижилхэн ангилалд оруулж байна
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Ангиллын нэрсийг `separator =` аргументээр тохируулж болно. Default тэмдэг нь "-".

Тоон утгын дээд хязгаарыг хэрхэхийг `ceiling =`аргументээр тохируулна. Дээд хязгаар тогтоох бол `ceiling = TRUE`гэж өгнө. Ингэснээр хамгийн дээд тогтоосон тоогоор ангилал дуусч "XX+" гэсэн ангилал үүсэхгүй. Энэхүү зааж өгсөн дээд хязгаараас их (эсвэл `upper =` -т зааж өгсөн) ямар ч тоо `NA` ангилалд орно. Доор жишээнд `ceiling = TRUE` гэж өгсөн тул XX+ ангилал үүсэхгүй, 70 -аас дээш (зааж өгсөн хамгийн дээд хязгаар) тоо `NA` болж хувирсан.

```{r}
# ceiling аргументийг TRUE дээр тохируулсан
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 бол дээд хязгаар ба үүнээс дээш тоо NA болно

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

Мөн `breakers =` аргументийн оронд та өөрөө `lower =`, `upper =`, `by =` гэсэн аргументуудэд хуваах цэгүүдтэы тоон дарааллыг оруулж өгч болно:

-   `lower =` таны зааж өгсөн хамгийн бага тоо - default нь 0\
-   `upper =` таны зааж өгсөн хамгийн их тоо\
-   `by =` ангилал хоорондын интервал

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# хүснэгтийг харуул
table(linelist$age_cat, useNA = "always")
```

энэ функцын Help хуудаснаас нэмэлт мэдээллийг үзэж болно (R console-д `?age_categories` гэсэн коммандаар гаргана).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()` бол **base** R -д багтдаг `age_categories()` -тай адил үйлдэлтэй функц. Гэвч `age_categories()` дээр ажиллахад илүү хялбар. `age_categories()` -аас гол ялгаатай шинжүүд:

-   Өөр багц суулгаж/уншуулах шаардлагагүй.\
-   Ангилал баруун/зүүн талруугаа нээлттэй/хаалттай эсэхийг зааж өгч болно.\
-   Ангиллын нэрсийг та өөрөө оруулж өгнө.\
-   Хамгийн бага ангилалдаа 0-г оруулах бол өөрөө зааж өгөх шаардлагатай.

`cut()` дотор эхлээд ангилах гэж буй numeric баганаа (`age_years`) оруулаад, хуваах цэгүүдээ `breaks=`аргументэд тоон вектор хэлбэрээр `c()` -д оруулна. `cut()` -аар үүсгэгдсэн багана эрэмбэлэгдсэн factor төрөл болдог.

Default-аар баруун/дээд тал "нээлттэй" (зүүн/доод тал нь "хаалттай" ) байдаг. Энэ нь `age_categories()` функцэд эсрэгээрээ хийгддэг. Default тэмдэглэгээ нь "(A, B]" бөгөөд энэ нь A ороогүй B орсон гэсэн утгатай. **Үүний эсрэг хийх бол `right = TRUE` гэж зааж өгнө.**

Үүнээс болоод хамгийн бага тоотой ангилалд default -аар "0" ордоггүй ба "0" утга `NA` болж хувирдаг. Гэтэл зарим тохиолдолд тухайлбал нярай хүүхдүүдийн нас 0 гэж кодлогддог зэргийг анхаарч байх шаардлагатай. Үүнийг өөрчлөхийн тулд `include.lowest = TRUE` гэсэн аргументийг нэмснээр "0" утга хамгийн бага тоотой ангилалд багтдаг. Автоматаар үүссэн ангиллын нэр хамгийн бага ангилалд "[A],B]" болдог. Note that if you include the `include.lowest = TRUE` argument **and** `right = TRUE`, the extreme inclusion will now apply to the *highest* break point value and category, not the lowest.

Үүсгэсэн ангилалд нэр өгөхдөө `labels =` аргументэд оруулна. Гараар бичигдэх тул алдаа гаргахаас сэргийлээрэй! Cross-tabulation (солбисон хүснэгт) ашиглаж алдаагаа шалгаарай

`cut()` ашиглаж `age_years` баганаас `age_cat` гэсэн шинэ багана үүсгэх жишээг дор харуулав:

```{r}
# Тоон age хувьсагчийг хувааж, ангилагдсан багана үүсгэ
# Ангиллын доод хязгаар нь битүү харин дээд хязгаар нь нээллттэй байна.
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # 0 -г доод ангиолд багтаа
      ))

# ангилал тус бүр дэх ажиглалтын тоог жагсааж хар
table(linelist$age_cat, useNA = "always")
```

**Хийсэн ажлаа шалга!!!** Насны тоон үзүүлэлтүүд зөв ангилалдаа орсон эсэхийг тоон болон ангилагдсан багануудыг солбиж харуулсан хүснэгтээр шалга. Ялангуяа захын утгуудыг шалгаарай (жишээ нь 15- ын тоо 10-15, 16-20 гэсэн ангилалуудын ойролцоо байгаа эсэх).

```{r}
# Тоон болон ангилагдсан баганыг солбиж харуулсан хүснэгт
table("Numeric Values" = linelist$age_years,   # ойлгомжтой болгох үүднээс багануудад нэр өгсөн
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # NA утгуудыг шалгахаа бүү мартаарай
```

**`NA` утгуудад дахин нэр өгөх**

`NA` -утгуудыг "Missing" гэсэн нэртэй ангилалд оруулж болно. Шинээр үүсэх багана factor учир (хязгаарлагдмал утгууд) шууд `replace_na()` аар хувиргалт хийх боломжгүй. [Factors] хэсэгт тайлбарсанчлан **forcats** багцын `fct_explicit_na()` функцыг хэрэглээрэй.

```{r}
linelist <- linelist %>% 
  
  # cut() -аар age_cat-ыг үүсгэнэ. Factor төрлийн багана үүснэ.     
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # Дутуу утгыг тодорхой болго
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # нэрийг өөрөө өгч болно
  )    

# ангилал тус бүр дэх ажиглалтын тоог харуулсан хүснэгт
table(linelist$age_cat, useNA = "always")
```

**Хуваах, нэрлэх үйлдлийг хялбарчлах**

Аливаа векторыг түргэн хугацаанд хувааж, нэр өгөх жишээг дор харуулав. [R basics] хэсгийн `seq()`, `rep()` -ийн тайлбараас нэмж үзэж болно.

```{r, eval=F}
#  0 -ээс 90 хүртэлх тоог 5 аар хуваасан цэгүүд үүсгэ. 
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Дээрх үүссэн ангиллуудад нэр өг (cut() default тохируулгатай)
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# ажиглалтын тоо хоёр векторт адилхан байна
length(age_seq) == length(age_labels)
```

`?cut` коммандыг R console -д өгч `cut()` функцын Help хуудаснаас нэмж тодруулж болно.

### Квантил хуваагдлууд {.unnumbered}

In common understanding, "quantiles" or "percentiles" typically refer to a value below which a proportion of values fall. Жишээ нь, `linelist` -ийн нас заасан баганын 95 дах персентил гэдэг нь нас заасан бүх утгын 95% нь орж буй утгуудыг хэлнэ.

Ердийн хэллэгт "квантил", "децил" гэдэг нь аливаа датаг 4 эсвэл 10 тэнцүү хуваахыг хэлдэг (хуваасан тооноос нэг илүү ангилал үүсэхийг анхаараарай).

Квантилаар хуваахдаа **base** R-ын **stats** багц дах `quantile()` функцыг ашигладаг. Та тоон вектор болон 0-оос 1 хүртэлх магадлал оноогдсон векторыг (ж: нэг баганадах тоо) оруулж өгнө. Эдгээр нь тоон векторууд юм. Энэ функцын статистикийн аргачлалын талаар `?quantile`комманд өгч уншна уу.

-   хэрэв таны оруулсан тоон вектор дутуу утгатай бол `na.rm = TRUE` гэж тохируулах хэрэгтэй.\
-   `names = FALSE` гэж тохируулснаар нэрлэгдээгүй тоон векторыг гаргаж ирнэ.

```{r}
quantile(linelist$age_years,               # ажиллах гэж буй тоон вектороо зааж өгнө
  probs = c(0, .25, .50, .75, .90, .95),   # персентилээ зааж өгнө
  na.rm = TRUE)                            # дутуу утгыг үл тоох 
```

`quantile()` -аар бодогдсон хуваагдах цэгүүдээ `age_categories()`, `cut()` функцын оролтод оруулж болно. Дор жишээнд `age_years` багана дах утгыг `quantiles()` -д өгч хуваагдах цэгүүдийг бодож гарган `cut()` коммандад өгснөөр `deciles` баганыг үүсгэж буй жишээг харуулав. Гарсан үр дүнгийн хувийг **janitor** багцын `tabyl()` функцийг ашиглаж харуулав ( [Descriptive tables] хуудсаас харна уу). Ангилалууд яг тэнцүү 10% -аар хуваагдаагүйг ажиглаарай.

```{r}
linelist %>%                                # linelist-ээс эхэл
  mutate(deciles = cut(age_years,           # cut()-аар age_years баганасс decile баганыг үүсгэ
    breaks = quantile(                      # quantile()-аар хуваагдах цэгүүдийг тодорхойл
      age_years,                               # age_years дээр хэрэгжүүл
      probs = seq(0, 1, by = 0.1),             # 0.0 -ээс 1.0 -ыг 0.1 -ээр хуваа
      na.rm = TRUE),                           # дутуу утгуудыг үл тоох
    include.lowest = TRUE)) %>%             # cut() -д  0 насыг оролцуул
  janitor::tabyl(deciles)                   # хүснэгт болгож харуулах
```

### Тэнцүү хэмжээтэй бүлгүүд үүсгэх {.unnumbered}

Тооноос бүлэг үүсгэх өөр нэгэн функц бол **dplyr** багцын `ntile()` юм. Энэ функц таны датаг яг тэнцүү бүлгүүдэд хуваахыг оролддог. `quantile()` -аас ялгаатай тал нь *нэг тоо хоёр өөр бүлэгт орж болдог тул анхаарах хэрэгтэй.* Хуваагдах тоон вектор болон үүсгэх бүлгүүдийн тоог оруулж өгөх хэрэгэтй. `cut()` функцээр үүсгэгдсэн баганын утга тухайн бүлгийн нэр байдаг бол `ntile()`-ээр үүссэн багана дах утга зөвхөн бүлгийн дугаарууд болохыг анхаарна.

```{r}
# ntile()-аар бүлэг үүсгэ
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# бүлэг тус бүрт ноогдох ажиглалтын тоо пропорцыг харуулах
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# зах хязгаарыг харуулах үүднээс min/max -г мөн нэмж харуул
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# нэгтгэж, хэвлэ - зарим утга олон бүлэгт зэрэг орж болохыг анхаар
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

**dplyr** -ын `case_when()` -ыг ашиглаж тоон баганаас ангилал үүсгэж бас болно. Гэхдээ шууд автоматаар эрэмбэлэгдсэн factor төрлийн багана үүсдэг тул **epikit** -ын `age_categories()` эсвэл `cut()` -ыг хэрэглэх нь илүү хялбар байдаг.

Хэрэв `case_when()` -г хэрэглэх бол Re-code values хэсгээс хэрхэн зөв хэрэглэх талаар үзнэ үү. Мөн энэ үед бүх баруун гар талын утгууд ижил төрөл байх хэрэгтэй. Хэрэв `NA` -г баруун гар талд бичих бол "Missing" эсвэл `NA` -г төлөөлсөн тусгай `NA_character_` хэрэглэх шаардлагатай.

### Цэвэрлэх холбоост залгах {.unnumbered}

Жишээгээр хоёр ангилагдсан баганыг цэвэрлэх pipe холбоостоо залгаж өгч харууллаа.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
  
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Мөр нэмэх

### нэг нэгээр нэмэх {.unnumbered}

Мөрийг **dplyr**-ын `add_row()` -аар оруулах нь гар ажиллагаа ихтэй байдаг. Энэ үед багана тус бүр нэг төрлийн дата агуулсан байх шаардлагатайг санаарай (character, numeric, logical гэх мэт). Тиймээс нэмэх мөрийн дата төрлийг тааруулах шаардлагатай.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

`.before` болон `.after.` аргументээр нэмэх мөрийн байрлалыг зааж өгдөг. Жишээ нь`.before = 3` гэвэл шинэ мөрийг одоогийн 3 дугаар мөрний өмнө нэм гэсэн үг. Default -аар мөрийг баганын төгсгөлд нэмдэг. Тодорхойлгоогүй багануудыг дутуу утгаар (`NA`) -авах болно.

Шинэ үүссэн *мөрийн дугаар* хачин харагдаж болох ба ("...23") but the row numbers in the pre-existing rows *have* changed. So if using the command twice, examine/test the insertion carefully.

Хэрэв зааж өгсөн дата төрөл нь таарахгүй бол дараахийн адил алдаа гарч ирнэ:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(огноо төрлийн мөр нэмэхдээ огноогоо `as.Date()` функцэд оруулж өгөөрэй ( `as.Date("2020-10-10")`).

### Мөрүүдийг холбох {.unnumbered}

Нэг хүснэгтийн мөрийг өөр нэг хүснэгтийн доороос залгах бол **dplyr** -ын `bind_rows()`- ыг хэрэглэдэг. Энэ талаар [Joining data] хэсэгт илүү тайлбарласан.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөрийг шүүх

Багануудыг цэвэрлээд, шинэ утгуудыг оруулсны дараа нийтлэг хийгддэг алхам бол **dplyr** -ын `filter()` -ээр мөрөнд шүүлт хийх юм.

`TRUE` байх ёстой логикийг `filter()` дотор зааж өгнө. Дараах хэсгүүдэд энгийн болон комплекс логик шалгуураар хэрхэн мөрийг шүүдгийг харуулав.

<!-- ======================================================= -->

### Энгийн шүүлт хийх {.unnumbered}

Логик шалгуурт нийцсэн мөрүүдийг `linelist` хүснэгтэд шүүж гаргаж ирэх жишээг харуулав. **Зөвхөн хаалтан доторх логик шалгуурт `TRUE` нөхцлүүд л үлддэг.**

Энэ жишээний логик шалгуур нь `gender == "f"`. Үүнийг үгчилбэл gender багана дах утгууд "f" (үсгийн том жижиг хамааатай) -тэй тэнцүү байна уу гэсэн үг.

Шүүлтүүр уншигдахын өмнө `linelist` дэх мөрийн тоо `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # gender баганад "f" гэсэн мөрүүдийг л авч үлднэ
```

Шүүж ялгасны дараа `linelist` хүснэгтэд `linelist %>% filter(gender == "f") %>% nrow()` мөр үлдсэн.

### Дутуу утгуудыг ялгах {.unnumbered}

Нийтлэг хийдэг үйлдлүүдийн нэг бол дутуу утгатай мөрүүдийг ялгах юм. Ингэхдээ шууд `filter(!is.na(column) & !is.na(column))` коммандыг өгөхийн оронд **tydir** багцын яг энэ үйлдэлд зориулсан `drop_na()` функцыг хэрэглэвэл оновчтой. Энэ функцын хаалтыг хоосон орхивол дутуу утга агуулсан мөр болгоныг арилгах болно. Баганын нэрийг зааж өгч болно эсвэл "tidyselect" функцын тусламжтай ([above](#clean_tidyselect)) багануудыг сонгож дутуу утгыг шүүж болно.

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # case_id, age_years багануудад дутуу утгатай  мөрийг арилгах
```

[Missing data] хэсгээс дутуу утгыг янзлах төрөл бүрийн аргатай танилцаж болно.

### Мөрийн дугаараар шүүлт хийх {.unnumbered}

Хүснэгт болон tibble-ийн эхний баганын зүүн талд мөрийн дугаар харагддаг (R Viewer цонхоор харахад). Энэ дугаарууд бие даасан багана биш боловч `filter()` хийхэд хэрэглэгддэг.

Дугаараар нь шүүлт хийхдээ **логик шалгуурын нөхцлийн нэг хэсэгт dplyr** -ын `row_number()` функцыг нээлттэй хааллтайгаар оруулдаг. Логик нөхцөлд `%in%` оператор болон жагсаасан тоо шаардлагатай (дор үзүүлсний дагуу). Эхний N мөрийг харахаын тулд **dplyr** функцын `head()` функцыг хэрэглэнэ үү.

```{r, eval=F}
# Эхний 100 мөр
linelist %>% head(100)     # tail() -аар сүүлийн мөрүүдийг харж болно

# Эхний 5 мөр
linelist %>% filter(row_number() == 5)

# Заасан гурван баганын 2-20 дах мөрийг харуул
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

You can also convert the row numbers to a true column by piping your data frame to the **tibble** function `rownames_to_column()` (do not put anything in the parentheses).

<!-- ======================================================= -->

### Комплекс шүүлт хийх {.unnumbered}

Илүү комплекс логик шүүлт хийхдээ хаалт `( )`, ЭСВЭЛ `|`, үгүйсгэх `!`, `%in%`, БОЛОН `&` операторуудыг ашигладаг.

Тэмдэглэл: `!` операторыг үгүйсгэх логик шалгуурын өмнө тавьдаг. Жишээ нь `!is.na(column)` комманд өгөхөд тухайн баганад *дутуу утга байхгүй* бол `TRUE` гэж гарна. Үүний адил `!column %in% c("a", "b", "c")` комманд өгөхөд баганын утга вектор биш бол `TRUE` гэж гарна.

#### Датаг шалга {.unnumbered}

Доорх коммандаар өвчний эхлэлийг харуулсан гистограмм хийгднэ. Зургаас харахад 2012-2013 оны хооронд гарсан жижиг дэгдэлтийн дата түүхий датаны нэг хэсэг болж орсон байна. **Бидний анализдаа энэхүү өмнөх дэгдэлтийн датаг арилгах шаардлагатай.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### Тоон болон огноон датаны дутуу утгад шүүлт хийх {.unnumbered}

2013 оны 6 сараас хойшхи мөрүүдийг `date_onset` баганад шууд шүүлт хийснээр ялгах боломжтой уу? **Анхааруулга! `filter(date_onset > as.Date("2013-06-01")))` комманд өгвөл дараагийн дэгдэлт дэх дутуу утгатай бүх мөрийг утгагдах болохыг анхаар!**

[***АЮУЛТАЙ:*** Тоон болон огноонд их (\>) багын (\<) тэмдэг хэрэглэхээр дутуу утгатай (`NA`) бүх мөр арилчихдаг! Учир нь `NA` нь хязгааргүй их эсвэл бага утга гэж уншигддаг.]{style="color: red;"}

*(Огноо болон **lubridate** багцтай ажиллах талаар [Working with dates] хэсгээс үзээрэй)*

#### Шүүлтүүрийн загвар гаргах {.unnumbered}

Солбисон хүснэгтээр зөв мөрүүд хамрагдсан эсэхийг шалга:

```{r}
table(Hospital  = linelist$hospital,                     # эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчний эхэлсэн (date_onset) жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Энэхүү датанаас эхний дэгдэлтийн (2012 болон 2013 онуудын) хэсгийг шүүхийн тулд ямар шалгуур нэмж болох вэ? Үүнээс харахад:

-   2012 болон 2013 онд болсон эхний дэгдэлтүүд A , B эмнэлэгт гарч Port эмнэлэгт ердөө 10 тохиолдол бүртгэгдсэн байна.\
-   Хоёрдах дэгдэлтийн үед A болон B эмнэлэгүүдэд дэгдэлт гараагүй. Port эмнэлэгт дэгдэлт гарсан байна.

Дараах хэсгийг хасах хэрэгтэй:

-   А, B, Port эмнэлэгүүдийн тохиолдлуудын өвчин эхэлсэн өдөр нь 2012, 2013 онд тэмдэглэгдсэн мөрүүд `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))`:

    -   2012 болон 2013 онд тэмдэглэгдсэн өвчний эхлэлтэй мөрүүдийг хасах `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))`
    -   A болон B эмнэлэгийн огноо нь дутуу мөрүүдийг хасах `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`\
    -   Огноо нь дутуу утгатай бусад мөрийг **хасахгүй** байх `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))`.

Эхлээд linelist -ийн мөрийн тоо nrow(linelist)\` байсан. Шүүлт хийх нөхцөл:

```{r}
linelist <- linelist %>% 
  # Өвчний эхлэл нь 2013  оны 6 сарын 1 нээс хойш ЭСВЭЛ өвчин эхэлсэн огноо нь дутуу бичигдсн , B эмнэлэгээс эмнэлэгийн бус тохиолдол
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Солбицох хүснэгт дахин хийж үзвэл A болон B эмнэлэгүүдийн дата бүтнээрээ, Port эмнэлэгт 2012, 2013 онд гарсан 10 тохиолдлын мөрүүд хасагдаж бусад утгууд хэвэндээ байна (яг бидний зорьсны дагуу).

```{r}
table(Hospital  = linelist$hospital,                     # Эмнэлэгийн нэр
      YearOnset = lubridate::year(linelist$date_onset),  # өвчин эхэлсэн (date_onset) жил
      useNA     = "always")                              # дутуу утгыг харуул
```

Шүүлт хийх ганц коммандаар олон нөхцөл зэрэг оруулж (таслалаар тугаарлан) оруулж болно. Эсвэл ойлгомжтой болгох үүднээс нөхцөл тус бүрт filter() -т оруулж pipe -аар залгаж болно.

*Тэмдэглэл: зарим уншигчид шууд `date_hospitalisation` шүүлтүүрийг ашиглах нь хялбар болохыг анзаарсан байх. Энэ нь дутуу утга байхгүй 100% бүрэн. бүртгэл юм. Таны зөв. Дээрх жишээний хувьд бол комплекс шүүлт хэрхэн хийхийг үзүүлэх үүднээс `date_onset`-г сонгосон гэдгийг анхаарна уу.*

### Бие даасан үйлдэл {.unnumbered}

Шүүлт хийх үйлдлийг дангаар нь бас гүйцэтгэж болно (pipe холбоосонд залгалгүйгээр). Энэ тохиолдолд **dplyr** -ын бусад функцын адил эхний аргумент нь дата хүснэгт өөрөө байх болно.

```{r, eval=F}
# dataframe <- filter(хүснэгт, мөрийг үлдээх нөхцлүүд )

linelist <- filter(linelist, !is.na(case_id))
```

**base** R -ын дөрвөлжин `[ ]` хаалтыг (сонгосон багана, мөрийг заадаг) ашиглан хүссэн хэсгээ салгаж үзэж болно.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Мөрүүдийг түргэн шалгах {.unnumbered}

Дата янзалж байх явцад зарим мөрийг яаралтай шалгах шаардлага цөөнгүй гардаг. RStudio дээр дата хүснэгттийг хэвлэж үзэхэд **base** R -ын функц `View()`-ийг хэрэглэдэг.

linelist-ийг RStudio-д харах код:

```{r, eval=F}
View(linelist)
```

Доор тодорхой нэг нүдийг шалгаж харах хоёр аргыг харуулав (тодорхий мөр, тодорхой багана):

**dplyr -ын `filter()` болон `select()` функцууд:**

Авч үлдэх мөрүүдээ `filter()` -т, багануудаа `select()` -д оруулэ pipe -аар холбож `View()` дотор бичнэ. Жишээ нь дараах 3 тохиолдлын өвчин эхэлсэн болон эмнэлэгт хэвтсэн огноог харахын тулд доорхи коммандыг өгнө:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

**base** R -ын `[ ]` хаалтыг ашиглан хүссэн хэсгээ салгаж үзэж, дээрхитэй ижил үр дүнг гаргаж бас болно.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Pipe холбоост залгах {.unnumbered}

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг үе шаттайгаар дамжуулан цэвэрлэдэг холбоос)
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
    
    # багана нэм: эмнэлэгт хожуу ирэлт
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 

    # эмнэлэгийн баганууддах утгыг цэвэрлэх
    mutate(hospital = recode(hospital,
                      # ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # age_years баганыг үүсгэ (age болон age_unit баганыг ашиглаж)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
  
    mutate(
          # насны ангилал: өөрөө оруулах
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # насны ангилал: 0 -оос 85 хүртэл 5 -аар
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
    
   # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТ ХЭЛЦЭГДСЭН
   ################################################### 
    
    filter(
          # case_id баганад дутуу утгагүй мөрүүдийг л үлдээ
          !is.na(case_id),  
          
          # зөвхөн хоёрдах дэгдэлтийн датаг үлдээ
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Мөр дагуу тооцоолол

Хэрэв мөр дагуу уртаашаа тооцоолол хийх бол **dplyr**-ын `rowwise()` функцыг хэрэглэ. Онлайн винньетийг [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html)- ээс нэмж үзнэ үү .\

Дор жишээнд linelist датанд `rowwise()` функц мөр болгоныг уртааш нь шалгаж үзээд "yes" гэсэн утгатай нүднүүдийн нийлбэртэй шинэ багана нэмсэн. Шалгагдах багануудыг `sum()` функцэд нэрээр нь вектороор `c()` уагсааж оруулна. `rowwise()` функц нь `group_by()` функцын нэг төрөл тул үйлдлээ хийж дуусаад эргүүлээд `ungroup()` коммандаар задлах шаардлагатай ([Grouping data] хэсэг).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # үзүүлэх зорилготой
```

Шалгах багануудыг сонгохдоо "tidyselect" туслах функцуудыг ( `select()` хэсэгт тайлбарласны дагуу) хэрэглэж болно. Зөвхөн тохируулгыг нь солиход л болно (**dplyr** -ын `select()`, `summarise()` зэрэг функц биш учраас).

**dplyr** -ын `c_across()` дотор нөхцлөө оруулж өгнө. Учир нь `c_across` ([documentation](https://dplyr.tidyverse.org/reference/c_across.html)) функц `rowwise()` -аар ажилладаг. Жишээ нь дараах код ажиллах дараалал нь:

-   эхлээд `rowwise()` гүйцэтгэгдэх ба ингэснээр үүний дараа хийгдэх үйлдэл (`sum()`) мөр болгонд хийгднэ (багануудын нийлбэр биш).
-   `num_NA_dates` хэмээх шинэ баганыг нэмж, defined for each row as the number of columns (with name containing "date") for which `is.na()` evaluated to TRUE (they are missing data).\
-   `ungroup()` хийснээр дараагийн хийгдэх үйлдлүүдэд `rowwise()` нөлөөлөхгүй байх болно.

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # үзүүлэх зорилготой
```

Нэмж `max()` гэх мэт бусад функцыг хэрэглэж болно. `max()`-аар мөр болгон дах хамгийн шинэ огноог харуулдаг:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # үзүүлэх зорилготой
```

## Эрэмбэлэн ялгах

Мөрийг баганын утгаар эрэмбэлэх бол **dplyr** функцын `arrange()` -ыг хэрэглэнэ.

Багануудыг эрэмбэлэх дарааллын дагуу жагсааж бичнэ. Хэрэв эрэмбэлэлтийг аль нэг баганын ангиллын дагуу хийх бол `.by_group = TRUE` гэж аргументийг тохируулна ([Grouping data] хэсгээс харна уу).

Default-аар бол баганын утга "ихсэх" дарааллаар эрэмбэлэгддэг (тоо болон үсгэн утга). Баганын нэрийг `desc()` -д оруулсанаар "буурах" дараалалд оруулж болно.

Ялангуяа тайлан, илтгэлд зориулсан хүснэгт ([Tables for presentation]) дээр ажиллахад `arrange()` -ыг ашиглавал оновчтой. `slice()` -аар ангилал тус бүрийн "оройн" мөрүүдийг харуулж болно. Мөн factor-ын шатлалыг харагдах байдлаар нь эрэмбэлж тохируулж болдог.

Жишээ нь, linelist датаг `hospital` баганын дагуу эрэмбэлээд, дараа нь `date_onset` -ээр буурах дарааллаар эрэмбэлэе гэвэл дараах байдлаар кодыг бичнэ:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# ХАРАГДАХГҮЙ
#
# хуучин дэгдэлтийн нэг мөрийг NA болго
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# БАГАНУУДЫГ ЭКСПОРТЛОХОД БЭЛДЭЖ ЭРЭМБЭЛ
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# ЦЭВЭРЛЭГДСЭНLINELIST ФАЙЛЫГ "DATA" ХАВТАСТ ЭКСПОРТЛОХ
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"), overwrite = TRUE)
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
