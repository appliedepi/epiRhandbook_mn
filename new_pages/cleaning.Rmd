# Өгөгдлийг цэвэрлэх ба үндсэн функцууд

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Энэ бүлэгт датаг "цэвэрлэх" нийтлэг аргуудыг үзэж R-ын дата менежментэд хэрэглэгддэг гол функцуудыг тайлбарлана.

Дата цэвэрлэгээг тайлбарлахдаа түүхий (raw) linelist -ийг импортлохоос эхлээд хэрхэн цэвэрлэгээ хийж буйг нэг бүрчлэн үзүүлэх болно. R- дээр дата "pipe (хоолой)" залгагдсан холбоосоор дамжин хийгддэг ба датаг нэгээс нөгөөрүү дамжуулах үйлдлийг "pipe" `%>%` буюу холбогч оператор гүйцэтгэдэг.

### Үндсэн функцууд {.unnumbered}

Энэхүү номонд [**tidyverse**](https://www.tidyverse.org/) бүлгийн харяа багцууд, тэдгээрийн функцыг голчлон тайлбарлна. Гол хэрэглэгдэх функцуудыг дор жагсаав.

Үүнд [**dplyr**](https://dplyr.tidyverse.org/) багцын дата засаж, янзалдаг "үйл үгэн" функцууд түлхүү орсон (**dplyr** багцын нэр "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)(хүснэгтийг%20засах)%22%20гэсэн%20утгатай) буюу "хүснэгт засагч" гэсэн утгатай). **dplyr** бол **tidyverse** -ын харьяа багц ( **tidyverse** --ын бусад багцуудад **ggplot2**,**tidyr**,**stringr**,**tibble**,**purrr**,**magrittr**,**forcats** ордог).

+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| Function                                            | Utility                                                             | Package                       |
+=====================================================+=====================================================================+===============================+
| `%>%`                                               | "pipe" (дамжуулах) датаг нэг функцээс нөгөөд дамжуулна              |     | **magrittr**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `mutate()`                                          | Баганыг үүсгэж, хувиргаж, өөрчилдөг \| \*\*dp                       | lyr\*\*                       |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `select()`                                          | Баганыг үлдээх, арилгах, шинээр нэр өгдөг                           | \| **dplyr**                  |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rename()`                                          | Баганыг шинээр нэрлэдэг                                             |       | **dplyr**             |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_names()`                                     | Баганын нэрсийг жигд болгодог \| \*\*janit                          | or\*\*                        |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | Баганадах өгөгдлийн төрлийг өөрчилнө.                               | \| **base** R                 |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `across()`                                          | Олон баганыг зэрэг хувиргана \| **dplyr**                           |                               |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| **tidyselect** functions                            | Баганыг сонгохдоо logic ашиглаган                                   |     | **tidyselect**          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `filter()`                                          | Тодорхой мөрүүдийг авч үлдэх                                        |          | **dplyr**          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `distinct()`                                        | Мөрүүдийг давхардалтыг арилгах                                      |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `rowwise()`                                         | Мөр дагуу үйлдэл хийх \| \*\*dplyr                                  | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `add_row()`                                         | Мөрийг гар аргаар нэмэх                                             | \| **tibble**                 |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `arrange()`                                         | Мөрийг эрэмбэлэх                                                    |      | **dplyr**              |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `recode()`                                          | Баганадах утгыг дахин өгөх \|                                       | **dplyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `case_when()`                                       | Баганад илүү нарийвчилсэн логик шалгуураар утга оруулна\| \*\*dplyr | \*\*                          |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | Баганад утга өгөх тусгай функцууд                                   | **tidyr**                     |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `age_categories()` and `cut()`                      | Тоон утгатай баганаас категортой бүлэг үүсгэ \| \*                  | \*epikit **and** base\*\* R   |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `clean_variable_spelling()`                         | Датаны тайлбар толийг ашиглан баганын утгыг өөрчлөх, арилг          | ах \| **linelist**            |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+
| `which()`                                           | Логик шалгуур ашиглах; Индексийг харуулах (return indices)          |                  | **base** R |
+-----------------------------------------------------+---------------------------------------------------------------------+-------------------------------+

Эдгээр функцууд Stata болон SAS программ дээр хэрхэн бичигддэг талаар [Transition to R] --линкээс үзэж болно.

Датаг янзалж байхад R-ын **data.table** багцын операторууд `:=` болон `[ ]`-ыг олж харах магадлалтай. **data.table** багцын хэрэглэгддэг синтакс, аргачлалыг [Data Table] хуудаст товч оруулсан.

### Нэр томьёо {.unnumbered}

Энэ номонд хувьсагч (variable) -ийг багана, ажиглалт (observations) -ийг мөр гэж нэрших болно. Тархвар судлалын ихэнх датаг гол бүрдүүлдэг зүйлс бол багана, мөр, доторх утгууд гэж ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html) "tidy data" линкэд тайлбарласан байна.

*Хувьсагч (Variables)* нь ижил хэв шинжтэй утгуудыг агуулсан байдаг (насны бүлэг, өвчин эхэлсэн огноо, эмчилгээний үр дүн гэх мэт ). *Ажиглалт (Observations)* гэж тухайн нэгжийн бүх төрлийн хэмжилтүүдийг хэлнэ (хүн, газар, лабораторийн дээж материал). Эдгээр шинж талуудыг бодитоор, барьцтай илэрхийлэх нь бэрхшээлтэй.

"Tidy/Цэгцтэй" өгөгдөлд, багана болгон хувьсагч, мөр болгон ажиглалт ба нэг нүд болгон нэг утгыг зааж байдаг. Заримдаа энэ загварт хэлбэржээгүй дататай та учирч болох юм. Тухайлбал " wide(өргөн)" дата гэхэд хувьсагч нь хэд хэдэн баганад хуваагдан байрладаг. Үүний жишээг [Pivoting data]--т хэсэгт жишээг харуулсан. Ажиглалт ч гэсэн хэд хэдэн мөрөнд хуваагдан байрласан байх тохиолдол бий.

Энэ номоороо бид датаг хэрхэн хувиргаж, янзлах, менежмент хийдгийг харуулахыг илүү эрмэлзсэн . Тийм ч учраас хувьсагч, ажиглалт зэрэг хийсвэр тодорхойлолт хэрэглэхийн оронд мөр, багана зэрэг бүтцийн нь нэршилийг хэрэглэх нь илүү тохиромжтой гэж үзсэн. Харин статистик дүн шинжилгээний талаар тайлбарласан хэсгүүдэд хувьсагч, ажиглалт гэсэн нэршил илүү хэрэглэгдсэн.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Цэвэрлэх холбоос

**Энэ хэсэгт датаг цэвэрлэгээг үе шат тус бүрээр нь тайлбарласан. Цэвэрлэгээний явцыг нэг бүрчлэн "pipe" цэвэрлэх холбоост залгаж үзүүлсэн.**

Тархвар судлалд датаг янзлах, цэвэрлэх явц хоорондоо холбоотой дараалласан үйлдлүүдээс бүрддэг. R программ дээр цэвэрлэгээг хийхдээ мөн адил *датаг нэг цэвэрлэх шатнаас нөгөөд угсруулан үйлддэг.*

Ийм угсруулсан үйлдлүүдийг **dplyr** --ын "үйл үгт" функцуууд болон **magrittr**-ын pipe`%>%` холбогч оператор хамтран гүйцэтгэдэг. Цэвэрлэгээ түүхий датагаар ("linelist_raw.xlsx") эхлээд R --ын "цэвэрхэн" хүснэгт (`linelist`) болж хувиран гардаг. Үүнийг шууд ашиглаж, хадгалж, экспортлож болно.

Цэвэрлэгээ хийж байхад үйлдлийн дараалал чухал. Дараах дарааллаар хийх нь элбэг:

-   Датаг оруулж ирэх\
-   Баганын нэрсийг өөрчлөх, арилгах\
-   Давхардсан утгуудыг арилгах\
-   Багана нэмж, хувиргах (утгыг хувиргах, )Column creation and transformation (баганадах утгыг хувиргах, утгыг стандардчилах гэх мэт)\
-   Мөрүүдийг шүүж хасаж, нэмэх

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Багцуудыг ачааллах

Доорх кодыг уншуулж шаардлагатай багцуудыг ачааллана. Энэ номонд багцыг ачааллахад **pacman** -ны `p_load()`-ыг голчлон хэрэглэ. Энэ функц нь шаардлагатай багцыг автоматаар татаж авч, ачааллаад ажиллахад бэлэн болгодог. **base** R-ын багцыг `library()`--аар та өөрөө шууд (татаж авалгүйгээр )ачааллаж бас болно. [R basics] хэсгээс талаар нэмж үзнэ үү.

```{r, message = F}
pacman::p_load(
  rio,        # дата оруулах  
  here,       # файлын холбоотой замыг тогтоох 
  janitor,    # дата, хүснэгт цэвэрлэх
  lubridate,  # огноотой ажиллах
  epikit,     # age_categories() функц
  tidyverse   # дата менежмент ба график зураглал
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Датаг импортлох

### Импорт хийх {.unnumbered}

Түүхий дата агуулсан Excel файлыг **rio**-ын `import()` функцээр импортлоно. **Rio** багц файл ын олон төрөлтэй ажиллаж чаддагаараа онцлог (.xlsx, .csv, .tsv, .rds. гэх мэт). [Import and export] хэсгээс дэлгэрүүлж үзнэ үү.

Хэрэв хамт дасгалыг зэрэг хийхийг хүсвэл энэ линкээр датаг татаж авна уу. <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>линк дээр дарж "түүхий" linelist -ыг татаж ав</a> ( .xlsx файл).

If your dataset is large and takes a long time to import, it can be useful to have the import command be separate from the pipe chain and the "raw" saved as a distinct file. This also allows easy comparison between the original and cleaned versions.

Below we import the raw Excel file and save it as the data frame `linelist_raw`. We assume the file is located in your working directory or R project root, and so no sub-folders are specified in the file path.

```{r, echo=F, message=F}
# HIDDEN FROM READER
# actually load the data using here()
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

You can view the first 50 rows of the the data frame below. Note: the **base** R function `head(n)` allow you to view just the first `n` rows in the R console.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Тоймлон үзэх {.unnumbered}

Дата-хүснэгтийн талаарх ерөнхий тойм мэдээг авахдаа **skimr** багцын `skim()` функцыг хэрэглэж болно. ([Descriptive tables] хэсгээс нэмж харна уу). Баганууд numeric (тоон), character (үсгэн) зэрэг төрлөөсөө хамаарч тусдаа тоймлогддог. Тэмдэглэл: "POSIXct" бол нэг төрлийн боловсруулагдаагүй огнооны төрөл. ([Working with dates] хэсгээс харна уу).

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганын нэрс

Хүснэгт импортлоход хамгийн эхний, толгой мөрийг R программ баганын *нэр* гэж уншдаг. Кодын синтакст мөн энэ нэрийг дуудаж хэрэглэнэ.

SAS, STATA зэрэг бусад статистик программд баганын толгойд буй товчилсон нэрнээс гадна *"дэлгэрэнгүй нэр (labels)"* гэж байдаг. R дээр багана тус бүрт label өгөх боломжтой ч ингэж нэмэх нь ховор. График дээр хэвлэлд тохиромжтой баганын нэрс оруулах бол тухайн график хэвлэх коммандад дэлгэцийг тохируулгыг оруулж өгөх хэрэгтэй (тэнхлэгийн (axis) нэрс, ялгах тэмдгийн (legends), нэрс, багана толгой гэх мэт. [scales section of the ggplot tips page](https://epirhandbook.com/ggplot-tips.html#ggplot_tips_scales) болон [Tables for presentation](https://epirhandbook.com/tables-for-presentation.html#tables-for-presentation) хуудсаас нэмж уншна уу). Баганад label өгөх талаар [here](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) болон [here](https://cran.r-project.org/web/packages/labelled/vignettes/intro_labelled.html) гэсэн линкүүдээс үзэж болно.

Баганын нэрс R дээр байнга хэрэглэгдэх тул "цэвэр" синтакстай байх нь чухал. Дараах аргаар нэрлэвэл тохиромжтой байдаг:

-   Богино
-   Зай авахгүй, доогуур зураас \_ хэрэглэх
-   Өвөрмөц тэмдэглэгээ оруулахгүй (&, \#, \<, \>, ...)
-   Төстэй нэрлэх ( жишээ нь бүх огноотой баганыг **date\_**onset, **date\_**report, **date\_**death гэж нэрлэх)

`linelist_raw`--дах баганын нэрсийг **base** R --ын `names()` функцийг уншуулж дор хэвлээд эхний байдлаар харахад:

-   Зарим нэрс зай авсан (жишээ нь `infection date`)\
-   Огноотой баганууд жигд бус нэрлэгдсэн (жишээ `date onset` багана `infection date` ээс өөр)\
-   There must have been a *merged header* across the two last columns in the .xlsx. We know this because the name of two merged columns ("merged_header") was assigned by R to the first column, and the second column was assigned a placeholder name "...28" (as it was then empty and is the 28th column).

```{r}
names(linelist_raw)
```

[***ТЭМДЭГЛЭЛ:*** зай авсан баганы нэрийг хойшоо харсан дан хашилтад хий. Жишээ нь: linelist\$`` ` '\x60infection date\x60'` ``. Үүнийг бичихдээ компьютерийн гаран дээрх хойшоо харсан дан хашилт (\`) бичгийн дан хашилтаас ( ' ) өөр гэдгйиг анхаарна уу.]{style="color: black;"}

### Автомат цэвэрлэгээ {.unnumbered}

**janitor** багцын `clean_names()` функц баганын нэрсийн өвөрмөц хэвээр байлгангаа жигд болгож өгдөг. Ингэхдээ:

-   Бүх баганыг зөвхөн доогуур зураас, тоо, үсгээс бүрдсэн нэртэй болгож хувиргана.\
-   Өргөгдсөн эгшгүүд ASCII хэлрүү галиглагдна (Герман хэлний ö --г "o"-руу, Испани хэлний "enye" -г "n" болгох гэх мэт)\
-   Үсгийн том жижгийг `case =` аргументэд зааж өгч болно ("snake" хэлбэр default сонголт, "sentence", "title", "small_camel" гэх мэт өөр сонголтууд буй)\
-   Нэр өөрчлөх, орлуулахдаа `replace =` аргументийг ашиглаж болно (ж: `replace = c(onset = "date_of_onset")`)\
-   Онлайн [vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) --г эндээс харж болно

Цэвэрлэх процесс `clean_names()` функцэд түүхий linelist --ийг оруулснаар эхэлнэ:

```{r clean_names}
# түүхий датагаа clean_names() –д холбоод, үр дүнг нь "linelist" хүснэгтэд оноо
linelist <- linelist_raw %>% 
  janitor::clean_names()

# баганын шинэ нэрс
names(linelist)
```

[***ТЭМДЭГЛЭЛ:*** сүүлийн баганын нэр "...28" байснаа "x28" болж хувирсан".]{style="color: black;"}

### Баганын нэрийг гар аргаар цэвэрлэх {.unnumbered}

Баганын нэрсийг дээрх байдлаар жигдрүүлсний дараа гар аргаар цэвэрлэх хэрэг заавал гардаг. Дор кодонд **dplyr** --ын `rename()` функцыг pipe холбоостоо залгаж зарим баганад шинэ нэр өгсөн. `rename()` функц `NEW = OLD`-- гэсэн дарааллаар аргументээ авдаг. Эхлээд шинэ, дараа нь хуучин нэрийг бичнэ.

Дараах цэвэрлэгээний процесст нэр өгөх комманд нэмэгдэж орж ирснийг ажиглаарай. Уншихад амар болгож зарим газар зай авсан.

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг цэвэрлэх үе шатуудаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
    
```

Баганын нэрс өөрчлөгдсөн нь энд харагдаж байна:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Баганын байрлалаар нь нэр өгөх {.unnumbered}

Баганыг нэрийг солихдоо нэрээр нь дуудахаас гадна байрлалыг нь дуудаж болдог. Жишээ нь:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### `select()`болон `summarise()` ашиглан нэр өгөх {.unnumbered}

Нэр өгөхдөө **dplyr** -ын `select()`болон `summarise()` функцуудыг хавсран ашиглавал арай түргэн байдаг. `select()`--ээр зөвхөн тодорхой багануудыг сонгож авна (дараагийн хэсгүүдэд дахин дурьдна).`summarise()`--г [Grouping data] болон [Descriptive tables] хэсгүүдэд тайлбарласан. Эдгээр функц мөн адил `new_name = old_name` гэсэн дарааллаар аргументээ авна. Жишээ:

```{r, eval=F}
linelist_raw %>% 
  select(# ШИНЭ нэр              # ХУУЧИН нэр
         date_infection       = `infection date`, # нэрийг солиод, ЗӨВХӨН тухайн багануудыг л авч үлднэ
         date_hospitalisation = `hosp date`)
```

### Бусад {.unnumbered}

#### Excel дээрх баганын нэр хоосон байх {.unnumbered}

R-т баганын нэргүй дата байх боломжгүй. Хэрэв Excel --ийн хоосон толгой агуулсан багануудтай хүснэгт R --луу оруулж ирвэл R баганыг "...1", "...2" гэх мэтээр байрлалаас нь хамаарч автоматаар нэрлэдэг (жишээ нь хүснэгтийн 4 дэх багана нэргүй хоосон орж ирсэн бол R тэр баганыг "...4" гэж нэрлэнэ).

You can clean these names manually by referencing their position number (see example above), or their assigned name (`linelist_raw$...1`).

Эдгээр автоматаар өгөгдсөн нэрсийг та өөрөөр байрлалаар нь, эсвэл оноогдсон нэрээр нь дуудаж (linelist_raw\$...1) цэвэрлэж болно (жишээг дээр харуулсан),

#### Excel багана, нүднүүд нэтгэгдсэн (merged) байх {.unnumbered}

Заримдаа Excel --ийн файл хүлээж авахад хүснэгтийн нүднүүд нэтгэгдсэн (merged) байдаг. Нэгтгэгдсэн нүдтэй хүснэгт хүн уншихад амар боловч, "цэгцтэй дата/tidy data" хэлбэрт ороогүй учраас компьютерт сайн уншигддаггүй ([Transition to R] хэсэгт тайлбарласан). R --дээр нэгтгэгдсэн нүднүүд уншигдахгүй.

Дата оруулж буй хүмүүстээ **хүнд уншигддаг дата машинд уншигддаг дата хоёр өөр** гэдгийг сайн ойлгуулах хэрэгтэй. Цэгцтэй датаны [**tidy data**](https://r4ds.had.co.nz/tidy-data.html) зарчмыг ойлгуулахыг эрмэлз. Болж өгвөл дата оруулах аргачлалд нь өөрчлөлт хийж аль болох цэгцэрсэн, ямар нэг нэгтгэсэн нүдгүй байхгүй дата өөртөө авахаар зохицуулбал сайн.

-   Хувьсагч тус бүр баганатай байна.\
-   Ажиглалт тус бүр мөртэй байна\
-   Утга тус бүр өөрийн нүдэнд байна.

**rio-ын** `import()` функцээр дата оруулж байхад датанд нэтгэгдсэн нүд тохиолдвол тухайн нүд задарч доторх утга эхний нүдэнд бичигдээд дараах нүднүүд нь хоосон орхигддог.

Нэтгэгдсэн нүдний асуудлыг **openxlsx** багцын `readWorkbook()`функцээр шийдвэрлэх боломжтой. Үүний `fillMergedCells =` аргументийг TRUE гэж тохируулснаар нэтгэгдсэн нүднүүд задрахад доторх утга бүгдэд нь зэрэг хуваарилагдаж ордог.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***АЮУЛТАЙ:*** `readWorkbook()` -өөр баганын нэрс нэгтгэгдсэн бол давхардсан нэртэй багануудтай болчихдог ба үүнийг гараар цэвэрлэхээс шаардлагатай. R давхардсан нэртэй ажиллахдаа муу! Давхар нэртэй багануудын нэрийг байршлаар нь дуудаж сольж болно (баганын нэрийг гар аргаар цэвэрлэх хэсэгт тайлбарласан)]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганыг сонгох болон эрэмбэлэх

Аль баганыг үлдээхээ dplyr-ын `select()` --д оруулж, дэс дарааг нь зааж өгч болно.

[***БОЛГООМЖЛОЛ:*** дорх жишээнд `linelist`- датаг `select()` --ээр өөрчилж харуулсан боловч хадгалаагүй. Энд зөвхөн үзүүлэх зорилготой. Pipe холбоостоо `names()-ыг` залгаж шинэ нэрүүдийг харж болж байна. ]{style="color: orange;"}

Цэвэрлэх холбоосонд [linelist --ын БҮХ нэрс цэвэрлэгдсэн байх үеийг энд харуулав]{style="color: orange;"}:

```{r}
names(linelist)
```

### Баганыг үлдээх {.unnumbered}

Баганыг үлдээх

**Зөвхөн үлдээх шаардлагатай багануудаа л сонго.**

Шаардлагатай багануудаа `select()`комманд дотор хашилтгүйгээр оруул. Баганууд таны оруулсан дарааллаар хүснэгтэд харагдана. Байхгүй багана `select()`--д бичвэл R алдаа заана. (алдаа заахгүйгээр үргэлжлүүлэх талаар `any_of()`--ын тайлбараас үзнэ үү).

```{r}
# linelist датаг select() коммандаар цэвэрлээд names() -ээр баганын нэрсийг хэвлэсэн
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # баганын нэрсийг хэвлэж харуулах
```

### "tidyselect" туслах функцууд {#clean_tidyselect .unnumbered}

Багана үлдээх, хасах эсвэл хувиргах үйлдлүүдийг туслах функцээр хялбарчилж болдог. Туслах функц нь **tidyverse**-ын харьяа **tidyselect** багцад ордог ба **dplyr** -ын багана сонгох үйлдэл дээр суурилдаг.

Тухайлбал баганын дарааллыг өөрчлөхөд "бичигдсэн баганаас бусад баганыг" заадаг `everything()` функц их хэрэг болдог. Доорх код `date_onset` болон `date_hospitalisation` багануудыг хамгийн эхэнд (зүүн талд) авчраад, үлдсэн багануудыг ардаас нь хэвээр нь байлгана.Энд `everything()` хоосон бичигдсэн байгааг анхаар:

```{r}
# date_onset болон date_hospitalisation -г хамгийн урд зөөж авчрах
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Энд *within* **dplyr** багцын `select()`, `across()`, `summarise()`зэрэг функцуудтай хамтарч ажилладаг **tidyselect** функцуудыг жагсаав :

-   `everything()` - дурьдсанаас бусад бүх баганууд\

-   `last_col()` - сүүлийн багана\

-   `where()` - аливаа функцыг бүх баганад уншуулж үзээд, TRUE тохиодлуудыг\

-   `contains()` - тодорхой үсэг, тэмдгийг (character) агуулсан багана

    -   жишээ: `select(contains("time"))`\

-   `starts_with()` - баганын нэрийн эхлэл хэсгийг тааруулах

    -   жишээ: `select(starts_with("date_"))`\

-   `ends_with()` - баганын нэрийн төгсгөл хэсгийг тааруулах

    -   жишээ: `select(ends_with("_post"))`\

-   `matches()` - regular expression (regex) -ийг тааруулах

    -   жишээ: `select(matches("[pt]al"))`\

-   `num_range()` - x01, x02, x03 зэргээх тоо, дугаараар тааруулах\

-   `any_of()` - аль нэг багана байхгүй тохиолдолд алдаа заахгүйгээр үйлдлийг гүйцэтгэнэ.

    -   жишээ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Үүнээс гадна ердийн операторуудыг ашигла. Жишээ нь `c()`-аар хэд хэдэн баганыг жагсаах,`:` -аар дарааллаж байрласан багануудыг сонгож болно. Мөн `!`- эсрэг,`&` БА, `|` ЭСВЭЛ зэргийг багана сонгоход ашиглаж болно.

Баганын логик шалгуураар сонгох бол`where()`-ийг хэрэглэ. Хэрэв `where()`-ийг функцын дотор хэрэглэж буй бол хоосон хаалттайгаар хэрэглэж болохгүй. Дорх жишээнд зөвхөн тоон утгатай багануудыг сонгохыг харууллаа.

```{r}
# Тоон утгатай багануудыг сонгох болно
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Баганын нэрэнд тодорхой үсэг, үг агуулагдсан тохиолдолд тухайн баганыг сонгох бол `contains()` -ыг хэрэглэ. Мөн`ends_with()` болон `starts_with()` -аар арай тодорхой зааж өгч болно.

```{r}
# тодорхой үг, үсэг нэрэндээ агуулсан багануудыг сонгох
linelist %>% 
  select(contains("date")) %>% 
  names()
```

`matches()` функц `contains()` -тай төстэй үүрэгтэй ба regular expression ашигладгаараа онцлог ([Characters and strings]) хэсгээс нэмж харна уу. Дорх жишээнд тааруулах үг, үсэгнүүдээ (strings) ЭСВЭЛ босоо зураасаар тусгаарлаж хашилтанд хийсэн буйг харж байна :

```{r}
# олон үг, үсэгнүүдийг зэрэг хайж, тааруулах
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***БОЛГООМЖИЛ:*** Хэрэв та датанд байхгүй баганын нэрийг функцэд өгсөн бол алдаа зааж үйлдэл тэр дороо зогсох болно. Ийм тохиолдолд `any_of()` -ийг хэрэглэхийг зөвлөж байна. Энэ функц заасан багана байхгүй ч байж магадгүй гэж илэрхийлдэг ба ялангуяа баганыг хасахад их хэрэг болдог.]{style="color: orange;"}

Дор жишээнд дурьдсан багануудын нэг нь л оршиж буй боловч дорх код алдаа заахгүйгүээр үргэлжилж, цэвэрлэх холбоосын залгаа үйлдлүүд зогсолтгүйгээр гүйцэтгэлээ хийх болно.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Баганыг хасах {.unnumbered}

Хасах ("-") тэмдэг (ж:`select(-outcome)`) эсвэл баганын нэрээс бүтсэн вектороор (дор жишээнд үзүүлсэн) **аль баганыг хасахаа зааж өг**. Бусад баганууд хэвээр үлдэх болно.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # date_onset болон fever ээс vomit хүртэлх баганыг хасах
  names()
```

Мөн **base** R -ын синтакс болох `NULL`-ыг ашиглаж баганыг хасч болно. Жишээ нь:

```{r, eval=F}
linelist$date_onset <- NULL   # base R -ын синтаксаар date_onset баганыг хасах
```

### Дангаараа үйлдэх коммандууд {.unnumbered}

`select()` -ийг дангаар нь мөн хэрэглэж болно (pipe холбоосны залгаа биш). Энэ тохиолдолд эхний аргумент нь тухайн ажиллаж буй хүснэгтийн нэр байдаг.

```{r}
#  id болон насыг харуулсан шинэ linelist үүсгэх
linelist_age <- select(linelist, case_id, contains("age"))

# үүсгэсэн linelist-ийн баганын нэрсийг харуул
names(linelist_age)
```

#### Pipe холбоосонд нэмж залгах {.unnumbered}

`linelist_raw`-хүснэгтийн дараах баганууд бидэнд шаардлагагүй: `row_num`, `merged_header`, `x28`. Эдгээрийг хасахдаа `select()` коммандыг pipe холбоосонд залгаж хасаж болно:

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг цэвэрлэх үе шатуудаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
           # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################

    # баганыг хас
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Давхардалтыг арилгах

Энэхүү номын [De-duplication] хэсгээс давхардалтыг арилгах нэмэлт аргын талаар дэлгэрүүлж үзнэ үү.Энд бид зөвхөн энгийн мөрний давхардалтыг арилгах талаар тайлбах болно.

**dplyr** багцад `distinct()` гэсэн функц буй. Энэ функц бүх мөрийг шалгаж үзээд датаг зөвхөн өвөрмөц мөрүүдээс бүрдсэн болгож багасгадаг. Энэ үйлдлээр яг 100% адилхан давхар мөрүүдийн давхардалт л арилдаг.

Давхардсан мөрүүдийг хайхдаа тодорхой хэмжээний мөрийг хамруулж шалгадаг (default аар бүх мөрийг зэрэг шалгана). Хэдий хэмжээний мөрүүдэд хайгуул хийхээ өөрөө тохируулж болно (давхардалтыг арилгах хэсэгт мөн тайлбарласан). Ингэснээр өвөрмөц мөрүүд зөвхөн тухайн хайлт хийсэн мөрнүүдийн хүрээнд л үүсэх юм.

Дорх энгийн жишээнд хоосон `distinct()`-ийг цэвэрлэх холбоосондоо залгаж өгсөн. Ингэснээр 100% ижилхэн мөрүүдийн давхардал датанд байхгүй байхаар цэвэрлэгээ хийгдлээ гэсэн үг юм (бүх мөрийг зэрэг шалгана).

Энд `linelist`-ийн `nrow(linelist)` коммандаас эхлэе.

```{r}
linelist <- linelist %>% 
  distinct()
```

Давхардалтыг арилгасны дараа үлдсэн мөрийн тоог `nrow(linelist)` -ээр уншуулж мэднэ. Хэрэв мөр арилсан бол аль нэг мөрний 100% ижил давхар мөр арилсан гэсэн үг.

Дор `distinct()` коммандыг pipe холбоосонд залгаснаар харууллаа

```{r}
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг цэвэрлэх үе шатуудаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    #####################################################
    
    # давхардлыг арилгах
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Баганыг үүсгэх ба хувирагх

**Шинэ багана нэмж, хуучин баганыг хувиргах үйлдлийг dplyr багцын `mutate()` функц ашиглан гүйцэтгэхийг зөвлөж байна.**

Дор жишээнд `mutate()`ашиглан шинэ багана нэмэхийг харуулсан. Синтакс нь: `mutate(new_column_name = value or transformation)`

R'-ын `mutate()` Stata-ын `generate`коммандтай төстэй боловч хуучин баганыг хувиргадагаараа онцлог.

### Шинэ багана {.unnumbered}

`mutate()` -ээр шинэ багана үүсгэх их энгийн жишээг дор харуулав. Энд бүх мөр нь 10 -ын тоотой энгийн `new_col` баганыг нэмж байна.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Өөр багануудын утгыг холбож, тооцоолол хийж бас болно. Дор жишээнд `bmi` Биеийн Жингийн Индексийг тооцоолсон (БЖИ = кг/жин\^2) шинэ баганыг `ht_cm`, `wt_kg` гэсэн хуучин багануудыг ашиглан үүсгэсэн.

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Шинэ багана олныг зэрэг үүсгэх бол багана тус бүрийг таслалаар тусгаарлаж шинэ мөрөнд бичнэ. Дор шинэ баганууд нэмэх жишээ харуулсан. Үүнд хуучин багануудыг **stringr** -ын`str_glue()`-ээр нийлүүлж үүсгэсэн багана бас буй. ([Characters and strings] -аас харж болно.

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # шинэ багана = хуучин баганыг хувилах
    new_var_static = 7,                   # шинэ багана = бүх утга ижилхэн
    new_var_static = new_var_static + 5,  # хуучин баганын дээр шинэ багана үүсгэж болох ба ингэхдээ өөр баганыг ашиглан тооцоолол хийж болно. 
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") # шинэ багана = бусад баганын утгыг хооронд нь нийлүүлж (paste) үүсгэнэ
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # үзүүлэх зорилгоор зөвхөн шинэ багануудыг харуулна
```

Шинэ багануудыг шалга. Дор жишээнд та бүхэнд харуулах зорилгоор зөвхөн шинээр үүссэн баганууд болон тэднийг үүсгэхэд оролцсон багануудыг л хэвлэсэн :

```{r message=FALSE, echo=F}
# linelist датаг хүснэгтээр харуулах
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***ЗӨВЛӨГӨӨ:*** `mutate()` -ын өөр нэгэн хувилбар бол `transmute()` юм.Энэ функц яг `mutate()` тай адилаар шинэ багана нэмэхээс гадна функц дотор дурьдаагүй багануудыг бүгдийг хасдаг.]{style="color: darkgreen;"}

```{r, eval=F}
# УНШИГЧИД ХАРАГДАХГҮЙ
# дээр үүсгэсэн баганыг хасна
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Баганын төрлийг хувиргах {.unnumbered}

Огноо, тоо, логик (TRUE/FALSE) утгуудыг агуулсан баганын ангиллыг зөв тодорхойлж оруулбал эдгээр баганатай ажиллахад хялбар болдог. Жишээ нь "2" бол character байхад 2 -ыг тоо уншигддаг!

Импорт хийж байх үед баганын төрлийг тохируулах аргууд буй боловч үйлдэл ихтэй. [R Basics] хэсэгт обьектийн төрлийн талаар, хэрхэн хувиргахыг дэлгэрүүлж уншиж болно.

Дор жишээнд эхлээд гол багануудын төрөл зөв танигдсан эсэхийг шалгаж үзэх болно. Үүнийг `skim()` -ийг уншуулахад мөн баганын төрлүүдийг харж болж байсан.

Одоо `age` баганын төрөл нь character байна. Энэ баганад тооцоолол хийхийн тулд тухайн баганын утга тоон утга гэж танигдсэн байх шаардлагатай!

```{r}
class(linelist$age)
```

`date_onset` баганын төрөл нь мөн character! Анализ хийхийн тулд эдгээр багана огноо хэлбэрээр танигдсан байх шаардлагатай!

```{r}
class(linelist$date_onset)
```

Ийм тохиолдолд `mutate()`-аар баганыг дахин тодорхойлж зөв төрөлд нь хувиргаж болно. Энэ үед баганын утгыг өөрчлөхгүйгээр зөвхөн төрлийг нь хувиргадаг. Дор энгийн жишээгээр `age` баганыг тоон утгатай баганаруу хувиргаж/бататгаж байна:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Үүнтэй адилаар `as.character()` болон `as.logical()` зэргийг хэрэглэж болно. Factor төрлийг хувиргахын тулд **base** R -ын`factor()` эсвэл **forcats**-ын `as_factor()`-г хэрэглэдэг. Энэ талаар [Factors] хэсгээс нэмж уншна уу.

Огноог болгоомжтой хувиргах шаардлагатай. [Working with dates] хэсэгт хэд хэдэн аргуудыг дурьдсан буй. Боловсруулагдаагүй датаны огноо нь бүгд ижилхэн форматтай байх шаардлагатай ба ингэснээр цаашид зөв хэлбэрт хувиргагдах боломжтой ( "MM/DD/YYYY", эсвэл "DD MM YYYY" гэх мэт). Огноог Date төрөлд хувиргасны дараа зөв хувирсан эсэхийг заавал шалгах шаардлагатай.

### Бүлэглэсэн дата {.unnumbered}

Хэрэв таны дата *бүлэглэгдсэн* бол ( [Grouping data] хэсгийг хар), `mutate()` функц бүлэглэглэгдээгүй датанаас өөрөөр ханддаг. Статистикийн `mean()`, `median()`, `max()` зэрэг функцуудыг бүлгээр тооцоолон бодоход ашигладаг.

```{r, eval=F}
# насыг бүх мөрний дунджаар хуваах
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# насыг эмнэлэгт хэвтсэн бүлгийн дунджаар хуваах
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Бүлэглэсэн хүснэгт дээр `mutate ()` -г хэрхэн хэрэгдэх талаар [tidyverse mutate documentation](https://dplyr.tidyverse.org/reference/mutate.html) хэсгээс нэмж уншна уу.

### Олон баганыг хувиргах {#clean_across .unnumbered}

Кодын хэмжээг багасгах үүднээс олон баганыг зэрэг хувиргах хэрэг гардаг. Үүнийг **dplyr** багцын ( **tidyverse** багцуудын нэг) `across()`-оор хийдэг . `across()` -ыг **dplyr** -ын аль ч функцэд ажиллуулж болох ч `select()`, `mutate()`, `filter()`, `summarise()`функцын дотор илүү хэрэглэгддэг. [Descriptive tables] хэсгээс `summarise()` -тай хэрхэн хавсарч хэрэглэж болох талаар харна уу.

`across()`-ын`.cols =` аргументэд сонгосон багануудаа оруулаад, `.fns =` аргументэд гүйцэтгэх функцуудээ зааж өгнө. Хэрэв `.fns` -д оруулсан функцийн аргументийг мөн оруулах шаардлагатай бол таслал аваад `across()` хаалт дотроо нэмж оруулна.

#### `across()` багана сонгох {.unnumbered}

`.cols =` -д сонгосон багануудаа зааж өг. Баганыг нэг бүрчлэн нэрлэж оруул. Эсвэл "tidyselect" -ын туслах функцуудыг ашигла. Гүйцэтгэх функцээ`.fns =`-д зааж өг. Оруулсан функц **хаалтгүйгээр** бичигдсэн байгааг дор жишээн дээрээс анзаарна уу.

Энд `across()`дотор бичигдсэн багануудад `as.character()` хувигалт зэрэг хийхийг харуулав.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

"tidyselect" туслах функцуудээр баганын сонголтыг хялбарчилахад ашигладаг. Энэ функцуудын талаар багана сонгох, дэс дарааллах хэсэгт дэлгэрүүлж тайлбарласан. Үүнд : `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` `any_of()` орно.

Энд **бүх баганыг** хэрхэн зэрэг character төрөлд хувиргахыг харуулсан:

```{r, eval=F}
#бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Дор зөвхөн нэрэндээ "date" гэсэн үг агуулсан багануудыг character -руу хувиргахыг харуулав (таслал болон хаалтны байрлалыг ажигла):

```{r, eval=F}
#"date" -г нэрэндээ агуулсан бүх баганыг character болгож хувиргах
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Дор POSIXct хэлбэрт (цаг хугацааг харуулсан датаны боловсруулагдаагүй хэлбэрийн нэг) байсан багануудыг хувиргахыг харуулав. Өөрөөр хэлбэл `is.POSIXct()` функцээр багануудыг шалгаад`TRUE` хариу өгсөн багана болгоныг `as.Date()`-руу хувиргаж зөв Date хэлбэрт оруулах юм.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Дээр бичсэнээр `across()` доторх `where()` функцээр `is.POSIXct` функц үнэн (TRUE) эсвэл худал (FALSE) эсэхийг шалгаж буй юм.\
-   Энэхүү`is.POSIXct()` нь **lubridate** багцын функц. Бусад төстэй "is"-ээр эхэлдэг функцууд `is.character()`, `is.numeric()`, `is.logical()` нар **base R** багцад байдаг.

#### `across()` функцууд {.unnumbered}

`?across` -комманд уншуулж `across()`-ын хэвлэлийг гаргаж ирж функц оруулах талаар нэмж уншиж болно. Функцуудыг багануудад хэрэгжүүлэх хэд хэдэн арга буйг санаж байх хэрэгтэй. Та өөрийн функцыг бас үүсгэж болно:

-   Функцын нэрийг дангаар нь өгч болно (ж:`mean` эсвэл `as.character`)\

-   Функцыг **purrr**-багцын хэлбэрт оруулж болно (ж:`~ mean(.x, na.rm = TRUE)`) ( [this page][Iteration, loops, and lists]-ээс хар)\

-   Олон функцуудыг list -д жагсааж оруулж болно (ж: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Олон функц зэрэг оруулж буй үед , multiple transformed columns will be returned per input column, with unique names in the format `col_fn`. Шинээр үүсэх багануудын нэрийг **glue** синтаксыг ашиглан `.names =` аргументээр тохируулж болно ( [Characters and strings]-ээс нэмж хар) `{.col}` болон `{.fn}` are shorthand for the input column and function.

`across()`-ын талаарх нэмэлт онлайн эх сурвалжууд: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### `coalesce()` {.unnumbered}

Энэхүү **dplyr** багцын функц хамгийн эхний дутуу биш утгыг байрлал бүрт олж тогтоодог. Ингэснээр дутуу утгуудыг хамгийн эхний боломжит утгаар таны заасны дагуу "бөглөдөг".

Үүнийг *хүснэгтгүй* жишээнд харуулав: Таньд хоёр вектор байна гэж бодъё. Нэг нь өвчтөний оношлогдсон тосгон, нөгөө нь өвчтөний амьдардаг хот байв. Энэ үед coalesce-г ашиглаж эхний дутуу биш утгыг индекс бүрт олж болно:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

Хүснэгтийн баганууудад мөн адил үйлчилнэ: энэ функц шинэ баганын утгыг таны зааж өгсөн баганын эхний дутуу биш утганд мөр болгоноор оноож өгнө (дэс дараалалтайгаар).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Энд "мөр - дагуу" гүйцэтгэлийг харуулав. Илүү нарийн тооцооллыг мөр дагуу хэрхэн хийх талаар Мөр-дагуу тооцоолол хэсэгт харна уу.

### Cumulative математик {.unnumbered}

Хэрэв cumulative нийлбэр/дундаж/min/max зэргийг баганын мөр болгонд өмнөх мөрүүдтэй нь хамт тооцоолон оруулах бол дараах функцыг хэрэглэж болно:

`cumsum()` -аар cumulative нийлбэрийг олно :

```{r}
sum(c(2,4,15,10))     # зөвхөн нэг тоон утгыг л үр дүнд гаргана
cumsum(c(2,4,15,10))  # утга болгонд cumulative нийлбэрийг харуулна
```

Хүснэгтийн хувьд мөн адилхан. Өдрийн дэгдэлтийн үед өдрийн cumulative тохиолдлын тоог тооцохдоо дараах кодыг ашигла:

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # linelist-ээс эхэл
  count(date_onset) %>%                 # Өдар тутамдах мөрийг тоолох ('n')   
  mutate(cumulative_cases = cumsum(n))  # Мөр болгонд cumulative нийлбэрийг бодсон шинэ багана
```

Ингээд эхний 10 мөрийг харахад:

```{r}
head(cumulative_case_counts, 10)
```

[Epidemic curves] хэсгээс cumulative тохиолдлын тоогоор хэрхэн график хийх тухай буйг уншна уу.

Мөн дараах функцуудын талаах хар:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### **base** R -г ашиглах {.unnumbered}

**base** R-г хэрэглэж шинэ багана үүсгэх (эсвэл хуучин баганыг өөрчлөх) бол, дататай хүснэгтийнхээ нэрийг бичээд `$` тэмдгээр *шинэ* үүсгэх (эсвэл өөрчлөх) баганаа холбож өгнө. оноох операторыг ашиглаж `<-` шинэ утгаа оруулна. **base** R -г хэрэглэж буй үед дататай хүснэгтийнхээ нэрийг баганын өмнө заавал зааж өгөх хэрэгтэй гэдгийг санаарай (ж: `dataframe$column`). Энэ жишээнд `bmi` -г хэрхэн **base** R-р үүсгэх тухай харуулав:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Pipe холбоосонд залгах {.unnumbered}

**Дор жишээнд pipe холбоосонд шинэ мөр үүсгэх болон зарим баганын төрлийг хувиргах үйлдлүүд залгагдсан.**

```{r }
# ЦЭВЭРЛЭХ 'PIPE' ХОЛБООС (түүхий датаг цэвэрлэх үе шатуудаар дамжуулан цэвэрлэдэг холбоос) 
##################################################################################

# Цэвэрлэх холбоосыг эхлэх
###########################
linelist <- linelist_raw %>%
    
    # баганын нэрсийг жигдрүүлэх
    janitor::clean_names() %>% 
    
    # зарим баганын нэрийг гараар өөрчил
            # ШИНЭ нэр             # ХУУЧИН нэр
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # баганыг хас
    select(-c(row_num, merged_header, x28)) %>% 

    # давхардалтыг арилга
    distinct() %>% 
  
    # ЭНЭ ХҮРТЭЛХ ҮЙЛДЭЛ ӨМНӨХ ХЭСЭГТТЭЙ АДИЛ
    ###################################################
    # Шинэ багана нэм
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # баганын төрлийг хувирга
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Утга өөрчлөх

Утга өөрчлөх хэд хэдэн тохиолдлуудыг дор дурьдлаа:

-   тодорхой нэг утгыг янзлах (ж: нэг огнооны жил нь буруу эсвэл буруу форматтай орсон байх)\
-   өөр өөрөөр галиглагдаж бичигдсэн утгуудыг жигд болгох
-   ангилсан утгуудтай шинэ багана үүсгэх\
-   тоон ангилалтай шинэ багана нэмэх (ж: насны бүлэглэл)

### Өвөрмөц утгууд {.unnumbered}

Утгыг гараар өөрчлөхийн тулд `mutate()` функц дотор`recode()` функцыг оруулж бичнэ.

Жишээ нь дата дотор буруу бичигдсэн огноо байлаа гэж бодъё (ж: "2014-14-15"): боловсруулалт хийгдэхээс өмнө эх дата дээрээ шууд гараар янзалж болно. Эсвэл `mutate()` болон`recode()`-функцуудыг pipe холбоостоо залгаж өгч цэвэрлэж бас болно. Сүүлийн арга илүү нээлттэй, дахин боловсруулалт хийх боломжтой тул таны датаг ойлгож, дахин анализ хийх хүсэлтэй хүмүүст боломж олгодог.

```{r, eval=F}
# алдаатай утгыг засах                   # хуучин утга  # шинж утга
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Дээр бичигдсэн `mutate()` үйлдлийг дараах байдлаар уншна: "`date_onset` баганыг шинэчлэгдсэн `date_onset` тай тэнцүү бичих ба ингэснээр ХУУЧИН УТГА нь ШИНЭ УТГА-аар солигдно". `recode()` функцын энэ дараалал (ХУУЧИН = ШИНЭ) R -ын ихэнх функцуудэд эсрэгээрээ бичигддэг (шинэ = хуучин). R хөгжлийн нийгэмлэг үүнийг сайжруулахаар ажиллаж буй юм.

**Нэг багана доторх хэд хэдэн утгыг зэрэг өөрчлөх өөр нэгэн жишээ энд харуулав.**

`linelist` -ын "hospital" баганыг цэвэрлэх шаардлагатай боллоо. Учир нь хэд хэдэн газар алдаатай бичигдэж, дутуу утгууд олон орсон байна.

```{r}
table(linelist$hospital, useNA = "always")  # дутуу утгуудыг оролцуулан бүх өвөрмөц утгуудыг хэвлэ  
```

Энэ`recode()` коммандад "hospital" баганыг тухайн "hospital" багана хэвээр боловч дотор нь тодорхой өөрчлөлтүүд оруулахыг зааж өгсөн байна. Тус бүр ардаа таслалтаа байгааг анхаар!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # лавлагаа: ХУУЧИН = ШИНЭ
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Одоо `hospital` баганын галиглал хэрхэн засагдаж жигдэрсэн байгааг хар:

```{r}
table(linelist$hospital, useNA = "always")
```

[***ЗӨВЛӨГӨӨ:*** тэнцүүгийн тэмдгийн ард урд хэр их зай авах нь хамаагүй. Гэвч бичсэн кодоо уншихад хялбар байх үүднээс = тэмдгийг мөр болгонд тэгшхэн тааруулж бичвэл зохимжтой. Мөн хүмүүст уншихад ойлгомжтой болгох үүднээс "хэш" тэмдэгтэй тэмдэглэлээр аль нь хуучин, аль нь шинэ утга болохыг тэмдэглэж болно.]{style="color: darkgreen;"}

[***ЗӨВЛӨГӨӨ:*** заримдаа *хоосон* утга датад орж ирсэн байдаг ( R-ын дутуу утга буюу `NA` болж танигдаагүй). Үүнийг давхар хашилтын тэмдгийн дотор зай авалгүйгээр бичснэрээ энэ хоосон утгыг зааж өгдөг ("").]{style="color: darkgreen;"}

### Логик үйлдлүүд {.unnumbered}

Дор logic болон нөхцөл (conditions) ашиглаж хэрхэн баганын утгыг өөрчлөхийг харуулав:

-   `replace()`, `ifelse()` болон `if_else()` зэргийг энгийн логик үйлдлүүдэд хэрэглэдэг
-   `case_when()` -ийг арай нарийн логик үйлдэлд хэрэглэнэ for more complex logic

### Энгийн логик үйлдэл {.unnumbered}

#### `replace()` {.unnumbered}

Энгийн логик шалгуурыг үүсгэхдээ `mutate()` дотор `replace()` -ийг бичдэг. `replace()` нь **base** R-ын функц. Логик нөхцөл ашиглан өөрчлөх мөрөө зааж өгнө. Синтаксын ерөнхий фрмат:

`mutate(col_to_change = replace(col_to_change, мөрний шалгуур үзүүлэлт, шинэ утга))`.

`replace()` -ийн өөр нэгэн нийтлэг хэрэглээ бол **өвөрмөц дугаараар нь зөвхөн нэг мөрний нэг утгыг нь өөрчлөх** юм. Дор жишээнд `case_id` баганын 2195 гэсэн мөрний хүйсийг "Female" болгож өөрчилсөн.

```{r, eval=F}
# Жишээ: тодорхой нэг ширхэг ажиглалтыг "Female" болгож өөрчлөх
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

Үүнтэй ижил үйлдлийг **base** R -ын индекс дөрвөлжин хаалт `[ ]` гүйцэтгэдэг (дор жишээнд харуулав). Доор кодыг дараах байдлаар уншина: "`linelist` хүснэгтийн `gender` баганыг (`case_id` баганадаа '2195' гэсэн утгатай `linelist`) 'Female' болго ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` болон `if_else()` {.unnumbered}

Өөр нэгэн энгийн логик үйлдлүүдэд `ifelse()` болон `if_else()` орно. Гэхдээ ихэнх утга өөрчлөх үйлдлүүдэд `case_when()` -ийг хэрэглэх нь илүү ойлгомжтой байдаг (дэлгэрэнгүйг доор бичсэн). Эдгээр "if else" коммандууд нь `if` болон `else` программчлалын хялбаршуулсан хэлбэр юм. Синтаксын ерөнхий формат:\
`ifelse(нөхцөл, хэрэв нөхцөл TRUE бол дуудах утга, нөхцөл FALSE бол дуудах утга)`

Дор `source_known` баганыг тодорхойлсон байна. Хэрэв `source` баганын аль нэг мөрний утга дутуу утга *биш* бол тухайн мөрний `source_known` баганадах утга "known" гэж бичигднэ. Хэрэв `source` -ын утга дутуу утга *мөн* бол тухайн мөрний `source_known` баганадах утга "unknown" гэж бичигднэ.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()` нь **dplyr** багцын голчлон огноог янзалдаг тусгай функц юм. Хэрэв 'жинхэнэ' утга нь огноо бол 'худал' утга нь мөн адил огноо гэж үзэгдэх тул ердийн `NA`-ын оронд тусгай `NA_real_` хэрэглэнэ.

```{r, eval=F}
# Нас барсан өдрийн баганыг үүсгэ. Өвчтөн нас бараагүй бол `NA`-аар бич.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**олон зэрэг ifelse -ийг бичихэээс зайлсхий. Оронд нь `case_when()` -ийг хэрэглэ!** `case_when()` -хялбар уншигддаг ба алдаа гаргах нь цөөн.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

код бичихэд хэрэглэдэг обьектийг хүснэгтээс гадуур байлгахыг хүсвэл object used in your code switch its value, consider using `switch()` from **base** R.{style="color: red;"}

### Нарийн логик үйлдлүүд {#clean_case_when .unnumbered}

Хэрэв олон бүлэгт өөрчлөлт оруулах, аливаа утгыг өөрчлөхөд нарийн төвөгтэй логик үйлдлүүд хийх шаардлагтай бол **dplyr** багцын `case_when()` -ыг хэрэглэ. Хүснэгтийн мөр болгоныг шалгаад, тодорхой шалгуурыг хангах эсэхийг үнэлсний дараа зөв утгыг оруулж өгдөг.

`case_when()` комманд нв Баруун-Тал/Right-Hand Side (RHS) болон Зүүн-Тал/Left-Hand Side (LHS) -ын бичиглэлүүдтэй ба "тилда" `~` тэмдэгээр хуваагддаг. Логик шалгуурууд нь зүүн талд нийцүүлсэн утгууд нь баруун талдаа бичигдэх ба өгөгдөл тус бүр таслал байна.

Жишээ нь, `age` болон `age_unit` баганыг ашиглаж `age_years` баганыг үүсгэсэн:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # хэрэв нас жилээр өгөгдсөн бол
            age_unit == "months" ~ age/12,    # хэрэв нас сараар өгөгдсөн бол
            is.na(age_unit)      ~ age,       # хэрэв нас баганад дутуу утга байвал (нас жилээр өгөгдсөн)
            TRUE                 ~ NA_real_)) # бусад бүх тохиолдолд дутуу утгаар авна
```

As each row in the data is evaluated, the criteria are applied/evaluated in the order the `case_when()` statements are written - from top-to-bottom. If the top criteria evaluates to `TRUE` for a given row, the RHS value is assigned, and the remaining criteria are not even tested for that row. Thus, it is best to write the most specific criteria first, and the most general last.

Along those lines, in your final statement, place `TRUE` on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like "check me!" or missing.

[***DANGER:*** **Vvalues on the right-side must all be the same class** - either numeric, character, date, logical, etc. To assign missing (`NA`), you may need to use special variations of `NA` such as `NA_character_`, `NA_real_` (for numeric or POSIX), and `as.Date(NA)`. Read more in [Working with dates].]{style="color: red;"}

### Missing values {.unnumbered}

Below are special functions for handling missing values in the context of data cleaning.

See the page on [Missing data] for more detailed tips on identifying and handling missing values. For example, the `is.na()` function which logically tests for missingness.

**`replace_na()`**

To change missing values (`NA`) to a specific value, such as "Missing", use the **dplyr** function `replace_na()` within `mutate()`. Note that this is used in the same manner as `recode` above - the name of the variable must be repeated within `replace_na()`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

This is a function from the **forcats** package. The **forcats** package handles columns of class Factor. Factors are R's way to handle *ordered* values such as `c("First", "Second", "Third")` or to set the order that values (e.g. hospitals) appear in tables and plots. See the page on [Factors].

If your data are class Factor and you try to convert `NA` to "Missing" by using `replace_na()`, you will get this error: `invalid factor level, NA generated`. You have tried to add "Missing" as a value, when it was not defined as a possible level of the factor, and it was rejected.

The easiest way to solve this is to use the **forcats** function `fct_explicit_na()` which converts a column to class factor, and converts `NA` values to the character "(Missing)".

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

A slower alternative would be to add the factor level using `fct_expand()` and then convert the missing values.

**`na_if()`**

To convert a *specific value to* `NA`, use **dplyr**'s `na_if()`. The command below performs the opposite operation of `replace_na()`. In the example below, any values of "Missing" in the column `hospital` are converted to `NA`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Note: `na_if()` **cannot be used for logic criteria** (e.g. "all values \> 99") - use `replace()` or `case_when()` for this:

```{r, eval=F}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Cleaning dictionary {.unnumbered}

Use the R package **linelist** and it's function `clean_variable_spelling()` to clean a data frame with a *cleaning dictionary*. **linelist** is a package developed by [RECON](https://github.com/reconhub/linelist) - the R Epidemics Consortium.

1)  Create a cleaning dictionary with 3 columns:

    -   A "from" column (the incorrect value)\
    -   A "to" column (the correct value)\
    -   A column specifying the column for the changes to be applied (or ".global" to apply to all columns)

Note: .global dictionary entries will be overridden by column-specific dictionary entries.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Import the dictionary file into R. This example can be downloaded via instructions on the [Download handbook and data] page.

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Pass the raw linelist to `clean_variable_spelling()`, specifying to `wordlists =` the cleaning dictionary data frame. The `spelling_vars =` argument can be used to specify which column in the dictionary refers to the columns (3rd by default), or can be set to `NULL` to have the dictionary apply to all character and factor columns. Note this function can take a long time to run.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # dict column containing column names, defaults to 3rd column in dict
  )
```

Now scroll to the right to see how values have changed - particularly `gender` (lowercase to uppercase), and all the symptoms columns have been transformed from yes/no to 1/0.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Note that your column names in the cleaning dictionary must correspond to the names *at this point* in your cleaning script. See this [online reference for the linelist package](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) for more details.

#### Add to pipe chain {.unnumbered}

**Below, some new columns and column transformations are added to the pipe chain.**

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
   ###################################################

    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Numeric categories {#num_cats}

Here we describe some special approaches for creating categories from numerical columns. Common examples include age categories, groups of lab values, etc. Here we will discuss:

-   `age_categories()`, from the **epikit** package\
-   `cut()`, from **base** R\
-   `case_when()`\
-   quantile breaks with `quantile()` and `ntile()`

### Review distribution {.unnumbered}

For this example we will create an `age_cat` column using the `age_years` column.

```{r}
#check the class of the linelist variable age
class(linelist$age_years)
```

First, examine the distribution of your data, to make appropriate cut-points. See the page on [ggplot basics].

```{r, out.height='50%'}
# examine the distribution
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***CAUTION:*** Sometimes, numeric variables will import as class "character". This occurs if there are non-numeric characters in some of the values, for example an entry of "2 months" for age, or (depending on your R locale settings) if a comma is used in the decimals place (e.g. "4,5" to mean four and one half years)..]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

With the **epikit** package, you can use the `age_categories()` function to easily categorize and label numeric columns (note: this function can be applied to non-age numeric variables too). As a bonum, the output column is automatically an ordered factor.

Here are the required inputs:

-   A numeric vector (column)\
-   The `breakers =` argument - provide a numeric vector of break points for the new groups

First, the simplest example:

```{r}
# Simple example
################
pacman::p_load(epikit)                    # load package

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# show table
table(linelist$age_cat, useNA = "always")
```

The break values you specify are by default the lower bounds - that is, they are included in the "higher" group / the groups are "open" on the lower/left side. As shown below, you can add 1 to each break value to achieve groups that are open at the top/right.

```{r}
# Include upper ends for the same categories
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# show table
table(linelist$age_cat, useNA = "always")
```

You can adjust how the labels are displayed with `separator =`. The default is "-"

You can adjust how the top numbers are handled, with the `ceiling =` arguemnt. To set an upper cut-off set `ceiling = TRUE`. In this use, the highest break value provided is a "ceiling" and a category "XX+" is not created. Any values above highest break value (or to `upper =`, if defined) are categorized as `NA`. Below is an example with `ceiling = TRUE`, so that there is no category of XX+ and values above 70 (the highest break value) are assigned as NA.

```{r}
# With ceiling set to TRUE
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# show table
table(linelist$age_cat, useNA = "always")
```

Alternatively, instead of `breakers =`, you can provide all of `lower =`, `upper =`, and `by =`:

-   `lower =` The lowest number you want considered - default is 0\
-   `upper =` The highest number you want considered\
-   `by =` The number of years between groups

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# show table
table(linelist$age_cat, useNA = "always")
```

See the function's Help page for more details (enter `?age_categories` in the R console).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

`cut()` is a **base** R alternative to `age_categories()`, but I think you will see why `age_categories()` was developed to simplify this process. Some notable differences from `age_categories()` are:

-   You do not need to install/load another package\
-   You can specify whether groups are open/closed on the right/left\
-   You must provide accurate labels yourself\
-   If you want 0 included in the lowest group you must specify this

The basic syntax within `cut()` is to first provide the numeric column to be cut (`age_years`), and then the *breaks* argument, which is a numeric vector `c()` of break points. Using `cut()`, the resulting column is an ordered factor.

By default, the categorization occurs so that the right/upper side is "open" and inclusive (and the left/lower side is "closed" or exclusive). This is the opposite behavior from the `age_categories()` function. The default labels use the notation "(A, B]", which means A is not included but B is. **Reverse this behavior by providing the `right = TRUE` argument**.

Thus, by default, "0" values are excluded from the lowest group, and categorized as `NA`! "0" values could be infants coded as age 0 so be careful! To change this, add the argument `include.lowest = TRUE` so that any "0" values will be included in the lowest group. The automatically-generated label for the lowest category will then be "[A],B]". Note that if you include the `include.lowest = TRUE` argument **and** `right = TRUE`, the extreme inclusion will now apply to the *highest* break point value and category, not the lowest.

You can provide a vector of customized labels using the `labels =` argument. As these are manually written, be very careful to ensure they are accurate! Check your work using cross-tabulation, as described below.

An example of `cut()` applied to `age_years` to make the new variable `age_cat` is below:

```{r}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**Check your work!!!** Verify that each age value was assigned to the correct category by cross-tabulating the numeric and category columns. Examine assignment of boundary values (e.g. 15, if neighboring categories are 10-15 and 16-20).

```{r}
# Cross tabulation of the numeric and category columns. 
table("Numeric Values" = linelist$age_years,   # names specified in table for clarity.
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # don't forget to examine NA values
```

**Re-labeling `NA` values**

You may want to assign `NA` values a label such as "Missing". Because the new column is class Factor (restricted values), you cannot simply mutate it with `replace_na()`, as this value will be rejected. Instead, use `fct_explicit_na()` from **forcats** as explained in the [Factors] page.

```{r}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

**Quickly make breaks and labels**

For a fast way to make breaks and label vectors, use something like below. See the [R basics] page for references on `seq()` and `rep()`.

```{r, eval=F}
# Make break points from 0 to 90 by 5
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Make labels for the above categories, assuming default cut() settings
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# check that both vectors are the same length
length(age_seq) == length(age_labels)
```

Read more about `cut()` in its Help page by entering `?cut` in the R console.

### Quantile breaks {.unnumbered}

In common understanding, "quantiles" or "percentiles" typically refer to a value below which a proportion of values fall. For example, the 95th percentile of ages in `linelist` would be the age below which 95% of the age fall.

However in common speech, "quartiles" and "deciles" can also refer to the *groups of data* as equally divided into 4, or 10 groups (note there will be one more break point than group).

To get quantile break points, you can use `quantile()` from the **stats** package from **base** R. You provide a numeric vector (e.g. a column in a dataset) and vector of numeric probability values ranging from 0 to 1.0. The break points are returned as a numeric vector. Explore the details of the statistical methodologies by entering `?quantile`.

-   If your input numeric vector has any missing values it is best to set `na.rm = TRUE`\
-   Set `names = FALSE` to get an un-named numeric vector

```{r}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

You can use the results of `quantile()` as break points in `age_categories()` or `cut()`. Below we create a new column `deciles` using `cut()` where the breaks are defined using `quantiles()` on `age_years`. Below, we display the results using `tabyl()` from **janitor** so you can see the percentages (see the [Descriptive tables] page). Note how they are not exactly 10% in each group.

```{r}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

### Evenly-sized groups {.unnumbered}

Another tool to make numeric groups is the the **dplyr** function `ntile()`, which attempts to break your data into n *evenly-sized groups* - *but be aware that unlike with `quantile()` the same value could appear in more than one group.* Provide the numeric vector and then the number of groups. The values in the new column created is just group "numbers" (e.g. 1 to 10), not the range of values themselves as when using `cut()`.

```{r}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

It is possible to use the **dplyr** function `case_when()` to create categories from a numeric column, but it is easier to use `age_categories()` from **epikit** or `cut()` because these will create an ordered factor automatically.

If using `case_when()`, please review the proper use as described earlier in the Re-code values section of this page. Also be aware that all right-hand side values must be of the same class. Thus, if you want `NA` on the right-side you should either write "Missing" or use the special `NA` value `NA_character_`.

### Add to pipe chain {.unnumbered}

Below, code to create two categorical age columns is added to the cleaning pipe chain:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################   
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Add rows

### One-by-one {.unnumbered}

Adding rows one-by-one manually is tedious but can be done with `add_row()` from **dplyr**. Remember that each column must contain values of only one class (either character, numeric, logical, etc.). So adding a row requires nuance to maintain this.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

Use `.before` and `.after.` to specify the placement of the row you want to add. `.before = 3` will put the new row before the current 3rd row. The default behavior is to add the row to the end. Columns not specified will be left empty (`NA`).

The new *row number* may look strange ("...23") but the row numbers in the pre-existing rows *have* changed. So if using the command twice, examine/test the insertion carefully.

If a class you provide is off you will see an error like this:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(when inserting a row with a date value, remember to wrap the date in the function `as.Date()` like `as.Date("2020-10-10")`).

### Bind rows {.unnumbered}

To combine datasets together by binding the rows of one dataframe to the bottom of another data frame, you can use `bind_rows()` from **dplyr**. This is explained in more detail in the page [Joining data].

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Filter rows

A typical cleaning step after you have cleaned the columns and re-coded values is to *filter* the data frame for specific rows using the **dplyr** verb `filter()`.

Within `filter()`, specify the logic that must be `TRUE` for a row in the dataset to be kept. Below we show how to filter rows based on simple and complex logical conditions.

<!-- ======================================================= -->

### Simple filter {.unnumbered}

This simple example re-defines the dataframe `linelist` as itself, having filtered the rows to meet a logical condition. **Only the rows where the logical statement within the parentheses evaluates to `TRUE` are kept.**

In this example, the logical statement is `gender == "f"`, which is asking whether the value in the column `gender` is equal to "f" (case sensitive).

Before the filter is applied, the number of rows in `linelist` is `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # keep only rows where gender is equal to "f"
```

After the filter is applied, the number of rows in `linelist` is `linelist %>% filter(gender == "f") %>% nrow()`.

### Filter out missing values {.unnumbered}

It is fairly common to want to filter out rows that have missing values. Resist the urge to write `filter(!is.na(column) & !is.na(column))` and instead use the **tidyr** function that is custom-built for this purpose: `drop_na()`. If run with empty parentheses, it removes rows with *any* missing values. Alternatively, you can provide names of specific columns to be evaluated for missingness, or use the "tidyselect" helper functions described [above](#clean_tidyselect).

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

See the page on [Missing data] for many techniques to analyse and manage missingness in your data.

### Filter by row number {.unnumbered}

In a data frame or tibble, each row will usually have a "row number" that (when seen in R Viewer) appears to the left of the first column. It is not itself a true column in the data, but it can be used in a `filter()` statement.

To filter based on "row number", you can use the **dplyr** function `row_number()` with open parentheses as part of a logical filtering statement. Often you will use the `%in%` operator and a range of numbers as part of that logical statement, as shown below. To see the *first* N rows, you can also use the special **dplyr** function `head()`.

```{r, eval=F}
# View first 100 rows
linelist %>% head(100)     # or use tail() to see the n last rows

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

You can also convert the row numbers to a true column by piping your data frame to the **tibble** function `rownames_to_column()` (do not put anything in the parentheses).

<!-- ======================================================= -->

### Complex filter {.unnumbered}

More complex logical statements can be constructed using parentheses `( )`, OR `|`, negate `!`, `%in%`, and AND `&` operators. An example is below:

Note: You can use the `!` operator in front of a logical criteria to negate it. For example, `!is.na(column)` evaluates to true if the column value is *not* missing. Likewise `!column %in% c("a", "b", "c")` evaluates to true if the column value is *not* in the vector.

#### Examine the data {.unnumbered}

Below is a simple one-line command to create a histogram of onset dates. See that a second smaller outbreak from 2012-2013 is also included in this raw dataset. **For our analyses, we want to remove entries from this earlier outbreak.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### How filters handle missing numeric and date values {.unnumbered}

Can we just filter by `date_onset` to rows after June 2013? **Caution! Applying the code `filter(date_onset > as.Date("2013-06-01")))` would remove any rows in the later epidemic with a missing date of onset!**

[***DANGER:*** Filtering to greater than (\>) or less than (\<) a date or number can remove any rows with missing values (`NA`)! This is because `NA` is treated as infinitely large and small.]{style="color: red;"}

*(See the page on [Working with dates] for more information on working with dates and the package **lubridate**)*

#### Design the filter {.unnumbered}

Examine a cross-tabulation to make sure we exclude only the correct rows:

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

What other criteria can we filter on to remove the first outbreak (in 2012 & 2013) from the dataset? We see that:

-   The first epidemic in 2012 & 2013 occurred at Hospital A, Hospital B, and that there were also 10 cases at Port Hospital.\
-   Hospitals A & B did *not* have cases in the second epidemic, but Port Hospital did.

We want to exclude:

-   The `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` rows with onset in 2012 and 2013 at either hospital A, B, or Port:

    -   Exclude `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))` rows with onset in 2012 and 2013
    -   Exclude `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` rows from Hospitals A & B with missing onset dates\
    -   Do **not** exclude `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` other rows with missing onset dates.

We start with a linelist of nrow(linelist)\`. Here is our filter statement:

```{r}
linelist <- linelist %>% 
  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

When we re-make the cross-tabulation, we see that Hospitals A & B are removed completely, and the 10 Port Hospital cases from 2012 & 2013 are removed, and all other values are the same - just as we wanted.

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Multiple statements can be included within one filter command (separated by commas), or you can always pipe to a separate filter() command for clarity.

*Note: some readers may notice that it would be easier to just filter by `date_hospitalisation` because it is 100% complete with no missing values. This is true. But `date_onset` is used for purposes of demonstrating a complex filter.*

### Standalone {.unnumbered}

Filtering can also be done as a stand-alone command (not part of a pipe chain). Like other **dplyr** verbs, in this case the first argument must be the dataset itself.

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

You can also use **base** R to subset using square brackets which reflect the [rows, columns] that you want to retain.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Quickly review records {.unnumbered}

Often you want to quickly review a few records, for only a few columns. The **base** R function `View()` will print a data frame for viewing in your RStudio.

View the linelist in RStudio:

```{r, eval=F}
View(linelist)
```

Here are two examples of viewing specific cells (specific rows, and specific columns):

**With dplyr functions `filter()` and `select()`:**

Within `View()`, pipe the dataset to `filter()` to keep certain rows, and then to `select()` to keep certain columns. For example, to review onset and hospitalization dates of 3 specific cases:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

You can achieve the same with **base** R syntax, using brackets `[ ]` to subset you want to see.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Add to pipe chain {.unnumbered}

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    filter(
          # keep only rows where case_id is not missing
          !is.na(case_id),  
          
          # also filter to keep only the second outbreak
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Row-wise calculations

If you want to perform a calculation within a row, you can use `rowwise()` from **dplyr**. See this online vignette on [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html).\
For example, this code applies `rowwise()` and then creates a new column that sums the number of the specified symptom columns that have value "yes", for each row in the linelist. The columns are specified within `sum()` by name within a vector `c()`. `rowwise()` is essentially a special kind of `group_by()`, so it is best to use `ungroup()` when you are done (page on [Grouping data]).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display
```

As you specify the column to evaluate, you may want to use the "tidyselect" helper functions described in the `select()` section of this page. You just have to make one adjustment (because you are not using them within a **dplyr** function like `select()` or `summarise()`).

Put the column-specification criteria within the **dplyr** function `c_across()`. This is because `c_across` ([documentation](https://dplyr.tidyverse.org/reference/c_across.html)) is designed to work with `rowwise()` specifically. For example, the following code:

-   Applies `rowwise()` so the following operation (`sum()`) is applied within each row (not summing entire columns)\
-   Creates new column `num_NA_dates`, defined for each row as the number of columns (with name containing "date") for which `is.na()` evaluated to TRUE (they are missing data).\
-   `ungroup()` to remove the effects of `rowwise()` for subsequent steps

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

You could also provide other functions, such as `max()` to get the latest or most recent date for each row:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## Arrange and sort

Use the **dplyr** function `arrange()` to sort or order the rows by column values.

Simple list the columns in the order they should be sorted on. Specify `.by_group = TRUE` if you want the sorting to to first occur by any *groupings* applied to the data (see page on [Grouping data]).

By default, column will be sorted in "ascending" order (which applies to numeric and also to character columns). You can sort a variable in "descending" order by wrapping it with `desc()`.

Sorting data with `arrange()` is particularly useful when making [Tables for presentation], using `slice()` to take the "top" rows per group, or setting factor level order by order of appearance.

For example, to sort the our linelist rows by `hospital`, then by `date_onset` in descending order, we would use:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# HIDDEN
#
# convert one remaining old outbreak row to missing for ease
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# REARRANGE COLUMNS FOR EXPORT
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# EXPORT CLEANED LINELIST FILE TO "DATA" FOLDER
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"), overwrite = TRUE)
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
