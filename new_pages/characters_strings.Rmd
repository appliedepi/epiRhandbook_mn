# Карактер ба стрингс

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```

Энэхүү хэсэгт карактер болон стрингс утгыг (залгаа карактерүүд) **stringr** багц ашиглаж шалгаж, янзлах талаар үзэх болно ("strings").

1.  Нэгтгэх, эрэмбэлэх,хуваах, дараалал солих - `str_c()`, `str_glue()`, `str_order()`, `str_split()`\

2.  Цэвэрлэх болон жигдрүүлэх

    -   Уртыг тохируул - `str_pad()`, `str_trunc()`, `str_wrap()`\
    -   Үсэгний том жижигийг өөрчлөх - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`\

3.  Байрлалыг тогтоож, орлуулах - `str_length()`, `str_sub()`, `word()`\

4.  Бүтэц, хэв маяг

    -   Илрүүлж, байрлалыг олох - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`\
    -   Хувиргаж, солих - `str_sub()`, `str_replace_all()`\

5.  Regular expressions ("regex")

Тайлбарлахад хялбар болгохын тулд ихэнх жишээг карактерийн богино векторууд дээр харуулсан. Гэсэн хэдий ч эдгээр жишээг хүснэгт, баганад дээр хэрэгжүүлэх боломжтой юм.

Энэхүү хэсгийг боловсруулахад [stringr vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) дэх материалаас их ашигласан.

<!-- ======================================================= -->

## Бэлтгэл

### Багцыг ачааллах {.unnumbered}

**stringr** болон бусад **tidyverse** багцыг татаж авч, ачааллана.

```{r}
# Багцыг татаж ав/ачаалла
pacman::p_load(
  stringr,    # стрингс дээр ажиллах функцуудын иж бүрдэл
  tidyverse,  # дата янзлахад хэрэгтэй
  tools)      # гарчигийг хувиргахад хэрэглэнэ

```

### Дата импортлох {.unnumbered}

Энэ хэсгийн дасгалд Эболагийн дэгдэлтийг загварчилсан дата `linelist` -ын цэвэрлэгдсэн хэлбэрийг ашиглах болно. Дасгалуудыг дагаж хийхийг хүсвэл <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>линк дээр дарж, "clean" гэсэн linelist дээр дарж татаж авна уу</a> (.rds файл хэлбэрээр буй). Датаг импортлохдоо **rio** багцын `import()` функцыг хэрэглэ ( .xlsx, .csv, .rds зэрэг олон өргөтгөлтэй ажиллаж чаддаг - [Import and export] хэсгээс нэмж уншна уу).

```{r, echo=F}
# linelist -ийг R - луу оруул
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# case linelist -ийг импортло
linelist <- import("linelist_cleaned.rds")
```

linelist -ийн эхний 50 мөрийг дор харуулав.

```{r, message=FALSE, echo=F}
# linelist -ийг хүснэгт хэлбэрээр харуул
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Нэгтгэх, хуваах, эрэмбэлэх

Энэхүү хэсгийн агуулга:

-   `str_c()`, `str_glue()`, `unite()` -аар стрингсийг нэгтгэх\
-   `str_order()` стрингсийг эрэмбэлэн байрлуулах\
-   `str_split()`, `separate()` стрингсийг хуваах

<!-- ======================================================= -->

### Стрингсийг нэгтгэх {.unnumbered}

Олон стрингсийг нэгтгэж, залгахдаа **stringr** -ийн `str_c` -ийг ашиглахыг зөвлөж байна. Хэрэв таны нэтгэх гэж буй карактерууд салангид утгууд бол тусдаа аргументууд болгон оруулж таслалаар зааглаж өгнө.

```{r}
str_c("String1", "String2", "String3")
```

Оруулж буй аргументуудын дунд зааглах тэмдэгтийг `sep =` ээр тохиуруулж болно (таслал, зай, шинэ мөр `"\n"` гэх мэт)

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

`str_c()` -д олон *вектор* аргумент оруулах үед `collapse =` аргумент хэрэг болнд. Ингэснээр үүсэх векторууд хоорондоо зааглагдсан нэг урт элемент болно.

Доорхи жишээ хоёр векторыг (овог, нэр) хэрхэн нэг болгож нэгтгэхийг харуулсан. Мөн нутаг дэвсгэрийн нэр болон тохиолдлын тоог энэ мэтээр нэгтгэж бас болно. Жишээнд:

-   `sep =` тэмдэгт нэр, овог болгоны дунд гарч ирнэ\
-   `collapse =` тэмдэгт хүн тус бүрийн дунд гарч ирнэ

```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# оруулсан аргумент болгоны дунд sep -ийн тэмдэг гарч ирж, элементү болгоны дунд collapse -ын тэмдэгт гарч ирж байна
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Тэмдэглэл: Хэрэв дээрхи шиг стрингсүүд хавсарч, шинэ мөр үүсгэн харуулах бол өгүүлбэрээ бүтнээр нь `cat()` хийснээр зөв хэвлэгдэж харагдна.

```{r}
# шинэ мөрөнд зөв хэвлэхийн тулд өгүүлбэрээ бүтнээр нь cat()-д хийнэ үү
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```

<!-- ======================================================= -->

### Динамик стрингс {.unnumbered}

Стрингст динамик R код оруулах тохиолдолд `str_glue()` -ийг хэрэглэдэг. Графикт динамик тайлбар хийхэд энэ функцыг ашиглах нь их тохиромжтой. Үүнийг дор харуулав:

-   Доторх бүх агуулга нь давхар хашилтад бичигднэ `str_glue("")`\
-   Аливаа динамик код эсвэл урьдчилан тодорхойлсон утгуудыг `{}` хээтэй хаалтын доторх давхар хашилтын дотор байрлуулна. Нэг `str_glue()` коммандад олон хээтэй хаалт `{}` хийж болно.\
-   Хашилт '' -ыг тэмдэгтэн утганд оруулж харуулахын тулд *дан* хашилтыг давхар хашилтанд дотор оруулж бичнэ (жишээ болгож огноог хэрхэн бичихийг дор харуулсан)\
-   Зөвлөгөө: `\n` шинэ мөр эхлүүлдэг болно\
-   Зөвлөгөө: огнооны харагдах байдлыг `format()` -аар тохируулж, `Sys.Date()` -аар одоогийн огноог харуулдаг.

Графикт динамик тайлбар хийх жишээ:

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Мөн `str_glue()` -дотор стрингс дундаа хээтэй хаалтан дотор орлуулагч оруулаад, кодыг нь тусдаа `str_glue()` аргумент байдлаар араас нь бичиж болно (доор жишээнд харуулсан). Ингэж бичих нь урт текстийг уншихад ойлгомжтой болгож өгдөг.

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```

**Дата хүснэгтээс гаргаж авах**

Заримдаа хүснэгт доторх датаг гаргаад дарааллуулан өрж тавих шаардлага гардаг. Нутаг дэвсгэр, шинэ тохиолдол, нийт тохиолдлын талаарх мэдэгдллийг хүснэгтээс хэрхэн гаргаж авах талаар жишээг дор харуулав.

```{r}
# тохиолдолдтой хүснэгт үүсгэ
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Хүснэгтийн мөрөнд буй датаг `str_glue_data()` -аар гаргаж авдаг.

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```

**Стрингсийг мөр дагуулж нэгтгэх**

Хүснэгтийн багана дах утгыг "хуйлах" буюу олон мөрүүдийг нэгтгэж нэг мөрд багтаагаад доторх утгыг нь тусгаарлагчаар тусгаарлах шаардлагатай бол ["rolling-up" values](#str_rollup) хуудасны [De-duplication] хэсгийг уншна уу.

**Хүснэгтийг нэг шугаманд багтаах**

Үүсгэсэн текстээ `str_c()` -ээр нэг шугаманд багтаахдаа (хүснэгт, баганын нэрсийг зааж өгнө) `sep =` болон `collapse =` аргументийг нэмж тохируулна.

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

pre-fix -ээр "Шинэ Тохиролдол:" гэсэн үгийг текстийнхээ өмнө автоматаар гардаг болгож болно. Ингэхдээ `str_c()` функц дотор оруулж бичнэ ("Шинэ Тохиолдол:" анхны `str_c()` дотор оруулчихвад олон дахин бичигдчихдэг.

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```

### Баганыг нэтгэх {#str_unite .unnumbered}

Багануудын карактер утгыг **tidyr**-ын `unite()` функцээр нэгтгэдэг. Энэ нь `separate()` функцын эсрэг үйлдэл.

Шинээр үүсгэх баганын нэрийг оруулаад, нэтгэх багануудын нэрийг оруулна.

-   Нэтгэсэн багана дах утгын default тусгаарлагч нь доогуур зураас `_`. Үүнийг `sep =` аргументэд тохируулга өгснөөр өөрчилж болно.\
-   `remove =` Хүснэгтээс нэгтгэлд оруулсан багануудыг хасна (default -аар TRUE)\
-   `na.rm =` нэтгэж байх явцдаа дутуу утгыг хасна (default -аар FALSE)

Эдгээрийг богино жишээгээр тайлбарлав:

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # 1-р өвчтөн
                "chills, aches, pains",        # 2-р өвчтөн
                "fever",                       # 3-р өвчтөн
                "vomiting, diarrhoea",         # 4-р өвчтөн
                "bleeding from gums, fever",   # 5-р өвчтөн
                "rapid pulse, headache"),      # 6-р өвчтөн
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```

```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Жишээ хүснэгт:

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Доор жишээнд шинж тэмдэг бичсэн гурван баганыг нэгтгэв:

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # Шинээр нэгтгэж үүсгэх баганын нэр
    c("sym_1", "sym_2", "sym_3"), # Нэтгэх баганууд
    sep = ", ",                   # Нэтгэсэн баганад хэрэглэх тусгаарлагч
    remove = TRUE,                # TRUE гэж өгснөөр нэгтгэлд оруулсан багануудыг хүснэгтээс хасах
    na.rm = TRUE                  # TRUE гэж өгснөөр нэтгэх явцад дутуу утгууд хасагдна
  )
```

<!-- ======================================================= -->

### Хуваах {.unnumbered}

Ямар нэг хэв шинжид үндэслэн стрингсийг хуваах бол `str_split()`-ийг хэрэглэдэг. Энэ функц стрингсийг заасны дагуу шалгаж, хуваагаад шинээр хуваагдсан утгуудаас бүрдсэн карактер вектортой `list` -ийг үүсгэдэг.

Доорхи энгийн жишээгээр нэг стрингсийг хэрхэн гурав хуваахыг харуулав. Хуваагдсан дата `list` хэлбэртэй үүсдэг ба анх өгөгдсөн стрингс тус бүрт нэг элэмент (карактер вектор) үүсгэсэн байдаг. Хэрэв `simplify = TRUE` гэж өгвөл карактер матрикс үүсгэдэг.

Энэхүү жишээнд нэг стрингсийг `str_split()`-д өгөгдхөд нэг элементтэй list үүсч байна. Энэ элэмент гурван карактер утгаас бүртдсэн вектор байна.

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Үүссэн обьектийг хадгалчихвал цаашид дөрвөлжин хаалтыг ашиглан хүссэн n-дэх утгаа сугалж гаргах боломжтой болно. Ийм синтаксыг дараахь байдлаар бичдэг: `the_returned_object[[1]][2]` комманд эхний элементийн стрингс утгуудын хоёрдах утгыг гаргаж ирнэ ("fever"). [R basics] -ээс элэментэд орох гэсэн хэсгийг нэмж уншна уу.

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # list-ийн эхний элэментийн 2 дах утгыг гаргаж ирэх 
```

`str_split()` -д стрингсийг олноор нь өгч буй тохиолдолд үүсэх листний элэментийн тоо мөн олон болдог.

```{r}
symptoms <- c("jaundice, fever, chills",     # 1-р өвчтөн 
              "chills, aches, pains",        # 2-р өвчтөн
              "fever",                       # 3-р өвчтөн
              "vomiting, diarrhoea",         # 4-р өвчтөн
              "bleeding from gums, fever",   # 5-р өвчтөн
              "rapid pulse, headache")       # 6-р өвчтөн

str_split(symptoms, ",")                     # өвчтөн болгоны шинж тэмдгийг хуваах
```

"Карактер матрикс" үүсгэх шаардалгатай бол `simplify = TRUE` гэж тохируулна. Матрикс байгуулах нь цаашид багана бий болгоход хэрэгтэй байдаг.

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Мөн `n =` аргументээр хэдэн хэсэг болгож хуваахаа зааж өгч болно. Доорхи жишээнд хуваагдах тоог 2-оор хязгаарласан байна. Энэ заасан тооноос хойшхи таслалууд хоёр дах утганд хамрах болно.

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Тэмдэглэл -дээрхитэй ижил үр дүнг `str_split_fixed()` функцээр үйлдэж болно. Энэ функцэд `simplify` аргументийг өгөх шаардлагагүй харин баганын тоог заавал зааж өгөх шаардлагатай (`n`).*

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```

### Баганыг хуваах {.unnumbered}

Хүснэгтийн баганыг **dplyr**-ын `separate()`-ээр хуваавал илүү хялбар. Энэ функц карактер баганыг олон багана болгож хэсэглэн хуваадаг.

Жишээ нь энгийн нэгэн хүснэгт `df` байна гэж бодьё ( [unite section](#str_unite) хэсэгт нэгтгэгдсэн). Үүнд `case_ID`, болон өвчний шинж тэмдэг (`symptoms`) болон эмчилгээний үр дүн тус тус бичсэн баганууд байв. Бид `symptoms` баганын утгыг задалж нэг шинж тэмдэг нэг багана болж задарсан олон баганууд үүсгэх хэрэгтэй болов.

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

`separate()`хэрвээ pipe холбоосонд залгаатай бол эхлээд хуваагдах баганыг зааж өгнө. Үүний дөраа `into =` аргументнд *шинээр* үүсгэх баганын нэрсийг вектор хэлбэрээр `c( )` дотор оруулж бичнэ. Доор үзүүлсэн жишээнд харуулсан.

-   `sep =` зааглагч, тэмдэгт эсвэл тоо байж болно (interpreted as the character position to split at)

-   `remove =` default нь FALSE, ашиглагдаж орсон баганыг устгана\

-   `convert =` default нь FALSE, карактер хэлбэрт буй "NA"-г `NA` -руу хувиргана\

-   `extra =` шинээр багана үүсгэсний дараа багана болж ороогүй утга илүү гарвал дараахь нөхцлүүдээр тохируулдаг.

    -   `extra = "warn"` анхааруулга гарч ирэх боловч илүү утгууд устгагдна (**default**)\
    -   `extra = "drop"` анхааруулга гарч ирэхгүйгээр илүү утгууд устгагдна\
    -   **`extra = "merge"into`-д зааж өгсөн баганын тоонд хуваах болно - *гэхдээ бүх датаг хадгалж үлднэ***

Доорхи жишээнд `extra = "merge"` -ийг хэрэглэхэд ямар ч дата устгагдаагүй байна. Хоёр шинэ багана үүссэн ба үүнээс илүү гарсан хэсэг нь хоёр дах баганадаа үлдсэн байна:

```{r}
# гурав дах шинж тэмдэг хоёр дах утганд нэгтгэгдсэн
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

When the default `extra = "drop"` is used below, a warning is given but the third symptoms are lost:

```{r}
# гуравдах шинж тэмдэг алдагдсан байна
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```

[***АНХААРУУЛГА:*** Хэрэв `into` -д хангалттай тоог оруулахгүй бол дата тайрагдаж болохыг анхаар.]{style="color: orange;"}

<!-- ======================================================= -->

### Цагаан толгойн дарааллаар эрэмбэлэх {.unnumbered}

Олон стрингсүүдийг цагаан толгойн дарааллаар эрэмбэлж болно. `str_order()` функц дарааллын дугаарыг үүсгэж, `str_sort()` дарааллаар нь эрэмбэлж байрлуулдаг.

```{r}
# стрингс
health_zones <- c("Alba", "Takota", "Delta")

# цагаан толгойгоор дарааллаар дугаарлана
str_order(health_zones)

# цагаан толгойн дарааллаар эрэмбэлэн байрлуулна
str_sort(health_zones)
```

Өөр хэлний цагаан толгой хэрэглэх бол `locale =` аргументээр тохируулдаг. `locale =`-д орох жагсаалтыг R console-д `stringi::stri_locale_list()` гэж бичиж гаргаж ирнэ.

<!-- ======================================================= -->

### base R -ын функцууд {.unnumbered}

Векторуудыг бүхэлд нь карактерлуу хувиргаад, нэгтгэдэг `paste()`, `paste0()` гэсэн функцууд **base** R-т бий. Эдгээр нь `str_c()`-тэй төстэй боловч бичигдэх синтаксаараа арай өөр - хаалтан дотор, хэсэг тус бүрийн дунд таслал оруулах хэрэгтэй болдог. Эдгээр хэсгүүд нэг бол карактер текст (хашилтанд бичигдна) эсвэл тодорхой кодын обьектууд байна (хашилтгүй бичигднэ). Жишээ нь:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

`sep =` болон `collapse =` аргументыг тохируулж болно. `paste()` бол `sep = " "` гэсэн аргументтэй `paste0()` (зай авахгүй) гэсэн үг .

## Цэвэрлэх болон жигдрүүлэх

<!-- ======================================================= -->

### Үсгийн том жижигийг өөрчлөх {.unnumbered}

Стрингс дата янзалж байхад үсгийн том жижигийг тохируулах шаадрдлага их гардаг. Ийм стрингсүүдийн жишээнд нутаг дэвсгэрийн нэрс ордог. Үүнд **stringr**-ын `str_to_upper()`, `str_to_lower()`, `str_to_title()` нарыг дор жишээнд харуулсан шиг хэрэглэнэ.

```{r}
str_to_upper("California")

str_to_lower("California")
```

Мөн \*base\*\* R-ын `toupper()`, `tolower()`-аар адил үр дүнд хүрч болно.

**Гарчигны үсгийн том жижиг**

Бүх үгсийн эхний үсгийг томоор бичих бол `str_to_title()`-ийг хэрэглэнэ:

```{r}
str_to_title("go to the US state of california ")
```

**tools** багцын `toTitleCase()` -ыг хэрэглэвэл дээрх үйлдлийг арай боловсронгуй гүйцэтгэдэг ("to", "the", "of" зэрэг зарим туслах үгс том болж хувирахгүй).

```{r}
tools::toTitleCase("This is the US state of california")
```

`str_to_sentence()` -ээр стрингийн зөвхөн эхний үсгийг том болгоход хэрэглэнэ.

```{r}
str_to_sentence("the patient must be transported")
```

### Уртыг тааруулах {#str_pad .unnumbered}

Стрингст доод уртын хэмжээг хэд байхыг зааж өгч болох ба үүнийг `str_pad()` -аар гүйцэтгэнэ. Уртыг заасан хэмжээнд хүргэхийн тулд нэмдэг default тэмдэгт нь хоосон зай (space) боловч `pad =` аргументэд үүнийг сольж өгч болно.

```{r}
# өөр өөр урттай ICD  кодын стрингсүүд
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD кодын баруун талд 7 карактер нэмж стрингсүүдийн уртыг тэнцүүлнэ
str_pad(ICD_codes, 7, "right")

# зай авахын оронд цэг нэм
str_pad(ICD_codes, 7, "right", pad = ".")
```

Доорхи жишээнд 0 -оор эхэлдэг (минут цаг гэх мэт) тоон утгуудыг дор хаяж 2 оронтой байлгахын тулд урд талдаа `pad = "0"` -гэж тохируулсан.

```{r}
# 2 орон болтол нь урд нь 0-ыг нэмнэ (цаг/минут)
str_pad("4", 2, pad = "0") 

# "цаг" гэсэн тоон багана нэм
# hours <- str_pad(hours, 2, pad = "0")
```

### Огтлох {.unnumbered}

`str_trunc()` -ээр стрингсийн дээд уртыг зааж өгнө. Хэрэв стрингс энэнээс урт бол огтлогддог (богиносно). Гэхдээ анхны утга урт байсныг сануулж эллипсис буюу гурван цэг (...) ард нь нэмж өгдөг. Гурван цэг нь өөрөө уртад тоологдох болохыг анхаар. Гурван цэгийн оронд өөр тэмдэг оруулахдаа `ellipsis =` аргументийг ашиглана. `side =` аргументээр гурван цэг огтлогдсон стрингсийн аль талд байрлахыг зааж өгнө ("зүүн", "баруун", "төв").

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```

### Уртыг жигдрүүлэх {.unnumbered}

Уртын дээд хэмжээг `str_trunc()` -аар зааж өгдөг бол хэт богино стрингсийг `str_pad()`-аар заасан цэг хүртэл сунгаж болдог. Доорх жишээнд уртын дээд хэмжээг 6 гэж заасан (ингэснээр нэг утга огтлогдсон). Үүний дараа их богино хэмжээтэй нэг стрингс байгааг 6 болгож уртасгасан.

```{r}
# Өөр урттай бичигдсэн ICD код
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# уртын дээд хязгаарыг 6 болгох
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# доод хязгаарыг 6 болгож уртасга
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```

### Илүү гарсан хоосон зайг арилгах {.unnumbered}

Стрингc утганд нэмэлт хоосон зай, шинэ мөр (`\n`), таб (`\t`) зэрэг илүүдлээр орсон бол эдгээрийг `str_trim()` - ээр тайрч болно. Тайрах талын байрлалыг `"right"` `"left"`, `"both"` гэж зааж өгч болно ( жишээ нь `str_trim(x, "right")`.

```{r}
# ID дугааруудын баруун талд илүү зай байна
IDs <- c("provA_1852  ", # 2 орон илүү зай
         "provA_2345",   # илүү зай байхгүй
         "provA_9460 ")  # 1 орон илүү зай 

# ID дугаартай стрингсийн зөвхөн баруун талын илүү зайг тайрах
str_trim(IDs)
```

### Давтагдсан хоосон зайг арилгах {.unnumbered}

Стрингсийн *завсар* хоосон зай давтагдсан бол `str_squish()`-ээр үүнийг янзалж болно. Давхар хоосон зай нэг хоосон зай болдог. Стрингсийн хажуугийн хоосон зай, шинэ мөр, таб -ыг `str_trim()` -ээр янзалж болно.

```{r}
# Эх текстийн завсарт хэт их зай авсагдсан байна
str_squish("  Pt requires   IV saline\n") 
```

Эдгээр функцын талаарх нэмэлт мэдээллийг R console -д `?str_trim`, `?str_pad` гэсэн комманд уншуулж авна уу.

### Параграф болгож нэгтгэх {.unnumbered}

Ямар ч бүтэц, хэвгүй үргэлжилсэн текстийг нэтгэж, бүтэцжүүлж, мөрийн уртыг зааж өгөн параграф хэвлбэрт оруулах бол `str_wrap()` -ыг хэрэглэ. Мөрний хэр урт байхыг зааж өгснөөр текст дундуур мөрүүд алгоритмын дагуу бий болж параграф хэлбэрт орно (жишээ дор харуулсан).

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

Дээрх коммандын үр дүнг хэвлэх бол **base** -ын `cat()` -д функц дотор коммандаа уншуулна уу.

```{r}
cat(str_wrap(pt_course, 40))
```

<!-- ======================================================= -->

## Байрлалаар нь янзлах

### Карактерийг байрлалаар гаргаж ирэх {.unnumbered}

Стрингсийг хэсэглэж гаргаж авах шаардлагтай үед `str_sub()` -ийг хэрэглэдэг. Энэхүү функц гурван үндсэн аргумент авдаг:

1)  карактер вектор(-ууд)\
2)  эхлэх байрлал\
3)  дуусах байрлал

Байрлалын дугаарлах талаар:

-   Хэрэв байрлал эерэг бол стрингсийн зүүн үзүүрээс эхэлж тоологдсон гэсэн үг\
-   Хэрэв байрлал сөрөг бол стрингсийн баруун үзүүрээс эхэлж тоологдсон гэсэн үг\
-   Байрлалын дугаар нь нээлттэй (inclusive)\
-   Стрингсээс гадуур байрлал огтлогддог (устгагдна).

Дор "pneumonia" гэсэн стрингсийг жишээ болгож үзүүлэв:

```{r}
# зүүн талын үзүүрээс тоолж гуравдах орноос эхэлж гурав дах орон дээр дуусна (зүүн талаас гурав дах үсэг)
str_sub("pneumonia", 3, 3)

# 0 гэсэн байрлал байхгүй 
str_sub("pneumonia", 0, 0)

# зүүн талаас 6 даха орноос баруун талаас 1 дэх хүртэл
str_sub("pneumonia", 6, -1)

# баруун талаас 5 дахаас орноос баруун талаас 2 дах хүртэл 
str_sub("pneumonia", -5, -2)

# зүүн талаасаа 4 дэх орноос стрингсийн гадна давж гартал
str_sub("pneumonia", 4, 15)
```

### Үгийн байрлалаар гаргаж ирэх {.unnumbered}

Стрингсээс n-дүгээр 'үгийг' гаргаж авахдаа мөн **stringr**-ийн `word()`функцыг хэрэглэдэг. Эхлээд шүүлт хийх стрингсээ оруулна. Үүнээс тасалж авах хэсгийн эхлэх үгийн байрлал, төгсгөл үгийн байрлалыг зааж өгнө.

Үүссэн стрингст үг хоорондын завсар орох default тэмдэгт нь хоосон зай боловч `sep =` -д үүнийг сольж болно (жишээ нь `sep = "_"` доогуур зураасыг оруулахаар зааж өгч болно).

```{r}
# Шүүлт хийх стрингс
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# Стрингс тус бүрийн 1 дэхээс 3д ах үгийг гаргаж ирэх
word(chief_complaints, start = 1, end = 3, sep = " ")
```

### Карактерийн байрлалаар орлуулах {.unnumbered}

Стрингсийн нэг хэсэгт өөрчлөлт оруулах шаардлагтай бол `str_sub()` болон (`<-`) оноогч операторыг хамтарч хэрэглэнэ.

```{r}
word <- "pneumonia"

# 3,4 дүгээр карактерийг X -ээр орлуул
str_sub(word, 3, 4) <- "XX"

# Хэвлэ
word
```

Дээрхи жишээг стрингсийн векторт хэрэглэж үзье (эсвэл багана). "HIV"-ийн хэмжээ уртасч байгааг анзаарна уу.

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# 3,4 дүгээр карактерийг X -ээр орлуул
str_sub(words, 3, 4) <- "XX"

words
```

### Уртыг шалга {.unnumbered}

```{r}
str_length("abc")
```

**base** R-ын `nchar()` -ыг бас хэрэглэж болно.

<!-- ======================================================= -->

## Хэв маяг

Аливаа *хэв маягт* тааруулан илрүүлэх, байрлуулах, гаргаж авах, тааруулах, орлуулах, хуваах үйлдлйиг хийдэг функцууд **stringr** багцад буй .

<!-- ======================================================= -->

### Хэв маягийг илрүүлэх {.unnumbered}

Стрингс доторх аливаа хэв маягийг `str_detect()` -ээр хайж, илрүүлдэг. Эхлээд шүүлт явуулах стрингс эсвэл вектороо оруулаад (`string =`), дараа нь хайж буй хэв маягийг зааж өгнө (`pattern =`). Default -аар *үсгийн том жижиг хамаатай* !

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

Хэрэв `negate =` аргументийг нэмж `TRUE` гэж тохируулбал тухайн заасан хэв маяг БАЙХГҮЙ эсэхийг шалгадаг.

```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

Хэрэв үсгийн том жижигийг хамаарахгүй болгохын тулд хайлт хийх хэв маягаа `regex()` функцэд оруулаад `regex()` *дотор* `ignore_case = TRUE` гэсэн тохиргоо хийдэг (эсвэл `T` гэж товчилж болно).

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

Карактер вектор эсвэл хүснэгтийн баганад `str_detect()` функцыг уншуулбал TRUE эсвэл FALSE гэсэн логик утгатай вектор үүснэ.

```{r}
# мэргэжил бүртгэсэн вектор/хүснэгтийн багана
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# стрингс тус бүрт "teach" гэсэн хэв маяг/үг байгаа эсэхийг шалгаж үр дүнг TRUE/FALSE-оор харуулна
str_detect(occupations, "teach")
```

Үүнийг `sum()` -ын дотор оруулж нийт хэдэн `TRUE`- байгааг тоолж болно.

```{r}
sum(str_detect(occupations, "teach"))
```

Олон янзын хэв маяг хайх бол тэдгээгийг жагсаан ЭСВЭЛ (`|`) тэмдэгтээр тусгаарлаж бичээд `pattern =` аргументэд дор харуулсан шиг бичнэ:

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

Хайлт хийх хэв маягийн жагсаалт их урт тохиолдолд эхлээд `str_c()` болон `sep = |`-ийг хавсарч хэрэглээд, карактер гэдгийг нь зааж өгвөл цаашид хайлтаа арай товч болгож болно. Доорх жишээнд эрүүл мэндийн ажилтнуудын тэргүүн шугаманд ажилладаг мэргэжлийн нэрсээр хайлт хийж байна.

```{r}
# олон янзын хэв маягийг хайх
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

Дараах коммандыг уншуулснаар occupations бүртгэлд дээрх жагсаалттай (`occupation_med_frontline`) тохирсон мэргэжлүүд хэд байгааг харуулна:

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```

**Base R -ын стрингс хайх функцууд**

**base** -ын функц болох `grepl()` нь `str_detect()` -тэй төстэй үйлдэлтэй. Энэ функц таарсан бүтцийг хайж логик вектор үүсгэдэг. Үндсэн синтакс нь `grepl(бүтэц, хайх_стрингс, ignore.case = FALSE, ...)`. Давуу тал нь `ignore.case` аргументийг бичихэд хялбар ( `regex()` функцтэй хавсарч хэрэглэх шаардлагагүй).

Мөн **base** -ын функц болох `sub()`, `gsub()` нар нь `str_replace()`-тэй төстэй үйлдэлтэй. Үндсэн синтакс нь: `gsub(бүтэц, орлуулалт, хайх_стрингс, ignore.case = FALSE)`. `sub()` функц уншуулахад өгөгдсөн хэв маягт таарсан эхний тохиолдлыг орлуулдаг бол `gsub()` функцыг уншуулахад өгөгдсөн бүтэцтэй таарсан бүх тохиолдлуудыг орлуулна.

#### Таслалыг цэгээр солих {.unnumbered}

Тоон векторуудад буй таслалуудыг `gsub()` ашиглаж цэгээр хэрхэн солихыг харуулав. Ингэж цэгээр солих үйлдлйиг АНУ, Их Британийн бус гаралтай датанд их хийдэг.

Доорх жишээнд эхлээд дотор талд буй `gsub()` нь `lengths` баганыг уншиж, үүнд агуулагдаж бүх цэгийг "" (зайгүй хоосон) болгож хувиргаж байна. Ингэхдээ "." гэсэн тэмдэгтийг алгасахын тулд хоёр ташуу зураас оруулж өгнө. Учир нь regex -т "." нь "бүх тэмдэгт" ( "any character")-ийг илэрхийлдэг. Үүссэн (зөвхөн таслалтай) үр дүн гаднах `gsub()` -д уншигдах ба ингэснээр бүх таслалууд цэг болж хувирна.

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # бүх таслалыг  
                replacement = ".",            # цэгээр солих
                x = gsub("\\.", "", lengths)  # цэг агуулсан бусад векторуудыг арилгах (цэг ())
                )
           )                                  # үр дүнг тоон утга болго
```

### Бүгдийг зэрэг солих {.unnumbered}

`str_replace_all()` -ыг "олоод ёоль" гэсэн үйлдэл хийхэд ашигладаг. Эхлээд шүүлт хийх стрингсээ `string =`-нд, хайлт хийх бүтцээ `pattern =`-нд, сольж тавих утгаа `replacement =`-нд тус тус зааж өгнө. Доорхи жишээгээр бүх "dead" гэсэн утгыг "deceased" болгож солих болно. Үсгийн том жижиг хамаатай болохыг анхаарна уу.

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Тэмдэглэл:

-   Аливаа хэв маягийг `NA`-аар солиход `str_replace_na()` функцыг хэрэглэдэг.\
-   `str_replace()` функц шалгагдаж буй стрингс тус бүрийн зөвхөн эхний тохиолдлыг л сольдог.

<!-- ======================================================= -->

### Логик дотор илрүүлэх {.unnumbered}

**`case_when()` дотор**

`str_detect()` -ийг (**dplyr**-ын) `case_when()`-ын дотор хэрэглэх нь их. Жишээнд linelist -д `occupations` хэмээх баганыг авч үзье. Энэхүү баганад логик нөхцлийг `case_when()` -ээр оруулж, үүнийгээ `mutate()` дотор оруулсгнаар `is_educator` гэсэн шинэ багана үүсгэж байна. `case_when()`-ийн талаар дата цэвэрлэгээг тайлбарласан хэсгээс лавшруулж уншиж болно.

```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # occupation дотор хийгдэж буй хайлтад үсгийн жижиг том хамаагүй
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # бусад бүх
    TRUE                                               ~ "Not an educator"))
```

Оруулахгүй хэв маягийг логик нөхцөлд зааж өгч болно (`negate = F`):

```{r, eval=F}
df <- df %>% 
  # шинээр үүсгэсэн is_educator багана дах утгыг логик нөхцлөөр үүсгэсэн 
  mutate(is_educator = case_when(
    
    # occupation баганын утга хоёр шалгуурт нийцэж байж "Educator" баганын утга болж чадна:
    # it must have a search term AND NOT any exclusion term
    
    # Хайлт хийх хэв маягууд
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # AND must NOT have an exclusion term
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # Дээрх шалгуурт нийцэхгүй бусад бүх нөхцлүүд
    TRUE                                            ~ "Not an educator"))
```

<!-- ======================================================= -->

### Хэв маягийн байрлалыг тогтоох {.unnumbered}

Хайлт хийж буй хэв маягийн эхний байрлалыг тогтоохын тулд `str_locate()`-ыг хэрэглэ. Эхлэл болон төгсгөл хэсгээр нь хайдаг.

```{r}
str_locate("I wish", "sh")
```

Бусад `str` функцын адил дээрх функцэд хэв маяг таарч буй *бүх* тохиолдлуудыг (стрингс тус бүрээс) гаргаж ирдэг "\_all" хувилбар (`str_locate_all()`) бас байна. Үүний хайлтын үр дүн `list` -ээр үүсдэг.

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # Хайлт хийж буй хэв маягтай тохирох *эхний* тохиолдлыг олох
str_locate_all(phrases, "h" ) # Хайлт хийх хэв маягтай тохирсон *бүх* тохиолдлыг олох
```

<!-- ======================================================= -->

### Хэв маягийг тааруулж сугалж гаргах  {.unnumbered}

Олон хэв маягийг зэрэг ЭСВЭЛ (`|`) нөхцөлтэйгээр зэрэг хайж буй үед `str_extract_all()` -ийг хэрэглэснээр тохирох хэв маягууд тэр хэвээрээ гарч ирдэг давуу талтай. Жишээ нь occupations гэсэн стрингс векторт (дээр бичигдсэн табд буй) "teach", "prof", "tutor" гэсэн хэв маяг/үгийн *аль нэгийг* хайя.

Энэ үед `str_extract_all()` функ стрингс бүрийн *таарсан* хэв маяг/үгсийг ялгаж цуглуулсан `list` үүсдэг. Доорх жишээнд бичсэн 3 мэргэжлийн 2 бүтэц occupations датанд таарч байна.

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```

`str_extract()` функц стрингс тус бүрийн *зөвхөн эхний таарсан хэв маяг/үгийг* гаргаж ирдэг. Ингэснээр стрингс тус бүрт нэг элэменттэй карактер вектор үүсдэг. Тохироо таараагүй утгуудад `NA` үүсдэг. Үүссэн векторыг `na.exclude()`-д оруулснаар `NA`-г арилгаж болно. occupation 3-ын хоёрдах тохироо харагдахгүй байгааг анзаарна уу.

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->

### Хэсэгчлэх ба тоолох {.unnumbered}

Эдгээр үйлдлийг `str_subset()`, `str_count()` гүйцэтгэдэг.

Аливаа хэв маягийг `str_subset()` -ээр хайснаар таарсан хэв маягийг агуулж буй утга анхны хэлбэрээр гарч ирдэг.

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` -ээр тоон вектор үүсдэг: шалгагдсан утга бүрт хайгдаж буй хэв маяг **хэдэн ширхэг** байгаа нь гарч ирдэг.

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```

<!-- ======================================================= -->

### Regex-ийн группууд {.unnumbered}

ХИЙГДЭЖ БУЙ

<!-- ======================================================= -->

## Өвөрмөц карактерүүд

**Арагшаа ташуу зураас `\` бол "алгасах тэмдэг"**

Арагшаа ташуу зураасыг `\` арынх нь карактер утгыг "алгасах" зориулалтаар хэрэглэдэг. Тиймээс арагшаа ташуу зураасыг хашилтан *доторх* хашилттай хамт хэрэглэдэг (`"\""`) - дундах хашилт хоёр захын хашилтуудыг *эвдлэхгүй*.

Тэмдэглэл - хэрэв арагшаа ташуу зураасыг *хэвлэх* бол, *дахин нэг* арагшаа ташуу зураас бичих шаардлагатай болдог. Өөрөөр хэлбэл нэг арагшаа ташуу зураас бичихийн тулд хоёр ташуу зураастай код бичнэ (`\\`).

**Өвөрмөц карактерүүд**

| Өвөрмөц карактерүүд                                                               | Зориулалт                            |
|-----------------------------------------------------------------------------------|--------------------------------------|
| `"\\"`                                                                            | Арагшаа ташуу зураас                 |
| `"\n"`                                                                            | шинэ мөр (newline)                   |
| `"\""`                                                                            | давхар хашилт *доторх* давхар хашилт |
| `'\''`                                                                            | дан хашилт *доторх* дан хашилт       |
| `"\`"`| grave accent`"\r"`| carriage return`"\t"`| tab`"\v"`| vertical tab`"\b"\` | backspace                            |

Эдгээр өвөрмөц карактерүүдийн бүрэн жагсаалтыг R Console -д `?"'"` гэж уншуулж гаргаж ирнэ ( RStudio -ын Help цонхонд харагдна).

<!-- ======================================================= -->

## Regular expressions (regex)

<!-- ======================================================= -->

## Regex болон өвөрмөц карактерүүд

Regular expressions, буюу "regex" бол стрингсийн доторх хэв маяг, бүтцийг дүрсэлж хураангуйлсан хэл юм. Regular expressions-ыг сайн мэдэхгүй хүнд харь гаригийн бичиг шиг харагддаг. Энэхүү хэсэгт энэ хэлийн тайллыг тайлбарлахыг зорилоо.

*Энэ хэсгийн ихэнх агуулгыг [this tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) болон [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) линкүүдээс авсан*. Энэхүү линкийн хичээлийг интернетгүй газар хэрэглэх боломжгүй тул бид энэхүү номондоо сонгож шилээд заримыг нь оруулсан.

regular expression -ыг "бүтэцгүй" текстнээс бүтэц хайж илрүүлэхэд хэрэглэдэг - үүний жишээнд өвчний түүх, өргөдөл, гомдол, эмнэлэгийн тэмдэглэл болоэ хүснэгтэлсэн сул текстүүд ордог.

regular expression -ын үндсэн хэсгийг дараах дөрвөн аргаар бүтээдэг:

1)  Карактер багц\
2)  Мета карактер\
3)  Тоон үзүүлэлт\
4)  Бүлэг

**Карактер багц**

Карактерийн сонголтуудыг жагсаалтаар илэрхийлж, хаалтанд дотор багцлах арга юм. Аливаа стрингст хайлт хийж буй карактерүүдийн аль нэг нь олдвол тохироо үүслээ гэж үзнэ. Жишээ нь эгшиг үсгүүдийг хайхын тулд "[aeiou]" гэсэн карактер багцыг хэрэглэдэг. Нийтлэг хэрэглэгддэг карактер багцуудыг дор жагсаав:

| Карактер багц | Илэрхийлэх утга                 |
|---------------|---------------------------------|
| `"[A-Z]"`     | томоор бичсэн бүх үсэг          |
| `"[a-z]"`     | жижигээр бичсэн бүх үсэг        |
| `"[0-9]"`     | бүх цифр                        |
| `[:alnum:]`   | тоон болон үсгэн бүх тэмдэгтүүд |
| `[:digit:]`   | бүх тоон цифр                   |
| `[:alpha:]`   | бүх үсэг (том болон жижиг үсэг) |
| `[:upper:]`   | томоор бичсэн бүх үсэг          |
| `[:lower:]`   | жижигээр бисэн бүх үсэг         |

Карактер багцуудыг хамтад нь зэрэг нэг хаалтанд бичиж болно (зай авахгүй!). Жишээ нь `"[A-Za-z]"` (том болон жижиг бүх үсгүүд), `"[t-z0-5]"` (жижиг t-ээс z хүртэл ЭСВЭЛ 0-оос 5 хүртэл) гэх мэтээр бичиж болно.

**Мета карактер**

Мета карактер нь карактер багцын товчилсон хэлбэр. Нийтлэг хэрэглэгддэг мета карактерүүдийг дор жагсаав:

| Мета карактерүүд | Илэрхийлэх утга                                        |
|------------------|--------------------------------------------------------|
| `"\\s"`          | нэг хоосон зай                                         |
| `"\\w"`          | нэг ширхэг тоон болон үсгэн тэмдэгт (A-Z, a-z, or 0-9) |
| `"\\d"`          | нэг ширхэг тоон цифр (0-9)                             |

**Олшруулагч**

Зөвхөн нэг карактер хайх тохиолдол бараг гардаггүй. Иймээс олшруулагч ашиглаж урт хэмжээний үсэг/тоон хайлт хийдэг .

Олшуурах гэж буй карактерийн *ард* олшруулах тоог `{ }` хаалтанд дотор бичдэг,

-   `"A{2}"` нь **хоёр** том A үсэг илэрхийлнэ.\
-   `"A{2,4}"` нь **2 оос 4 -н** том A үсгийг илэрхийлнэ *(зай авч болохгүй!)*.\
-   `"A{2,}"` **2 болон түүнээс дээш** тооны том А үсгийг илэрхийлнэ.\
-   `"A+"` **нэг болон түүнээс дээш** тооны том А үсгийг илэрхийлнэ (өөр карактер гарч иртэл энэ бүлэг үргэлжлэх болно).\
-   Хэрэв од `*` тэмдэг урд нь тавьбал **0 болон түүнээс дээш** тохироо буй эсэхийг харуулна (тухайн хэв маяг байгаа эсэх нь эргэлзээтэй үед байгаа хэрэг болдог).

Нэмэх `+` тэмдгийг олшуулагчаар өгвөл таарсан хэв маягийг дараачийн карактер гарч иртэл хайх болно. Жишээ нь `"[A-Za-z]+"` (цагаан толгойн карактерүүд) -ээр бүх *үгсийг* илэрхийлнэ:

```{r}
# олшруулагчийг шалгах тест стринг
test <- "A-AA-AAA-AAAA"
```

Олшруулагчийг {2} гэж өгвөл зөвхөн дараалласан A -г л гаргаж ирнэ. Жишээ нь `AAAA`-д хоёр хос дараалласан А байна.

```{r}
str_extract_all(test, "A{2}")
```

Хэрэв олшруулагч {2,4} бол 2 -оос 4 удаа дараалласан A байх тохиолдлуудыг гаргаж ирнэ.

```{r}
str_extract_all(test, "A{2,4}")
```

Хэрэв олшруулагч `+` бол **нэг болон түүнээс дээш** тооны А байх тохиолдлууд гарч ирнэ:

```{r}
str_extract_all(test, "A+")
```

**Харьцангуй байрлал**

Эдгээр нөхцлүүд хайж буй хэв маягийн өмнө болон хойно нь юу байгаа вэ гэдгээр илэрхийлэгддэг. Жишээ нь "хоёр тооны ардах цэг" (`""`). (?\<=\\.)\\s(?=[A-Z])

```{r}
str_extract_all(test, "")
```

| Байрлын илэрхийлэл | Илэрхийлэх утга               |
|--------------------|-------------------------------|
| `"(?<=b)a"`        | **урдаа** "b" тэй "a"         |
| `"(?<!b)a"`        | **урдаа** "b" **БАЙХГҮЙ** "a" |
| `"a(?=b)"`         | **ардаа** "b" тэй "a"         |
| `"a(?!b)"`         | **урдаа** "b" **БАЙХГҮЙ** "a" |

**Бүлгүүд**

regular expression ийг бүлэглэснээр үр дүн илүү зохион байгуулалттайгаар гарч ирдэг.

**Regex -ын жишээ**

Сул текст дээр хэрхэн ажиллах талаар жишээ дор харуулав. Үүнээс бид regular expression-ийн хайлтын дүрмээр хэрэгтэй мэдээллээ гаргаж авах болно.

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Энэхүү илэрхийлэл нь бүх үгтэй тохирч байна (тохироо нь бүх карактертэй тохирох ба хоосон зай гэх мэт үсэг биш карактер гарч иртэл үргэлжилнэ):

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

`"[0-9]{1,2}"` бол үргэлжилсэн, 1 ээс 2 орон тоог илэрхийлэл. Үүнийг мөн `"\\d{1,2}"`, эсвэл `"[:digit:]{1,2}"` гэж бичиж болно.

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- нь бүх өгүүлбэрийг илэрхийлнэ (ингэхдээ өгүүлбэрийн эхний үсэг томоор, бичигдсэн ба өгүүлбэр төгсөхөд цэг тавигдсан гэж үзнэ). Илэрхийлсэн бүтэц Англи хэлээр уншигдахдаа: "Ардаасаа жижиг үсэгнүүд, хоосон зай, хэдэн үсэг, зай гэх мэтээр дагуулсан том үсэг     -->

<!-- ```{r} -->

<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->

<!-- ``` -->

Дараах линкийн 2 дугаар хуудаснаас чухал regex expressions-үүд, хэрэгтэй зөвлөгөөнүүдтэй танилцаж болно [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Мөн [tutorial](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) линкээс нэмэлт мэдээлэл авна уу.

<!-- ======================================================= -->

## Эх сурвалж материалууд

**stringr** функцын лавлагаа хуудсыг дараах линкээс үзэж болно: [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

**stringr** -ын винньетийг дараах линкээс үзэж болно: [here](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
